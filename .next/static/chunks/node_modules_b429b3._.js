(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_b429b3._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter)
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config.children;
            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                Object.freeze && Object.freeze(children);
            } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else validateChildKeys(children, type);
        } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
        }
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/@atproto/syntax/dist/handle.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DisallowedDomainError = exports.UnsupportedDomainError = exports.ReservedHandleError = exports.InvalidHandleError = exports.isValidTld = exports.isValidHandle = exports.normalizeAndEnsureValidHandle = exports.normalizeHandle = exports.ensureValidHandleRegex = exports.ensureValidHandle = exports.DISALLOWED_TLDS = exports.INVALID_HANDLE = void 0;
exports.INVALID_HANDLE = 'handle.invalid';
// Currently these are registration-time restrictions, not protocol-level
// restrictions. We have a couple accounts in the wild that we need to clean up
// before hard-disallow.
// See also: https://en.wikipedia.org/wiki/Top-level_domain#Reserved_domains
exports.DISALLOWED_TLDS = [
    '.local',
    '.arpa',
    '.invalid',
    '.localhost',
    '.internal',
    '.example',
    '.alt',
    // policy could concievably change on ".onion" some day
    '.onion'
];
// Handle constraints, in English:
//  - must be a possible domain name
//    - RFC-1035 is commonly referenced, but has been updated. eg, RFC-3696,
//      section 2. and RFC-3986, section 3. can now have leading numbers (eg,
//      4chan.org)
//    - "labels" (sub-names) are made of ASCII letters, digits, hyphens
//    - can not start or end with a hyphen
//    - TLD (last component) should not start with a digit
//    - can't end with a hyphen (can end with digit)
//    - each segment must be between 1 and 63 characters (not including any periods)
//    - overall length can't be more than 253 characters
//    - separated by (ASCII) periods; does not start or end with period
//    - case insensitive
//    - domains (handles) are equal if they are the same lower-case
//    - punycode allowed for internationalization
//  - no whitespace, null bytes, joining chars, etc
//  - does not validate whether domain or TLD exists, or is a reserved or
//    special TLD (eg, .onion or .local)
//  - does not validate punycode
const ensureValidHandle = (handle)=>{
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9.-]*$/.test(handle)) {
        throw new InvalidHandleError('Disallowed characters in handle (ASCII letters, digits, dashes, periods only)');
    }
    if (handle.length > 253) {
        throw new InvalidHandleError('Handle is too long (253 chars max)');
    }
    const labels = handle.split('.');
    if (labels.length < 2) {
        throw new InvalidHandleError('Handle domain needs at least two parts');
    }
    for(let i = 0; i < labels.length; i++){
        const l = labels[i];
        if (l.length < 1) {
            throw new InvalidHandleError('Handle parts can not be empty');
        }
        if (l.length > 63) {
            throw new InvalidHandleError('Handle part too long (max 63 chars)');
        }
        if (l.endsWith('-') || l.startsWith('-')) {
            throw new InvalidHandleError('Handle parts can not start or end with hyphens');
        }
        if (i + 1 === labels.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError('Handle final component (TLD) must start with ASCII letter');
        }
    }
};
exports.ensureValidHandle = ensureValidHandle;
// simple regex translation of above constraints
const ensureValidHandleRegex = (handle)=>{
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(handle)) {
        throw new InvalidHandleError("Handle didn't validate via regex");
    }
    if (handle.length > 253) {
        throw new InvalidHandleError('Handle is too long (253 chars max)');
    }
};
exports.ensureValidHandleRegex = ensureValidHandleRegex;
const normalizeHandle = (handle)=>{
    return handle.toLowerCase();
};
exports.normalizeHandle = normalizeHandle;
const normalizeAndEnsureValidHandle = (handle)=>{
    const normalized = (0, exports.normalizeHandle)(handle);
    (0, exports.ensureValidHandle)(normalized);
    return normalized;
};
exports.normalizeAndEnsureValidHandle = normalizeAndEnsureValidHandle;
const isValidHandle = (handle)=>{
    try {
        (0, exports.ensureValidHandle)(handle);
    } catch (err) {
        if (err instanceof InvalidHandleError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidHandle = isValidHandle;
const isValidTld = (handle)=>{
    return !exports.DISALLOWED_TLDS.some((domain)=>handle.endsWith(domain));
};
exports.isValidTld = isValidTld;
class InvalidHandleError extends Error {
}
exports.InvalidHandleError = InvalidHandleError;
class ReservedHandleError extends Error {
}
exports.ReservedHandleError = ReservedHandleError;
class UnsupportedDomainError extends Error {
}
exports.UnsupportedDomainError = UnsupportedDomainError;
class DisallowedDomainError extends Error {
}
exports.DisallowedDomainError = DisallowedDomainError; //# sourceMappingURL=handle.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/did.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDidError = exports.ensureValidDidRegex = exports.ensureValidDid = void 0;
// Human-readable constraints:
//   - valid W3C DID (https://www.w3.org/TR/did-core/#did-syntax)
//      - entire URI is ASCII: [a-zA-Z0-9._:%-]
//      - always starts "did:" (lower-case)
//      - method name is one or more lower-case letters, followed by ":"
//      - remaining identifier can have any of the above chars, but can not end in ":"
//      - it seems that a bunch of ":" can be included, and don't need spaces between
//      - "%" is used only for "percent encoding" and must be followed by two hex characters (and thus can't end in "%")
//      - query ("?") and fragment ("#") stuff is defined for "DID URIs", but not as part of identifier itself
//      - "The current specification does not take a position on the maximum length of a DID"
//   - in current atproto, only allowing did:plc and did:web. But not *forcing* this at lexicon layer
//   - hard length limit of 8KBytes
//   - not going to validate "percent encoding" here
const ensureValidDid = (did)=>{
    if (!did.startsWith('did:')) {
        throw new InvalidDidError('DID requires "did:" prefix');
    }
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9._:%-]*$/.test(did)) {
        throw new InvalidDidError('Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)');
    }
    const { length, 1: method } = did.split(':');
    if (length < 3) {
        throw new InvalidDidError('DID requires prefix, method, and method-specific content');
    }
    if (!/^[a-z]+$/.test(method)) {
        throw new InvalidDidError('DID method must be lower-case letters');
    }
    if (did.endsWith(':') || did.endsWith('%')) {
        throw new InvalidDidError('DID can not end with ":" or "%"');
    }
    if (did.length > 2 * 1024) {
        throw new InvalidDidError('DID is too long (2048 chars max)');
    }
};
exports.ensureValidDid = ensureValidDid;
const ensureValidDidRegex = (did)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints
    if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(did)) {
        throw new InvalidDidError("DID didn't validate via regex");
    }
    if (did.length > 2 * 1024) {
        throw new InvalidDidError('DID is too long (2048 chars max)');
    }
};
exports.ensureValidDidRegex = ensureValidDidRegex;
class InvalidDidError extends Error {
}
exports.InvalidDidError = InvalidDidError; //# sourceMappingURL=did.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/nsid.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
/*
Grammar:

alpha     = "a" / "b" / "c" / "d" / "e" / "f" / "g" / "h" / "i" / "j" / "k" / "l" / "m" / "n" / "o" / "p" / "q" / "r" / "s" / "t" / "u" / "v" / "w" / "x" / "y" / "z" / "A" / "B" / "C" / "D" / "E" / "F" / "G" / "H" / "I" / "J" / "K" / "L" / "M" / "N" / "O" / "P" / "Q" / "R" / "S" / "T" / "U" / "V" / "W" / "X" / "Y" / "Z"
number    = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" / "0"
delim     = "."
segment   = alpha *( alpha / number / "-" )
authority = segment *( delim segment )
name      = alpha *( alpha )
nsid      = authority delim name

*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidNsidError = exports.ensureValidNsidRegex = exports.ensureValidNsid = exports.NSID = void 0;
class NSID {
    static parse(nsid) {
        return new NSID(nsid);
    }
    static create(authority, name) {
        const segments = [
            ...authority.split('.').reverse(),
            name
        ].join('.');
        return new NSID(segments);
    }
    static isValid(nsid) {
        try {
            NSID.parse(nsid);
            return true;
        } catch (e) {
            return false;
        }
    }
    constructor(nsid){
        Object.defineProperty(this, "segments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        (0, exports.ensureValidNsid)(nsid);
        this.segments = nsid.split('.');
    }
    get authority() {
        return this.segments.slice(0, this.segments.length - 1).reverse().join('.');
    }
    get name() {
        return this.segments.at(this.segments.length - 1);
    }
    toString() {
        return this.segments.join('.');
    }
}
exports.NSID = NSID;
// Human readable constraints on NSID:
// - a valid domain in reversed notation
// - followed by an additional period-separated name, which is camel-case letters
const ensureValidNsid = (nsid)=>{
    const toCheck = nsid;
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
        throw new InvalidNsidError('Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)');
    }
    if (toCheck.length > 253 + 1 + 63) {
        throw new InvalidNsidError('NSID is too long (317 chars max)');
    }
    const labels = toCheck.split('.');
    if (labels.length < 3) {
        throw new InvalidNsidError('NSID needs at least three parts');
    }
    for(let i = 0; i < labels.length; i++){
        const l = labels[i];
        if (l.length < 1) {
            throw new InvalidNsidError('NSID parts can not be empty');
        }
        if (l.length > 63) {
            throw new InvalidNsidError('NSID part too long (max 63 chars)');
        }
        if (l.endsWith('-') || l.startsWith('-')) {
            throw new InvalidNsidError('NSID parts can not start or end with hyphen');
        }
        if (/^[0-9]/.test(l) && i === 0) {
            throw new InvalidNsidError('NSID first part may not start with a digit');
        }
        if (!/^[a-zA-Z]+$/.test(l) && i + 1 === labels.length) {
            throw new InvalidNsidError('NSID name part must be only letters');
        }
    }
};
exports.ensureValidNsid = ensureValidNsid;
const ensureValidNsidRegex = (nsid)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(nsid)) {
        throw new InvalidNsidError("NSID didn't validate via regex");
    }
    if (nsid.length > 253 + 1 + 63) {
        throw new InvalidNsidError('NSID is too long (317 chars max)');
    }
};
exports.ensureValidNsidRegex = ensureValidNsidRegex;
class InvalidNsidError extends Error {
}
exports.InvalidNsidError = InvalidNsidError; //# sourceMappingURL=nsid.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/aturi_validation.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ensureValidAtUriRegex = exports.ensureValidAtUri = void 0;
const handle_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/handle.js [app-client] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/did.js [app-client] (ecmascript)");
const nsid_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/nsid.js [app-client] (ecmascript)");
// Human-readable constraints on ATURI:
//   - following regular URLs, a 8KByte hard total length limit
//   - follows ATURI docs on website
//      - all ASCII characters, no whitespace. non-ASCII could be URL-encoded
//      - starts "at://"
//      - "authority" is a valid DID or a valid handle
//      - optionally, follow "authority" with "/" and valid NSID as start of path
//      - optionally, if NSID given, follow that with "/" and rkey
//      - rkey path component can include URL-encoded ("percent encoded"), or:
//          ALPHA / DIGIT / "-" / "." / "_" / "~" / ":" / "@" / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//          [a-zA-Z0-9._~:@!$&'\(\)*+,;=-]
//      - rkey must have at least one char
//      - regardless of path component, a fragment can follow  as "#" and then a JSON pointer (RFC-6901)
const ensureValidAtUri = (uri)=>{
    // JSON pointer is pretty different from rest of URI, so split that out first
    const uriParts = uri.split('#');
    if (uriParts.length > 2) {
        throw new Error('ATURI can have at most one "#", separating fragment out');
    }
    const fragmentPart = uriParts[1] || null;
    uri = uriParts[0];
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {
        throw new Error('Disallowed characters in ATURI (ASCII)');
    }
    const parts = uri.split('/');
    if (parts.length >= 3 && (parts[0] !== 'at:' || parts[1].length !== 0)) {
        throw new Error('ATURI must start with "at://"');
    }
    if (parts.length < 3) {
        throw new Error('ATURI requires at least method and authority sections');
    }
    try {
        if (parts[2].startsWith('did:')) {
            (0, did_1.ensureValidDid)(parts[2]);
        } else {
            (0, handle_1.ensureValidHandle)(parts[2]);
        }
    } catch  {
        throw new Error('ATURI authority must be a valid handle or DID');
    }
    if (parts.length >= 4) {
        if (parts[3].length === 0) {
            throw new Error('ATURI can not have a slash after authority without a path segment');
        }
        try {
            (0, nsid_1.ensureValidNsid)(parts[3]);
        } catch  {
            throw new Error('ATURI requires first path segment (if supplied) to be valid NSID');
        }
    }
    if (parts.length >= 5) {
        if (parts[4].length === 0) {
            throw new Error('ATURI can not have a slash after collection, unless record key is provided');
        }
    // would validate rkey here, but there are basically no constraints!
    }
    if (parts.length >= 6) {
        throw new Error('ATURI path can have at most two parts, and no trailing slash');
    }
    if (uriParts.length >= 2 && fragmentPart == null) {
        throw new Error('ATURI fragment must be non-empty and start with slash');
    }
    if (fragmentPart != null) {
        if (fragmentPart.length === 0 || fragmentPart[0] !== '/') {
            throw new Error('ATURI fragment must be non-empty and start with slash');
        }
        // NOTE: enforcing *some* checks here for sanity. Eg, at least no whitespace
        if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
            throw new Error('Disallowed characters in ATURI fragment (ASCII)');
        }
    }
    if (uri.length > 8 * 1024) {
        throw new Error('ATURI is far too long');
    }
};
exports.ensureValidAtUri = ensureValidAtUri;
const ensureValidAtUriRegex = (uri)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints. whew!
    const aturiRegex = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/;
    const rm = uri.match(aturiRegex);
    if (!rm || !rm.groups) {
        throw new Error("ATURI didn't validate via regex");
    }
    const groups = rm.groups;
    try {
        (0, handle_1.ensureValidHandleRegex)(groups.authority);
    } catch  {
        try {
            (0, did_1.ensureValidDidRegex)(groups.authority);
        } catch  {
            throw new Error('ATURI authority must be a valid handle or DID');
        }
    }
    if (groups.collection) {
        try {
            (0, nsid_1.ensureValidNsidRegex)(groups.collection);
        } catch  {
            throw new Error('ATURI collection path segment must be a valid NSID');
        }
    }
    if (uri.length > 8 * 1024) {
        throw new Error('ATURI is far too long');
    }
};
exports.ensureValidAtUriRegex = ensureValidAtUriRegex; //# sourceMappingURL=aturi_validation.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/aturi.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtUri = exports.ATP_URI_REGEX = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/aturi_validation.js [app-client] (ecmascript)"), exports);
exports.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
/^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
//                       --path-----   --query--  --hash--
const RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
class AtUri {
    constructor(uri, base){
        Object.defineProperty(this, "hash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "host", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pathname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let parsed;
        if (base) {
            parsed = parse(base);
            if (!parsed) {
                throw new Error(`Invalid at uri: ${base}`);
            }
            const relativep = parseRelative(uri);
            if (!relativep) {
                throw new Error(`Invalid path: ${uri}`);
            }
            Object.assign(parsed, relativep);
        } else {
            parsed = parse(uri);
            if (!parsed) {
                throw new Error(`Invalid at uri: ${uri}`);
            }
        }
        this.hash = parsed.hash;
        this.host = parsed.host;
        this.pathname = parsed.pathname;
        this.searchParams = parsed.searchParams;
    }
    static make(handleOrDid, collection, rkey) {
        let str = handleOrDid;
        if (collection) str += '/' + collection;
        if (rkey) str += '/' + rkey;
        return new AtUri(str);
    }
    get protocol() {
        return 'at:';
    }
    get origin() {
        return `at://${this.host}`;
    }
    get hostname() {
        return this.host;
    }
    set hostname(v) {
        this.host = v;
    }
    get search() {
        return this.searchParams.toString();
    }
    set search(v) {
        this.searchParams = new URLSearchParams(v);
    }
    get collection() {
        return this.pathname.split('/').filter(Boolean)[0] || '';
    }
    set collection(v) {
        const parts = this.pathname.split('/').filter(Boolean);
        parts[0] = v;
        this.pathname = parts.join('/');
    }
    get rkey() {
        return this.pathname.split('/').filter(Boolean)[1] || '';
    }
    set rkey(v) {
        const parts = this.pathname.split('/').filter(Boolean);
        if (!parts[0]) parts[0] = 'undefined';
        parts[1] = v;
        this.pathname = parts.join('/');
    }
    get href() {
        return this.toString();
    }
    toString() {
        let path = this.pathname || '/';
        if (!path.startsWith('/')) {
            path = `/${path}`;
        }
        let qs = this.searchParams.toString();
        if (qs && !qs.startsWith('?')) {
            qs = `?${qs}`;
        }
        let hash = this.hash;
        if (hash && !hash.startsWith('#')) {
            hash = `#${hash}`;
        }
        return `at://${this.host}${path}${qs}${hash}`;
    }
}
exports.AtUri = AtUri;
function parse(str) {
    const match = exports.ATP_URI_REGEX.exec(str);
    if (match) {
        return {
            hash: match[5] || '',
            host: match[2] || '',
            pathname: match[3] || '',
            searchParams: new URLSearchParams(match[4] || '')
        };
    }
    return undefined;
}
function parseRelative(str) {
    const match = RELATIVE_REGEX.exec(str);
    if (match) {
        return {
            hash: match[3] || '',
            pathname: match[1] || '',
            searchParams: new URLSearchParams(match[2] || '')
        };
    }
    return undefined;
} //# sourceMappingURL=aturi.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/tid.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidTidError = exports.isValidTid = exports.ensureValidTid = void 0;
const ensureValidTid = (tid)=>{
    if (tid.length !== 13) {
        throw new InvalidTidError('TID must be 13 characters');
    }
    // simple regex to enforce most constraints via just regex and length.
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(tid)) {
        throw new InvalidTidError('TID syntax not valid (regex)');
    }
};
exports.ensureValidTid = ensureValidTid;
const isValidTid = (tid)=>{
    try {
        (0, exports.ensureValidTid)(tid);
    } catch (err) {
        if (err instanceof InvalidTidError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidTid = isValidTid;
class InvalidTidError extends Error {
}
exports.InvalidTidError = InvalidTidError; //# sourceMappingURL=tid.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/recordkey.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidRecordKeyError = exports.isValidRecordKey = exports.ensureValidRecordKey = void 0;
const ensureValidRecordKey = (rkey)=>{
    if (rkey.length > 512 || rkey.length < 1) {
        throw new InvalidRecordKeyError('record key must be 1 to 512 characters');
    }
    // simple regex to enforce most constraints via just regex and length.
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(rkey)) {
        throw new InvalidRecordKeyError('record key syntax not valid (regex)');
    }
    if (rkey === '.' || rkey === '..') throw new InvalidRecordKeyError('record key can not be "." or ".."');
};
exports.ensureValidRecordKey = ensureValidRecordKey;
const isValidRecordKey = (rkey)=>{
    try {
        (0, exports.ensureValidRecordKey)(rkey);
    } catch (err) {
        if (err instanceof InvalidRecordKeyError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidRecordKey = isValidRecordKey;
class InvalidRecordKeyError extends Error {
}
exports.InvalidRecordKeyError = InvalidRecordKeyError; //# sourceMappingURL=recordkey.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/datetime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDatetimeError = exports.normalizeDatetimeAlways = exports.normalizeDatetime = exports.isValidDatetime = exports.ensureValidDatetime = void 0;
/* Validates datetime string against atproto Lexicon 'datetime' format.
 * Syntax is described at: https://atproto.com/specs/lexicon#datetime
 */ const ensureValidDatetime = (dtStr)=>{
    const date = new Date(dtStr);
    // must parse as ISO 8601; this also verifies semantics like month is not 13 or 00
    if (isNaN(date.getTime())) {
        throw new InvalidDatetimeError('datetime did not parse as ISO 8601');
    }
    if (date.toISOString().startsWith('-')) {
        throw new InvalidDatetimeError('datetime normalized to a negative time');
    }
    // regex and other checks for RFC-3339
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(dtStr)) {
        throw new InvalidDatetimeError("datetime didn't validate via regex");
    }
    if (dtStr.length > 64) {
        throw new InvalidDatetimeError('datetime is too long (64 chars max)');
    }
    if (dtStr.endsWith('-00:00')) {
        throw new InvalidDatetimeError('datetime can not use "-00:00" for UTC timezone');
    }
    if (dtStr.startsWith('000')) {
        throw new InvalidDatetimeError('datetime so close to year zero not allowed');
    }
};
exports.ensureValidDatetime = ensureValidDatetime;
/* Same logic as ensureValidDatetime(), but returns a boolean instead of throwing an exception.
 */ const isValidDatetime = (dtStr)=>{
    try {
        (0, exports.ensureValidDatetime)(dtStr);
    } catch (err) {
        if (err instanceof InvalidDatetimeError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidDatetime = isValidDatetime;
/* Takes a flexible datetime string and normalizes representation.
 *
 * This function will work with any valid atproto datetime (eg, anything which isValidDatetime() is true for). It *additionally* is more flexible about accepting datetimes that don't comply to RFC 3339, or are missing timezone information, and normalizing them to a valid datetime.
 *
 * One use-case is a consistent, sortable string. Another is to work with older invalid createdAt datetimes.
 *
 * Successful output will be a valid atproto datetime with millisecond precision (3 sub-second digits) and UTC timezone with trailing 'Z' syntax. Throws `InvalidDatetimeError` if the input string could not be parsed as a datetime, even with permissive parsing.
 *
 * Expected output format: YYYY-MM-DDTHH:mm:ss.sssZ
 */ const normalizeDatetime = (dtStr)=>{
    if ((0, exports.isValidDatetime)(dtStr)) {
        const outStr = new Date(dtStr).toISOString();
        if ((0, exports.isValidDatetime)(outStr)) {
            return outStr;
        }
    }
    // check if this permissive datetime is missing a timezone
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(dtStr)) {
        const date = new Date(dtStr + 'Z');
        if (!isNaN(date.getTime())) {
            const tzStr = date.toISOString();
            if ((0, exports.isValidDatetime)(tzStr)) {
                return tzStr;
            }
        }
    }
    // finally try parsing as simple datetime
    const date = new Date(dtStr);
    if (isNaN(date.getTime())) {
        throw new InvalidDatetimeError('datetime did not parse as any timestamp format');
    }
    const isoStr = date.toISOString();
    if ((0, exports.isValidDatetime)(isoStr)) {
        return isoStr;
    } else {
        throw new InvalidDatetimeError('datetime normalized to invalid timestamp string');
    }
};
exports.normalizeDatetime = normalizeDatetime;
/* Variant of normalizeDatetime() which always returns a valid datetime strings.
 *
 * If a InvalidDatetimeError is encountered, returns the UNIX epoch time as a UTC datetime (1970-01-01T00:00:00.000Z).
 */ const normalizeDatetimeAlways = (dtStr)=>{
    try {
        return (0, exports.normalizeDatetime)(dtStr);
    } catch (err) {
        if (err instanceof InvalidDatetimeError) {
            return new Date(0).toISOString();
        }
        throw err;
    }
};
exports.normalizeDatetimeAlways = normalizeDatetimeAlways;
/* Indicates a datetime string did not pass full atproto Lexicon datetime string format checks.
 */ class InvalidDatetimeError extends Error {
}
exports.InvalidDatetimeError = InvalidDatetimeError; //# sourceMappingURL=datetime.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/handle.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/did.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/nsid.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/aturi.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/tid.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/recordkey.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/datetime.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toLexUri = toLexUri;
exports.toConcreteTypes = toConcreteTypes;
exports.requiredPropertiesRefinement = requiredPropertiesRefinement;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-client] (ecmascript)");
function toLexUri(str, baseUri) {
    if (str.split('#').length > 2) {
        throw new Error('Uri can only have one hash segment');
    }
    if (str.startsWith('lex:')) {
        return str;
    }
    if (str.startsWith('#')) {
        if (!baseUri) {
            throw new Error(`Unable to resolve uri without anchor: ${str}`);
        }
        return `${baseUri}${str}`;
    }
    return `lex:${str}`;
}
function toConcreteTypes(lexicons, def) {
    if (def.type === 'ref') {
        return [
            lexicons.getDefOrThrow(def.ref)
        ];
    } else if (def.type === 'union') {
        return def.refs.map((ref)=>lexicons.getDefOrThrow(ref)).flat();
    } else {
        return [
            def
        ];
    }
}
function requiredPropertiesRefinement(object, ctx) {
    // Required fields check
    if (object.required === undefined) {
        return;
    }
    if (!Array.isArray(object.required)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.invalid_type,
            received: typeof object.required,
            expected: 'array'
        });
        return;
    }
    if (object.properties === undefined) {
        if (object.required.length > 0) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: `Required fields defined but no properties defined`
            });
        }
        return;
    }
    for (const field of object.required){
        if (object.properties[field] === undefined) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: `Required field "${field}" not defined`
            });
        }
    }
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LexiconDefNotFoundError = exports.InvalidLexiconError = exports.ValidationError = exports.discriminatedObject = exports.lexiconDoc = exports.lexUserType = exports.lexRecord = exports.lexXrpcSubscription = exports.lexXrpcProcedure = exports.lexXrpcQuery = exports.lexXrpcError = exports.lexXrpcSubscriptionMessage = exports.lexXrpcBody = exports.lexXrpcParameters = exports.lexObject = exports.lexToken = exports.lexPrimitiveArray = exports.lexArray = exports.lexBlob = exports.lexRefVariant = exports.lexRefUnion = exports.lexRef = exports.lexIpldType = exports.lexCidLink = exports.lexBytes = exports.lexPrimitive = exports.lexUnknown = exports.lexString = exports.lexStringFormat = exports.lexInteger = exports.lexBoolean = void 0;
exports.isValidLexiconDoc = isValidLexiconDoc;
exports.isObj = isObj;
exports.hasProp = hasProp;
exports.isDiscriminatedObject = isDiscriminatedObject;
exports.parseLexiconDoc = parseLexiconDoc;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-client] (ecmascript)");
const syntax_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/index.js [app-client] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/util.js [app-client] (ecmascript)");
// primitives
// =
exports.lexBoolean = zod_1.z.object({
    type: zod_1.z.literal('boolean'),
    description: zod_1.z.string().optional(),
    default: zod_1.z.boolean().optional(),
    const: zod_1.z.boolean().optional()
}).strict();
exports.lexInteger = zod_1.z.object({
    type: zod_1.z.literal('integer'),
    description: zod_1.z.string().optional(),
    default: zod_1.z.number().int().optional(),
    minimum: zod_1.z.number().int().optional(),
    maximum: zod_1.z.number().int().optional(),
    enum: zod_1.z.number().int().array().optional(),
    const: zod_1.z.number().int().optional()
}).strict();
exports.lexStringFormat = zod_1.z.enum([
    'datetime',
    'uri',
    'at-uri',
    'did',
    'handle',
    'at-identifier',
    'nsid',
    'cid',
    'language',
    'tid',
    'record-key'
]);
exports.lexString = zod_1.z.object({
    type: zod_1.z.literal('string'),
    format: exports.lexStringFormat.optional(),
    description: zod_1.z.string().optional(),
    default: zod_1.z.string().optional(),
    minLength: zod_1.z.number().int().optional(),
    maxLength: zod_1.z.number().int().optional(),
    minGraphemes: zod_1.z.number().int().optional(),
    maxGraphemes: zod_1.z.number().int().optional(),
    enum: zod_1.z.string().array().optional(),
    const: zod_1.z.string().optional(),
    knownValues: zod_1.z.string().array().optional()
}).strict();
exports.lexUnknown = zod_1.z.object({
    type: zod_1.z.literal('unknown'),
    description: zod_1.z.string().optional()
}).strict();
exports.lexPrimitive = zod_1.z.discriminatedUnion('type', [
    exports.lexBoolean,
    exports.lexInteger,
    exports.lexString,
    exports.lexUnknown
]);
// ipld types
// =
exports.lexBytes = zod_1.z.object({
    type: zod_1.z.literal('bytes'),
    description: zod_1.z.string().optional(),
    maxLength: zod_1.z.number().optional(),
    minLength: zod_1.z.number().optional()
}).strict();
exports.lexCidLink = zod_1.z.object({
    type: zod_1.z.literal('cid-link'),
    description: zod_1.z.string().optional()
}).strict();
exports.lexIpldType = zod_1.z.discriminatedUnion('type', [
    exports.lexBytes,
    exports.lexCidLink
]);
// references
// =
exports.lexRef = zod_1.z.object({
    type: zod_1.z.literal('ref'),
    description: zod_1.z.string().optional(),
    ref: zod_1.z.string()
}).strict();
exports.lexRefUnion = zod_1.z.object({
    type: zod_1.z.literal('union'),
    description: zod_1.z.string().optional(),
    refs: zod_1.z.string().array(),
    closed: zod_1.z.boolean().optional()
}).strict();
exports.lexRefVariant = zod_1.z.discriminatedUnion('type', [
    exports.lexRef,
    exports.lexRefUnion
]);
// blobs
// =
exports.lexBlob = zod_1.z.object({
    type: zod_1.z.literal('blob'),
    description: zod_1.z.string().optional(),
    accept: zod_1.z.string().array().optional(),
    maxSize: zod_1.z.number().optional()
}).strict();
// complex types
// =
exports.lexArray = zod_1.z.object({
    type: zod_1.z.literal('array'),
    description: zod_1.z.string().optional(),
    items: zod_1.z.discriminatedUnion('type', [
        // lexPrimitive
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown,
        // lexIpldType
        exports.lexBytes,
        exports.lexCidLink,
        // lexRefVariant
        exports.lexRef,
        exports.lexRefUnion,
        // other
        exports.lexBlob
    ]),
    minLength: zod_1.z.number().int().optional(),
    maxLength: zod_1.z.number().int().optional()
}).strict();
exports.lexPrimitiveArray = exports.lexArray.merge(zod_1.z.object({
    items: exports.lexPrimitive
}).strict());
exports.lexToken = zod_1.z.object({
    type: zod_1.z.literal('token'),
    description: zod_1.z.string().optional()
}).strict();
exports.lexObject = zod_1.z.object({
    type: zod_1.z.literal('object'),
    description: zod_1.z.string().optional(),
    required: zod_1.z.string().array().optional(),
    nullable: zod_1.z.string().array().optional(),
    properties: zod_1.z.record(zod_1.z.discriminatedUnion('type', [
        exports.lexArray,
        // lexPrimitive
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown,
        // lexIpldType
        exports.lexBytes,
        exports.lexCidLink,
        // lexRefVariant
        exports.lexRef,
        exports.lexRefUnion,
        // other
        exports.lexBlob
    ]))
}).strict().superRefine(util_1.requiredPropertiesRefinement);
// xrpc
// =
exports.lexXrpcParameters = zod_1.z.object({
    type: zod_1.z.literal('params'),
    description: zod_1.z.string().optional(),
    required: zod_1.z.string().array().optional(),
    properties: zod_1.z.record(zod_1.z.discriminatedUnion('type', [
        exports.lexPrimitiveArray,
        // lexPrimitive
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown
    ]))
}).strict().superRefine(util_1.requiredPropertiesRefinement);
exports.lexXrpcBody = zod_1.z.object({
    description: zod_1.z.string().optional(),
    encoding: zod_1.z.string(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: zod_1.z.union([
        exports.lexRefVariant,
        exports.lexObject
    ]).optional()
}).strict();
exports.lexXrpcSubscriptionMessage = zod_1.z.object({
    description: zod_1.z.string().optional(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: zod_1.z.union([
        exports.lexRefVariant,
        exports.lexObject
    ]).optional()
}).strict();
exports.lexXrpcError = zod_1.z.object({
    name: zod_1.z.string(),
    description: zod_1.z.string().optional()
}).strict();
exports.lexXrpcQuery = zod_1.z.object({
    type: zod_1.z.literal('query'),
    description: zod_1.z.string().optional(),
    parameters: exports.lexXrpcParameters.optional(),
    output: exports.lexXrpcBody.optional(),
    errors: exports.lexXrpcError.array().optional()
}).strict();
exports.lexXrpcProcedure = zod_1.z.object({
    type: zod_1.z.literal('procedure'),
    description: zod_1.z.string().optional(),
    parameters: exports.lexXrpcParameters.optional(),
    input: exports.lexXrpcBody.optional(),
    output: exports.lexXrpcBody.optional(),
    errors: exports.lexXrpcError.array().optional()
}).strict();
exports.lexXrpcSubscription = zod_1.z.object({
    type: zod_1.z.literal('subscription'),
    description: zod_1.z.string().optional(),
    parameters: exports.lexXrpcParameters.optional(),
    message: exports.lexXrpcSubscriptionMessage.optional(),
    errors: exports.lexXrpcError.array().optional()
}).strict();
// database
// =
exports.lexRecord = zod_1.z.object({
    type: zod_1.z.literal('record'),
    description: zod_1.z.string().optional(),
    key: zod_1.z.string().optional(),
    record: exports.lexObject
}).strict();
// core
// =
// We need to use `z.custom` here because
// lexXrpcProperty and lexObject are refined
// `z.union` would work, but it's too slow
// see #915 for details
exports.lexUserType = zod_1.z.custom((val)=>{
    if (!val || typeof val !== 'object') {
        return;
    }
    if (val['type'] === undefined) {
        return;
    }
    switch(val['type']){
        case 'record':
            return exports.lexRecord.parse(val);
        case 'query':
            return exports.lexXrpcQuery.parse(val);
        case 'procedure':
            return exports.lexXrpcProcedure.parse(val);
        case 'subscription':
            return exports.lexXrpcSubscription.parse(val);
        case 'blob':
            return exports.lexBlob.parse(val);
        case 'array':
            return exports.lexArray.parse(val);
        case 'token':
            return exports.lexToken.parse(val);
        case 'object':
            return exports.lexObject.parse(val);
        case 'boolean':
            return exports.lexBoolean.parse(val);
        case 'integer':
            return exports.lexInteger.parse(val);
        case 'string':
            return exports.lexString.parse(val);
        case 'bytes':
            return exports.lexBytes.parse(val);
        case 'cid-link':
            return exports.lexCidLink.parse(val);
        case 'unknown':
            return exports.lexUnknown.parse(val);
    }
}, (val)=>{
    if (!val || typeof val !== 'object') {
        return {
            message: 'Must be an object',
            fatal: true
        };
    }
    if (val['type'] === undefined) {
        return {
            message: 'Must have a type',
            fatal: true
        };
    }
    if (typeof val['type'] !== 'string') {
        return {
            message: 'Type property must be a string',
            fatal: true
        };
    }
    return {
        message: `Invalid type: ${val['type']} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
        fatal: true
    };
});
exports.lexiconDoc = zod_1.z.object({
    lexicon: zod_1.z.literal(1),
    id: zod_1.z.string().refine((v)=>syntax_1.NSID.isValid(v), {
        message: 'Must be a valid NSID'
    }),
    revision: zod_1.z.number().optional(),
    description: zod_1.z.string().optional(),
    defs: zod_1.z.record(exports.lexUserType)
}).strict().superRefine((doc, ctx)=>{
    for(const defId in doc.defs){
        const def = doc.defs[defId];
        if (defId !== 'main' && (def.type === 'record' || def.type === 'procedure' || def.type === 'query' || def.type === 'subscription')) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
        }
    }
});
// helpers
// =
function isValidLexiconDoc(v) {
    return exports.lexiconDoc.safeParse(v).success;
}
function isObj(obj) {
    return obj !== null && typeof obj === 'object';
}
function hasProp(data, prop) {
    return prop in data;
}
exports.discriminatedObject = zod_1.z.object({
    $type: zod_1.z.string()
});
function isDiscriminatedObject(value) {
    return exports.discriminatedObject.safeParse(value).success;
}
function parseLexiconDoc(v) {
    exports.lexiconDoc.parse(v);
    return v;
}
class ValidationError extends Error {
}
exports.ValidationError = ValidationError;
class InvalidLexiconError extends Error {
}
exports.InvalidLexiconError = InvalidLexiconError;
class LexiconDefNotFoundError extends Error {
}
exports.LexiconDefNotFoundError = LexiconDefNotFoundError; //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlobRef = exports.jsonBlobRef = exports.untypedJsonBlobRef = exports.typedJsonBlobRef = void 0;
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-client] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-client] (ecmascript)");
exports.typedJsonBlobRef = zod_1.z.object({
    $type: zod_1.z.literal('blob'),
    ref: common_web_1.schema.cid,
    mimeType: zod_1.z.string(),
    size: zod_1.z.number()
}).strict();
exports.untypedJsonBlobRef = zod_1.z.object({
    cid: zod_1.z.string(),
    mimeType: zod_1.z.string()
}).strict();
exports.jsonBlobRef = zod_1.z.union([
    exports.typedJsonBlobRef,
    exports.untypedJsonBlobRef
]);
class BlobRef {
    constructor(ref, mimeType, size, original){
        Object.defineProperty(this, "ref", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ref
        });
        Object.defineProperty(this, "mimeType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mimeType
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: size
        });
        Object.defineProperty(this, "original", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.original = original ?? {
            $type: 'blob',
            ref,
            mimeType,
            size
        };
    }
    static asBlobRef(obj) {
        if (common_web_1.check.is(obj, exports.jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
        }
        return null;
    }
    static fromJsonRef(json) {
        if (common_web_1.check.is(json, exports.typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
        } else {
            return new BlobRef(cid_1.CID.parse(json.cid), json.mimeType, -1, json);
        }
    }
    ipld() {
        return {
            $type: 'blob',
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
        };
    }
    toJSON() {
        return (0, common_web_1.ipldToJson)(this.ipld());
    }
}
exports.BlobRef = BlobRef; //# sourceMappingURL=blob-refs.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/blob.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blob = blob;
const blob_refs_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-client] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)");
function blob(lexicons, path, def, value) {
    // check
    if (!value || !(value instanceof blob_refs_1.BlobRef)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} should be a blob ref`)
        };
    }
    return {
        success: true,
        value
    };
} //# sourceMappingURL=blob.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/formats.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.datetime = datetime;
exports.uri = uri;
exports.atUri = atUri;
exports.did = did;
exports.handle = handle;
exports.atIdentifier = atIdentifier;
exports.nsid = nsid;
exports.cid = cid;
exports.language = language;
exports.tid = tid;
exports.recordKey = recordKey;
const iso_datestring_validator_1 = __turbopack_require__("[project]/node_modules/iso-datestring-validator/dist/index.js [app-client] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)");
const syntax_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/index.js [app-client] (ecmascript)");
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-client] (ecmascript)");
function datetime(path, value) {
    try {
        if (!(0, iso_datestring_validator_1.isValidISODateString)(value)) {
            throw new Error();
        }
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
        };
    }
    return {
        success: true,
        value
    };
}
function uri(path, value) {
    const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
    if (!isUri) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a uri`)
        };
    }
    return {
        success: true,
        value
    };
}
function atUri(path, value) {
    try {
        (0, syntax_1.ensureValidAtUri)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid at-uri`)
        };
    }
    return {
        success: true,
        value
    };
}
function did(path, value) {
    try {
        (0, syntax_1.ensureValidDid)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid did`)
        };
    }
    return {
        success: true,
        value
    };
}
function handle(path, value) {
    try {
        (0, syntax_1.ensureValidHandle)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid handle`)
        };
    }
    return {
        success: true,
        value
    };
}
function atIdentifier(path, value) {
    // We can discriminate based on the "did:" prefix
    if (value.startsWith('did:')) {
        const didResult = did(path, value);
        if (didResult.success) return didResult;
    } else {
        const handleResult = handle(path, value);
        if (handleResult.success) return handleResult;
    }
    return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a valid did or a handle`)
    };
}
function nsid(path, value) {
    try {
        (0, syntax_1.ensureValidNsid)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid nsid`)
        };
    }
    return {
        success: true,
        value
    };
}
function cid(path, value) {
    try {
        cid_1.CID.parse(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a cid string`)
        };
    }
    return {
        success: true,
        value
    };
}
// The language format validates well-formed BCP 47 language tags: https://www.rfc-editor.org/info/bcp47
function language(path, value) {
    if ((0, common_web_1.validateLanguage)(value)) {
        return {
            success: true,
            value
        };
    }
    return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a well-formed BCP 47 language tag`)
    };
}
function tid(path, value) {
    try {
        (0, syntax_1.ensureValidTid)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid TID (timestamp identifier)`)
        };
    }
    return {
        success: true,
        value
    };
}
function recordKey(path, value) {
    try {
        (0, syntax_1.ensureValidRecordKey)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid Record Key`)
        };
    }
    return {
        success: true,
        value
    };
} //# sourceMappingURL=formats.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/primitives.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = validate;
exports.boolean = boolean;
exports.integer = integer;
exports.string = string;
exports.bytes = bytes;
exports.cidLink = cidLink;
exports.unknown = unknown;
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-client] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
const formats = __importStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/formats.js [app-client] (ecmascript)"));
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)");
function validate(lexicons, path, def, value) {
    switch(def.type){
        case 'boolean':
            return boolean(lexicons, path, def, value);
        case 'integer':
            return integer(lexicons, path, def, value);
        case 'string':
            return string(lexicons, path, def, value);
        case 'bytes':
            return bytes(lexicons, path, def, value);
        case 'cid-link':
            return cidLink(lexicons, path, def, value);
        case 'unknown':
            return unknown(lexicons, path, def, value);
        default:
            return {
                success: false,
                error: new types_1.ValidationError(`Unexpected lexicon type: ${def.type}`)
            };
    }
}
function boolean(lexicons, path, def, value) {
    def = def;
    // type
    const type = typeof value;
    if (type === 'undefined') {
        if (typeof def.default === 'boolean') {
            return {
                success: true,
                value: def.default
            };
        }
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a boolean`)
        };
    } else if (type !== 'boolean') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a boolean`)
        };
    }
    // const
    if (typeof def.const === 'boolean') {
        if (value !== def.const) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be ${def.const}`)
            };
        }
    }
    return {
        success: true,
        value
    };
}
function integer(lexicons, path, def, value) {
    def = def;
    // type
    const type = typeof value;
    if (type === 'undefined') {
        if (typeof def.default === 'number') {
            return {
                success: true,
                value: def.default
            };
        }
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an integer`)
        };
    } else if (!Number.isInteger(value)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an integer`)
        };
    }
    // const
    if (typeof def.const === 'number') {
        if (value !== def.const) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be ${def.const}`)
            };
        }
    }
    // enum
    if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be one of (${def.enum.join('|')})`)
            };
        }
    }
    // maximum
    if (typeof def.maximum === 'number') {
        if (value > def.maximum) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} can not be greater than ${def.maximum}`)
            };
        }
    }
    // minimum
    if (typeof def.minimum === 'number') {
        if (value < def.minimum) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} can not be less than ${def.minimum}`)
            };
        }
    }
    return {
        success: true,
        value
    };
}
function string(lexicons, path, def, value) {
    def = def;
    // type
    if (typeof value === 'undefined') {
        if (typeof def.default === 'string') {
            return {
                success: true,
                value: def.default
            };
        }
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a string`)
        };
    } else if (typeof value !== 'string') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a string`)
        };
    }
    // const
    if (typeof def.const === 'string') {
        if (value !== def.const) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be ${def.const}`)
            };
        }
    }
    // enum
    if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be one of (${def.enum.join('|')})`)
            };
        }
    }
    // maxLength and minLength
    if (typeof def.minLength === 'number' || typeof def.maxLength === 'number') {
        // If the JavaScript string length * 3 is below the maximum limit,
        // its UTF8 length (which <= .length * 3) will also be below.
        if (typeof def.minLength === 'number' && value.length * 3 < def.minLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
            };
        }
        // If the JavaScript string length * 3 is within the maximum limit,
        // its UTF8 length (which <= .length * 3) will also be within.
        // When there's no minimal length, this lets us skip the UTF8 length check.
        let canSkipUtf8LenChecks = false;
        if (typeof def.minLength === 'undefined' && typeof def.maxLength === 'number' && value.length * 3 <= def.maxLength) {
            canSkipUtf8LenChecks = true;
        }
        if (!canSkipUtf8LenChecks) {
            const len = (0, common_web_1.utf8Len)(value);
            if (typeof def.maxLength === 'number') {
                if (len > def.maxLength) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be longer than ${def.maxLength} characters`)
                    };
                }
            }
            if (typeof def.minLength === 'number') {
                if (len < def.minLength) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
                    };
                }
            }
        }
    }
    // maxGraphemes and minGraphemes
    if (typeof def.maxGraphemes === 'number' || typeof def.minGraphemes === 'number') {
        let needsMaxGraphemesCheck = false;
        let needsMinGraphemesCheck = false;
        if (typeof def.maxGraphemes === 'number') {
            if (value.length <= def.maxGraphemes) {
                // If the JavaScript string length (UTF-16) is within the maximum limit,
                // its grapheme length (which <= .length) will also be within.
                needsMaxGraphemesCheck = false;
            } else {
                needsMaxGraphemesCheck = true;
            }
        }
        if (typeof def.minGraphemes === 'number') {
            if (value.length < def.minGraphemes) {
                // If the JavaScript string length (UTF-16) is below the minimal limit,
                // its grapheme length (which <= .length) will also be below.
                // Fail early.
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
                };
            } else {
                needsMinGraphemesCheck = true;
            }
        }
        if (needsMaxGraphemesCheck || needsMinGraphemesCheck) {
            const len = (0, common_web_1.graphemeLen)(value);
            if (typeof def.maxGraphemes === 'number') {
                if (len > def.maxGraphemes) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be longer than ${def.maxGraphemes} graphemes`)
                    };
                }
            }
            if (typeof def.minGraphemes === 'number') {
                if (len < def.minGraphemes) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
                    };
                }
            }
        }
    }
    if (typeof def.format === 'string') {
        switch(def.format){
            case 'datetime':
                return formats.datetime(path, value);
            case 'uri':
                return formats.uri(path, value);
            case 'at-uri':
                return formats.atUri(path, value);
            case 'did':
                return formats.did(path, value);
            case 'handle':
                return formats.handle(path, value);
            case 'at-identifier':
                return formats.atIdentifier(path, value);
            case 'nsid':
                return formats.nsid(path, value);
            case 'cid':
                return formats.cid(path, value);
            case 'language':
                return formats.language(path, value);
            case 'tid':
                return formats.tid(path, value);
            case 'record-key':
                return formats.recordKey(path, value);
        }
    }
    return {
        success: true,
        value
    };
}
function bytes(lexicons, path, def, value) {
    def = def;
    if (!value || !(value instanceof Uint8Array)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a byte array`)
        };
    }
    // maxLength
    if (typeof def.maxLength === 'number') {
        if (value.byteLength > def.maxLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be larger than ${def.maxLength} bytes`)
            };
        }
    }
    // minLength
    if (typeof def.minLength === 'number') {
        if (value.byteLength < def.minLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be smaller than ${def.minLength} bytes`)
            };
        }
    }
    return {
        success: true,
        value
    };
}
function cidLink(lexicons, path, def, value) {
    if (cid_1.CID.asCID(value) === null) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a CID`)
        };
    }
    return {
        success: true,
        value
    };
}
function unknown(lexicons, path, def, value) {
    // type
    if (!value || typeof value !== 'object') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an object`)
        };
    }
    return {
        success: true,
        value
    };
} //# sourceMappingURL=primitives.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = validate;
exports.array = array;
exports.object = object;
exports.validateOneOf = validateOneOf;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/util.js [app-client] (ecmascript)");
const blob_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/blob.js [app-client] (ecmascript)");
const primitives_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/primitives.js [app-client] (ecmascript)");
function validate(lexicons, path, def, value) {
    switch(def.type){
        case 'boolean':
            return (0, primitives_1.boolean)(lexicons, path, def, value);
        case 'integer':
            return (0, primitives_1.integer)(lexicons, path, def, value);
        case 'string':
            return (0, primitives_1.string)(lexicons, path, def, value);
        case 'bytes':
            return (0, primitives_1.bytes)(lexicons, path, def, value);
        case 'cid-link':
            return (0, primitives_1.cidLink)(lexicons, path, def, value);
        case 'unknown':
            return (0, primitives_1.unknown)(lexicons, path, def, value);
        case 'object':
            return object(lexicons, path, def, value);
        case 'array':
            return array(lexicons, path, def, value);
        case 'blob':
            return (0, blob_1.blob)(lexicons, path, def, value);
        default:
            return {
                success: false,
                error: new types_1.ValidationError(`Unexpected lexicon type: ${def.type}`)
            };
    }
}
function array(lexicons, path, def, value) {
    // type
    if (!Array.isArray(value)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an array`)
        };
    }
    // maxLength
    if (typeof def.maxLength === 'number') {
        if (value.length > def.maxLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not have more than ${def.maxLength} elements`)
            };
        }
    }
    // minLength
    if (typeof def.minLength === 'number') {
        if (value.length < def.minLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not have fewer than ${def.minLength} elements`)
            };
        }
    }
    // items
    const itemsDef = def.items;
    for(let i = 0; i < value.length; i++){
        const itemValue = value[i];
        const itemPath = `${path}/${i}`;
        const res = validateOneOf(lexicons, itemPath, itemsDef, itemValue);
        if (!res.success) {
            return res;
        }
    }
    return {
        success: true,
        value
    };
}
function object(lexicons, path, def, value) {
    def = def;
    // type
    if (!value || typeof value !== 'object') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an object`)
        };
    }
    const requiredProps = new Set(def.required);
    const nullableProps = new Set(def.nullable);
    // properties
    let resultValue = value;
    if (typeof def.properties === 'object') {
        for(const key in def.properties){
            if (value[key] === null && nullableProps.has(key)) {
                continue;
            }
            const propDef = def.properties[key];
            if (typeof value[key] === 'undefined' && !requiredProps.has(key)) {
                // Fast path for non-required undefined props.
                if (propDef.type === 'integer' || propDef.type === 'boolean' || propDef.type === 'string') {
                    if (typeof propDef.default === 'undefined') {
                        continue;
                    }
                } else {
                    continue;
                }
            }
            const propPath = `${path}/${key}`;
            const validated = validateOneOf(lexicons, propPath, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === 'undefined';
            // Return error for bad validation, giving required rule precedence
            if (propIsUndefined && requiredProps.has(key)) {
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} must have the property "${key}"`)
                };
            } else if (!propIsUndefined && !validated.success) {
                return validated;
            }
            // Adjust value based on e.g. applied defaults, cloning shallowly if there was a changed value
            if (propValue !== value[key]) {
                if (resultValue === value) {
                    // Lazy shallow clone
                    resultValue = {
                        ...value
                    };
                }
                resultValue[key] = propValue;
            }
        }
    }
    return {
        success: true,
        value: resultValue
    };
}
function validateOneOf(lexicons, path, def, value, mustBeObj = false) {
    let error;
    let concreteDefs;
    if (def.type === 'union') {
        if (!(0, types_1.isDiscriminatedObject)(value)) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be an object which includes the "$type" property`)
            };
        }
        if (!refsContainType(def.refs, value.$type)) {
            if (def.closed) {
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} $type must be one of ${def.refs.join(', ')}`)
                };
            }
            return {
                success: true,
                value
            };
        } else {
            concreteDefs = (0, util_1.toConcreteTypes)(lexicons, {
                type: 'ref',
                ref: value.$type
            });
        }
    } else {
        concreteDefs = (0, util_1.toConcreteTypes)(lexicons, def);
    }
    for (const concreteDef of concreteDefs){
        const result = mustBeObj ? object(lexicons, path, concreteDef, value) : validate(lexicons, path, concreteDef, value);
        if (result.success) {
            return result;
        }
        error ?? (error = result.error);
    }
    if (concreteDefs.length > 1) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} did not match any of the expected definitions`)
        };
    }
    return {
        success: false,
        error
    };
}
// to avoid bugs like #0189 this needs to handle both
// explicit and implicit #main
const refsContainType = (refs, type)=>{
    const lexUri = (0, util_1.toLexUri)(type);
    if (refs.includes(lexUri)) {
        return true;
    }
    if (lexUri.endsWith('#main')) {
        return refs.includes(lexUri.replace('#main', ''));
    } else {
        return refs.includes(lexUri + '#main');
    }
}; //# sourceMappingURL=complex.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/xrpc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.params = params;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)");
const PrimitiveValidators = __importStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/primitives.js [app-client] (ecmascript)"));
const complex_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-client] (ecmascript)");
function params(lexicons, path, def, val) {
    // type
    const value = val && typeof val === 'object' ? val : {};
    const requiredProps = new Set(def.required ?? []);
    // properties
    let resultValue = value;
    if (typeof def.properties === 'object') {
        for(const key in def.properties){
            const propDef = def.properties[key];
            const validated = propDef.type === 'array' ? (0, complex_1.array)(lexicons, key, propDef, value[key]) : PrimitiveValidators.validate(lexicons, key, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === 'undefined';
            // Return error for bad validation, giving required rule precedence
            if (propIsUndefined && requiredProps.has(key)) {
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} must have the property "${key}"`)
                };
            } else if (!propIsUndefined && !validated.success) {
                return validated;
            }
            // Adjust value based on e.g. applied defaults, cloning shallowly if there was a changed value
            if (propValue !== value[key]) {
                if (resultValue === value) {
                    // Lazy shallow clone
                    resultValue = {
                        ...value
                    };
                }
                resultValue[key] = propValue;
            }
        }
    }
    return {
        success: true,
        value: resultValue
    };
} //# sourceMappingURL=xrpc.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validation.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertValidRecord = assertValidRecord;
exports.assertValidXrpcParams = assertValidXrpcParams;
exports.assertValidXrpcInput = assertValidXrpcInput;
exports.assertValidXrpcOutput = assertValidXrpcOutput;
exports.assertValidXrpcMessage = assertValidXrpcMessage;
const complex_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-client] (ecmascript)");
const xrpc_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/xrpc.js [app-client] (ecmascript)");
function assertValidRecord(lexicons, def, value) {
    const res = (0, complex_1.object)(lexicons, 'Record', def.record, value);
    if (!res.success) throw res.error;
    return res.value;
}
function assertValidXrpcParams(lexicons, def, value) {
    if (def.parameters) {
        const res = (0, xrpc_1.params)(lexicons, 'Params', def.parameters, value);
        if (!res.success) throw res.error;
        return res.value;
    }
}
function assertValidXrpcInput(lexicons, def, value) {
    if (def.input?.schema) {
        // loop: all input schema definitions
        return assertValidOneOf(lexicons, 'Input', def.input.schema, value, true);
    }
}
function assertValidXrpcOutput(lexicons, def, value) {
    if (def.output?.schema) {
        // loop: all output schema definitions
        return assertValidOneOf(lexicons, 'Output', def.output.schema, value, true);
    }
}
function assertValidXrpcMessage(lexicons, def, value) {
    if (def.message?.schema) {
        // loop: all output schema definitions
        return assertValidOneOf(lexicons, 'Message', def.message.schema, value, true);
    }
}
function assertValidOneOf(lexicons, path, def, value, mustBeObj = false) {
    const res = (0, complex_1.validateOneOf)(lexicons, path, def, value, mustBeObj);
    if (!res.success) throw res.error;
    return res.value;
} //# sourceMappingURL=validation.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/lexicons.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Lexicons = void 0;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)");
const validation_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validation.js [app-client] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/util.js [app-client] (ecmascript)");
const ComplexValidators = __importStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-client] (ecmascript)"));
/**
 * A collection of compiled lexicons.
 */ class Lexicons {
    constructor(docs){
        Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "defs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        if (docs) {
            for (const doc of docs){
                this.add(doc);
            }
        }
    }
    /**
     * @example clone a lexicon:
     * ```ts
     * const clone = new Lexicons(originalLexicon)
     * ```
     *
     * @example get docs array:
     * ```ts
     * const docs = Array.from(lexicons)
     * ```
     */ [Symbol.iterator]() {
        return this.docs.values();
    }
    /**
     * Add a lexicon doc.
     */ add(doc) {
        const uri = (0, util_1.toLexUri)(doc.id);
        if (this.docs.has(uri)) {
            throw new Error(`${uri} has already been registered`);
        }
        // WARNING
        // mutates the object
        // -prf
        resolveRefUris(doc, uri);
        this.docs.set(uri, doc);
        for (const [defUri, def] of iterDefs(doc)){
            this.defs.set(defUri, def);
        }
    }
    /**
     * Remove a lexicon doc.
     */ remove(uri) {
        uri = (0, util_1.toLexUri)(uri);
        const doc = this.docs.get(uri);
        if (!doc) {
            throw new Error(`Unable to remove "${uri}": does not exist`);
        }
        for (const [defUri, _def] of iterDefs(doc)){
            this.defs.delete(defUri);
        }
        this.docs.delete(uri);
    }
    /**
     * Get a lexicon doc.
     */ get(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.docs.get(uri);
    }
    /**
     * Get a definition.
     */ getDef(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.defs.get(uri);
    }
    getDefOrThrow(uri, types) {
        const def = this.getDef(uri);
        if (!def) {
            throw new types_1.LexiconDefNotFoundError(`Lexicon not found: ${uri}`);
        }
        if (types && !types.includes(def.type)) {
            throw new types_1.InvalidLexiconError(`Not a ${types.join(' or ')} lexicon: ${uri}`);
        }
        return def;
    }
    /**
     * Validate a record or object.
     */ validate(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'record',
            'object'
        ]);
        if (!(0, types_1.isObj)(value)) {
            throw new types_1.ValidationError(`Value must be an object`);
        }
        if (def.type === 'record') {
            return ComplexValidators.object(this, 'Record', def.record, value);
        } else if (def.type === 'object') {
            return ComplexValidators.object(this, 'Object', def, value);
        } else {
            // shouldn't happen
            throw new types_1.InvalidLexiconError('Definition must be a record or object');
        }
    }
    /**
     * Validate a record and throw on any error.
     */ assertValidRecord(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'record'
        ]);
        if (!(0, types_1.isObj)(value)) {
            throw new types_1.ValidationError(`Record must be an object`);
        }
        if (!(0, types_1.hasProp)(value, '$type') || typeof value.$type !== 'string') {
            throw new types_1.ValidationError(`Record/$type must be a string`);
        }
        const $type = value.$type || '';
        if ((0, util_1.toLexUri)($type) !== lexUri) {
            throw new types_1.ValidationError(`Invalid $type: must be ${lexUri}, got ${$type}`);
        }
        return (0, validation_1.assertValidRecord)(this, def, value);
    }
    /**
     * Validate xrpc query params and throw on any error.
     */ assertValidXrpcParams(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'query',
            'procedure',
            'subscription'
        ]);
        return (0, validation_1.assertValidXrpcParams)(this, def, value);
    }
    /**
     * Validate xrpc input body and throw on any error.
     */ assertValidXrpcInput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'procedure'
        ]);
        return (0, validation_1.assertValidXrpcInput)(this, def, value);
    }
    /**
     * Validate xrpc output body and throw on any error.
     */ assertValidXrpcOutput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'query',
            'procedure'
        ]);
        return (0, validation_1.assertValidXrpcOutput)(this, def, value);
    }
    /**
     * Validate xrpc subscription message and throw on any error.
     */ assertValidXrpcMessage(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'subscription'
        ]);
        return (0, validation_1.assertValidXrpcMessage)(this, def, value);
    }
    /**
     * Resolve a lex uri given a ref
     */ resolveLexUri(lexUri, ref) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        return (0, util_1.toLexUri)(ref, lexUri);
    }
}
exports.Lexicons = Lexicons;
function* iterDefs(doc) {
    for(const defId in doc.defs){
        yield [
            `lex:${doc.id}#${defId}`,
            doc.defs[defId]
        ];
        if (defId === 'main') {
            yield [
                `lex:${doc.id}`,
                doc.defs[defId]
            ];
        }
    }
}
// WARNING
// this method mutates objects
// -prf
function resolveRefUris(obj, baseUri) {
    for(const k in obj){
        if (obj.type === 'ref') {
            obj.ref = (0, util_1.toLexUri)(obj.ref, baseUri);
        } else if (obj.type === 'union') {
            obj.refs = obj.refs.map((ref)=>(0, util_1.toLexUri)(ref, baseUri));
        } else if (Array.isArray(obj[k])) {
            obj[k] = obj[k].map((item)=>{
                if (typeof item === 'string') {
                    return item.startsWith('#') ? (0, util_1.toLexUri)(item, baseUri) : item;
                } else if (item && typeof item === 'object') {
                    return resolveRefUris(item, baseUri);
                }
                return item;
            });
        } else if (obj[k] && typeof obj[k] === 'object') {
            obj[k] = resolveRefUris(obj[k], baseUri);
        }
    }
    return obj;
} //# sourceMappingURL=lexicons.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/serialize.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jsonStringToLex = exports.jsonToLex = exports.stringifyLex = exports.lexToJson = exports.ipldToLex = exports.lexToIpld = void 0;
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-client] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
const blob_refs_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-client] (ecmascript)");
// @NOTE avoiding use of check.is() here only because it makes
// these implementations slow, and they often live in hot paths.
const lexToIpld = (val)=>{
    // walk arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.lexToIpld)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // convert blobs, leaving the original encoding so that we don't change CIDs on re-encode
        if (val instanceof blob_refs_1.BlobRef) {
            return val.original;
        }
        // retain cids & bytes
        if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
        }
        // walk plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.lexToIpld)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.lexToIpld = lexToIpld;
const ipldToLex = (val)=>{
    // map arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.ipldToLex)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // convert blobs, using hints to avoid expensive is() check
        if ((val['$type'] === 'blob' || typeof val['cid'] === 'string' && typeof val['mimeType'] === 'string') && common_web_1.check.is(val, blob_refs_1.jsonBlobRef)) {
            return blob_refs_1.BlobRef.fromJsonRef(val);
        }
        // retain cids, bytes
        if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
        }
        // map plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.ipldToLex)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.ipldToLex = ipldToLex;
const lexToJson = (val)=>{
    return (0, common_web_1.ipldToJson)((0, exports.lexToIpld)(val));
};
exports.lexToJson = lexToJson;
const stringifyLex = (val)=>{
    return JSON.stringify((0, exports.lexToJson)(val));
};
exports.stringifyLex = stringifyLex;
const jsonToLex = (val)=>{
    return (0, exports.ipldToLex)((0, common_web_1.jsonToIpld)(val));
};
exports.jsonToLex = jsonToLex;
const jsonStringToLex = (val)=>{
    return (0, exports.jsonToLex)(JSON.parse(val));
};
exports.jsonStringToLex = jsonStringToLex; //# sourceMappingURL=serialize.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/lexicons.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/serialize.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/check.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Explicitly not using "zod" types here to avoid mismatching types due to
// version differences.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isObject = exports.assure = exports.create = exports.is = void 0;
const is = (obj, def)=>{
    return def.safeParse(obj).success;
};
exports.is = is;
const create = (def)=>(v)=>def.safeParse(v).success;
exports.create = create;
const assure = (def, obj)=>{
    return def.parse(obj);
};
exports.assure = assure;
const isObject = (obj)=>{
    return typeof obj === 'object' && obj !== null;
};
exports.isObject = isObject; //# sourceMappingURL=check.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseIntWithFallback = exports.dedupeStrs = exports.range = exports.chunkArray = exports.errHasMsg = exports.isErrnoException = exports.asyncFilter = exports.s32decode = exports.s32encode = exports.streamToBuffer = exports.flattenUint8Arrays = exports.bailableWait = exports.wait = exports.jitter = exports.noUndefinedVals = void 0;
exports.omit = omit;
const noUndefinedVals = (obj)=>{
    Object.keys(obj).forEach((k)=>{
        if (obj[k] === undefined) {
            delete obj[k];
        }
    });
    return obj;
};
exports.noUndefinedVals = noUndefinedVals;
function omit(src, rejectedKeys) {
    // Hot path
    if (!src) return src;
    const dst = {};
    const srcKeys = Object.keys(src);
    for(let i = 0; i < srcKeys.length; i++){
        const key = srcKeys[i];
        if (!rejectedKeys.includes(key)) {
            dst[key] = src[key];
        }
    }
    return dst;
}
const jitter = (maxMs)=>{
    return Math.round((Math.random() - 0.5) * maxMs * 2);
};
exports.jitter = jitter;
const wait = (ms)=>{
    return new Promise((res)=>setTimeout(res, ms));
};
exports.wait = wait;
const bailableWait = (ms)=>{
    let bail;
    const waitPromise = new Promise((res)=>{
        const timeout = setTimeout(res, ms);
        bail = ()=>{
            clearTimeout(timeout);
            res();
        };
    });
    return {
        bail,
        wait: ()=>waitPromise
    };
};
exports.bailableWait = bailableWait;
const flattenUint8Arrays = (arrs)=>{
    const length = arrs.reduce((acc, cur)=>{
        return acc + cur.length;
    }, 0);
    const flattened = new Uint8Array(length);
    let offset = 0;
    arrs.forEach((arr)=>{
        flattened.set(arr, offset);
        offset += arr.length;
    });
    return flattened;
};
exports.flattenUint8Arrays = flattenUint8Arrays;
const streamToBuffer = async (stream)=>{
    const arrays = [];
    for await (const chunk of stream){
        arrays.push(chunk);
    }
    return (0, exports.flattenUint8Arrays)(arrays);
};
exports.streamToBuffer = streamToBuffer;
const S32_CHAR = '234567abcdefghijklmnopqrstuvwxyz';
const s32encode = (i)=>{
    let s = '';
    while(i){
        const c = i % 32;
        i = Math.floor(i / 32);
        s = S32_CHAR.charAt(c) + s;
    }
    return s;
};
exports.s32encode = s32encode;
const s32decode = (s)=>{
    let i = 0;
    for (const c of s){
        i = i * 32 + S32_CHAR.indexOf(c);
    }
    return i;
};
exports.s32decode = s32decode;
const asyncFilter = async (arr, fn)=>{
    const results = await Promise.all(arr.map((t)=>fn(t)));
    return arr.filter((_, i)=>results[i]);
};
exports.asyncFilter = asyncFilter;
const isErrnoException = (err)=>{
    return !!err && err['code'];
};
exports.isErrnoException = isErrnoException;
const errHasMsg = (err, msg)=>{
    return !!err && typeof err === 'object' && err['message'] === msg;
};
exports.errHasMsg = errHasMsg;
const chunkArray = (arr, chunkSize)=>{
    return arr.reduce((acc, cur, i)=>{
        const chunkI = Math.floor(i / chunkSize);
        if (!acc[chunkI]) {
            acc[chunkI] = [];
        }
        acc[chunkI].push(cur);
        return acc;
    }, []);
};
exports.chunkArray = chunkArray;
const range = (num)=>{
    const nums = [];
    for(let i = 0; i < num; i++){
        nums.push(i);
    }
    return nums;
};
exports.range = range;
const dedupeStrs = (strs)=>{
    return [
        ...new Set(strs)
    ];
};
exports.dedupeStrs = dedupeStrs;
const parseIntWithFallback = (value, fallback)=>{
    const parsed = parseInt(value || '', 10);
    return isNaN(parsed) ? fallback : parsed;
};
exports.parseIntWithFallback = parseIntWithFallback; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/arrays.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapDefined = exports.keyBy = void 0;
const keyBy = (arr, key)=>{
    return arr.reduce((acc, cur)=>{
        acc[cur[key]] = cur;
        return acc;
    }, {});
};
exports.keyBy = keyBy;
const mapDefined = (arr, fn)=>{
    const output = [];
    for (const item of arr){
        const val = fn(item);
        if (val !== undefined) {
            output.push(val);
        }
    }
    return output;
};
exports.mapDefined = mapDefined; //# sourceMappingURL=arrays.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/async.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsyncBufferFullError = exports.AsyncBuffer = exports.allComplete = exports.createDeferrables = exports.createDeferrable = exports.readFromGenerator = void 0;
exports.allFulfilled = allFulfilled;
exports.handleAllSettledErrors = handleAllSettledErrors;
exports.isRejectedResult = isRejectedResult;
exports.isFulfilledResult = isFulfilledResult;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-client] (ecmascript)");
// reads values from a generator into a list
// breaks when isDone signals `true` AND `waitFor` completes OR when a max length is reached
// NOTE: does not signal generator to close. it *will* continue to produce values
const readFromGenerator = async (gen, isDone, waitFor = Promise.resolve(), maxLength = Number.MAX_SAFE_INTEGER)=>{
    const evts = [];
    let bail;
    let hasBroke = false;
    const awaitDone = async ()=>{
        if (await isDone(evts.at(-1))) {
            return true;
        }
        const bailable = (0, util_1.bailableWait)(20);
        await bailable.wait();
        bail = bailable.bail;
        if (hasBroke) return false;
        return await awaitDone();
    };
    const breakOn = new Promise((resolve)=>{
        waitFor.then(()=>{
            awaitDone().then(()=>resolve());
        });
    });
    try {
        while(evts.length < maxLength){
            const maybeEvt = await Promise.race([
                gen.next(),
                breakOn
            ]);
            if (!maybeEvt) break;
            const evt = maybeEvt;
            if (evt.done) break;
            evts.push(evt.value);
        }
    } finally{
        hasBroke = true;
        bail && bail();
    }
    return evts;
};
exports.readFromGenerator = readFromGenerator;
const createDeferrable = ()=>{
    let resolve;
    const promise = new Promise((res)=>{
        resolve = ()=>res();
    });
    return {
        resolve,
        complete: promise
    };
};
exports.createDeferrable = createDeferrable;
const createDeferrables = (count)=>{
    const list = [];
    for(let i = 0; i < count; i++){
        list.push((0, exports.createDeferrable)());
    }
    return list;
};
exports.createDeferrables = createDeferrables;
const allComplete = async (deferrables)=>{
    await Promise.all(deferrables.map((d)=>d.complete));
};
exports.allComplete = allComplete;
class AsyncBuffer {
    constructor(maxSize){
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: maxSize
        });
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "promise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "toThrow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Initializing to satisfy types/build, immediately reset by resetPromise()
        this.promise = Promise.resolve();
        this.resolve = ()=>null;
        this.resetPromise();
    }
    get curr() {
        return this.buffer;
    }
    get size() {
        return this.buffer.length;
    }
    get isClosed() {
        return this.closed;
    }
    resetPromise() {
        this.promise = new Promise((r)=>this.resolve = r);
    }
    push(item) {
        this.buffer.push(item);
        this.resolve();
    }
    pushMany(items) {
        items.forEach((i)=>this.buffer.push(i));
        this.resolve();
    }
    async *events() {
        while(true){
            if (this.closed && this.buffer.length === 0) {
                if (this.toThrow) {
                    throw this.toThrow;
                } else {
                    return;
                }
            }
            await this.promise;
            if (this.toThrow) {
                throw this.toThrow;
            }
            if (this.maxSize && this.size > this.maxSize) {
                throw new AsyncBufferFullError(this.maxSize);
            }
            const [first, ...rest] = this.buffer;
            if (first) {
                this.buffer = rest;
                yield first;
            } else {
                this.resetPromise();
            }
        }
    }
    throw(err) {
        this.toThrow = err;
        this.closed = true;
        this.resolve();
    }
    close() {
        this.closed = true;
        this.resolve();
    }
}
exports.AsyncBuffer = AsyncBuffer;
class AsyncBufferFullError extends Error {
    constructor(maxSize){
        super(`ReachedMaxBufferSize: ${maxSize}`);
    }
}
exports.AsyncBufferFullError = AsyncBufferFullError;
function allFulfilled(promises) {
    return Promise.allSettled(promises).then(handleAllSettledErrors);
}
function handleAllSettledErrors(results) {
    const errors = results.filter(isRejectedResult).map(extractReason);
    if (errors.length === 0) {
        // No need to filter here, it is safe to assume that all promises are fulfilled
        return results.map(extractValue);
    }
    if (errors.length === 1) {
        throw errors[0];
    }
    throw new AggregateError(errors, `Multiple errors: ${errors.map(stringifyReason).join('\n')}`);
}
function isRejectedResult(result) {
    return result.status === 'rejected';
}
function extractReason(result) {
    return result.reason;
}
function isFulfilledResult(result) {
    return result.status === 'fulfilled';
}
function extractValue(result) {
    return result.value;
}
function stringifyReason(reason) {
    if (reason instanceof Error) {
        return reason.message;
    }
    return String(reason);
} //# sourceMappingURL=async.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/tid.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TID = void 0;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-client] (ecmascript)");
const TID_LEN = 13;
let lastTimestamp = 0;
let timestampCount = 0;
let clockid = null;
function dedash(str) {
    return str.replaceAll('-', '');
}
class TID {
    constructor(str){
        Object.defineProperty(this, "str", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const noDashes = dedash(str);
        if (noDashes.length !== TID_LEN) {
            throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
        }
        this.str = noDashes;
    }
    static next(prev) {
        // javascript does not have microsecond precision
        // instead, we append a counter to the timestamp to indicate if multiple timestamps were created within the same millisecond
        // take max of current time & last timestamp to prevent tids moving backwards if system clock drifts backwards
        const time = Math.max(Date.now(), lastTimestamp);
        if (time === lastTimestamp) {
            timestampCount++;
        }
        lastTimestamp = time;
        const timestamp = time * 1000 + timestampCount;
        // the bottom 32 clock ids can be randomized & are not guaranteed to be collision resistant
        // we use the same clockid for all tids coming from this machine
        if (clockid === null) {
            clockid = Math.floor(Math.random() * 32);
        }
        const tid = TID.fromTime(timestamp, clockid);
        if (!prev || tid.newerThan(prev)) {
            return tid;
        }
        return TID.fromTime(prev.timestamp() + 1, clockid);
    }
    static nextStr(prev) {
        return TID.next(prev ? new TID(prev) : undefined).toString();
    }
    static fromTime(timestamp, clockid) {
        // base32 encode with encoding variant sort (s32)
        const str = `${(0, util_1.s32encode)(timestamp)}${(0, util_1.s32encode)(clockid).padStart(2, '2')}`;
        return new TID(str);
    }
    static fromStr(str) {
        return new TID(str);
    }
    static oldestFirst(a, b) {
        return a.compareTo(b);
    }
    static newestFirst(a, b) {
        return b.compareTo(a);
    }
    static is(str) {
        return dedash(str).length === TID_LEN;
    }
    timestamp() {
        return (0, util_1.s32decode)(this.str.slice(0, 11));
    }
    clockid() {
        return (0, util_1.s32decode)(this.str.slice(11, 13));
    }
    formatted() {
        const str = this.toString();
        return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(7, 11)}-${str.slice(11, 13)}`;
    }
    toString() {
        return this.str;
    }
    // newer > older
    compareTo(other) {
        if (this.str > other.str) return 1;
        if (this.str < other.str) return -1;
        return 0;
    }
    equals(other) {
        return this.str === other.str;
    }
    newerThan(other) {
        return this.compareTo(other) > 0;
    }
    olderThan(other) {
        return this.compareTo(other) < 0;
    }
}
exports.TID = TID;
exports.default = TID; //# sourceMappingURL=tid.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/ipld.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ipldEquals = exports.ipldToJson = exports.jsonToIpld = void 0;
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
const ui8 = __importStar(__turbopack_require__("[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript)"));
// @NOTE avoiding use of check.is() here only because it makes
// these implementations slow, and they often live in hot paths.
const jsonToIpld = (val)=>{
    // walk arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.jsonToIpld)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // check for dag json values
        if (typeof val['$link'] === 'string' && Object.keys(val).length === 1) {
            return cid_1.CID.parse(val['$link']);
        }
        if (typeof val['$bytes'] === 'string' && Object.keys(val).length === 1) {
            return ui8.fromString(val['$bytes'], 'base64');
        }
        // walk plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.jsonToIpld)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.jsonToIpld = jsonToIpld;
const ipldToJson = (val)=>{
    // walk arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.ipldToJson)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // convert bytes
        if (val instanceof Uint8Array) {
            return {
                $bytes: ui8.toString(val, 'base64')
            };
        }
        // convert cids
        if (cid_1.CID.asCID(val)) {
            return {
                $link: val.toString()
            };
        }
        // walk plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.ipldToJson)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.ipldToJson = ipldToJson;
const ipldEquals = (a, b)=>{
    // walk arrays
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length; i++){
            if (!(0, exports.ipldEquals)(a[i], b[i])) return false;
        }
        return true;
    }
    // objects
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        // check bytes
        if (a instanceof Uint8Array && b instanceof Uint8Array) {
            return ui8.equals(a, b);
        }
        // check cids
        if (cid_1.CID.asCID(a) && cid_1.CID.asCID(b)) {
            return cid_1.CID.asCID(a)?.equals(cid_1.CID.asCID(b));
        }
        // walk plain objects
        if (Object.keys(a).length !== Object.keys(b).length) return false;
        for (const key of Object.keys(a)){
            if (!(0, exports.ipldEquals)(a[key], b[key])) return false;
        }
        return true;
    }
    return a === b;
};
exports.ipldEquals = ipldEquals; //# sourceMappingURL=ipld.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/retry.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.retry = retry;
exports.createRetryable = createRetryable;
exports.backoffMs = backoffMs;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-client] (ecmascript)");
async function retry(fn, opts = {}) {
    const { maxRetries = 3, retryable = ()=>true, getWaitMs = backoffMs } = opts;
    let retries = 0;
    let doneError;
    while(!doneError){
        try {
            return await fn();
        } catch (err) {
            const waitMs = getWaitMs(retries);
            const willRetry = retries < maxRetries && waitMs !== null && retryable(err);
            if (willRetry) {
                retries += 1;
                if (waitMs !== 0) {
                    await (0, util_1.wait)(waitMs);
                }
            } else {
                doneError = err;
            }
        }
    }
    throw doneError;
}
function createRetryable(retryable) {
    return async (fn, opts)=>retry(fn, {
            ...opts,
            retryable
        });
}
// Waits exponential backoff with max and jitter: ~100, ~200, ~400, ~800, ~1000, ~1000, ...
function backoffMs(n, multiplier = 100, max = 1000) {
    const exponentialMs = Math.pow(2, n) * multiplier;
    const ms = Math.min(exponentialMs, max);
    return jitter(ms);
}
// Adds randomness +/-15% of value
function jitter(value) {
    const delta = value * 0.15;
    return value + randomRange(-delta, delta);
}
function randomRange(from, to) {
    const rand = Math.random() * (to - from);
    return rand + from;
} //# sourceMappingURL=retry.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.def = exports.schema = void 0;
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-client] (ecmascript)");
const cidSchema = zod_1.z.any().refine((obj)=>cid_1.CID.asCID(obj) !== null, {
    message: 'Not a CID'
}).transform((obj)=>cid_1.CID.asCID(obj));
exports.schema = {
    cid: cidSchema,
    bytes: zod_1.z.instanceof(Uint8Array),
    string: zod_1.z.string(),
    array: zod_1.z.array(zod_1.z.unknown()),
    map: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
    unknown: zod_1.z.unknown()
};
exports.def = {
    cid: {
        name: 'cid',
        schema: exports.schema.cid
    },
    bytes: {
        name: 'bytes',
        schema: exports.schema.bytes
    },
    string: {
        name: 'string',
        schema: exports.schema.string
    },
    map: {
        name: 'map',
        schema: exports.schema.map
    },
    unknown: {
        name: 'unknown',
        schema: exports.schema.unknown
    }
}; //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/times.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addHoursToDate = exports.lessThanAgoMs = exports.DAY = exports.HOUR = exports.MINUTE = exports.SECOND = void 0;
exports.SECOND = 1000;
exports.MINUTE = exports.SECOND * 60;
exports.HOUR = exports.MINUTE * 60;
exports.DAY = exports.HOUR * 24;
const lessThanAgoMs = (time, range)=>{
    return Date.now() < time.getTime() + range;
};
exports.lessThanAgoMs = lessThanAgoMs;
const addHoursToDate = (hours, startingDate)=>{
    // When date is passed, clone before calling `setHours()` so that we are not mutating the original date
    const currentDate = startingDate ? new Date(startingDate) : new Date();
    currentDate.setHours(currentDate.getHours() + hours);
    return currentDate;
};
exports.addHoursToDate = addHoursToDate; //# sourceMappingURL=times.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/strings.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateLanguage = exports.parseLanguage = exports.b64UrlToUtf8 = exports.utf8ToB64Url = exports.graphemeLen = exports.utf8Len = void 0;
const graphemer_1 = __importDefault(__turbopack_require__("[project]/node_modules/graphemer/lib/index.js [app-client] (ecmascript)"));
const ui8 = __importStar(__turbopack_require__("[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript)"));
// counts the number of bytes in a utf8 string
const utf8Len = (str)=>{
    return new TextEncoder().encode(str).byteLength;
};
exports.utf8Len = utf8Len;
// counts the number of graphemes (user-displayed characters) in a string
const graphemeLen = (str)=>{
    const splitter = new graphemer_1.default();
    return splitter.countGraphemes(str);
};
exports.graphemeLen = graphemeLen;
const utf8ToB64Url = (utf8)=>{
    return ui8.toString(ui8.fromString(utf8, 'utf8'), 'base64url');
};
exports.utf8ToB64Url = utf8ToB64Url;
const b64UrlToUtf8 = (b64)=>{
    return ui8.toString(ui8.fromString(b64, 'base64url'), 'utf8');
};
exports.b64UrlToUtf8 = b64UrlToUtf8;
const parseLanguage = (langTag)=>{
    const parsed = langTag.match(bcp47Regexp);
    if (!parsed?.groups) return null;
    const parts = parsed.groups;
    return {
        grandfathered: parts.grandfathered,
        language: parts.language,
        extlang: parts.extlang,
        script: parts.script,
        region: parts.region,
        variant: parts.variant,
        extension: parts.extension,
        privateUse: parts.privateUseA || parts.privateUseB
    };
};
exports.parseLanguage = parseLanguage;
const validateLanguage = (langTag)=>{
    return bcp47Regexp.test(langTag);
};
exports.validateLanguage = validateLanguage;
// Validates well-formed BCP 47 syntax: https://www.rfc-editor.org/rfc/rfc5646.html#section-2.1
const bcp47Regexp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/; //# sourceMappingURL=strings.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/did-doc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didDocument = exports.getServiceEndpoint = exports.getNotifEndpoint = exports.getFeedGenEndpoint = exports.getPdsEndpoint = exports.getSigningDidKey = exports.getVerificationMaterial = exports.getSigningKey = exports.getHandle = exports.getDid = exports.isValidDidDoc = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-client] (ecmascript)");
// Parsing atproto data
// --------
const isValidDidDoc = (doc)=>{
    return exports.didDocument.safeParse(doc).success;
};
exports.isValidDidDoc = isValidDidDoc;
const getDid = (doc)=>{
    const id = doc.id;
    if (typeof id !== 'string') {
        throw new Error('No `id` on document');
    }
    return id;
};
exports.getDid = getDid;
const getHandle = (doc)=>{
    const aka = doc.alsoKnownAs;
    if (aka) {
        for(let i = 0; i < aka.length; i++){
            const alias = aka[i];
            if (alias.startsWith('at://')) {
                // strip off "at://" prefix
                return alias.slice(5);
            }
        }
    }
    return undefined;
};
exports.getHandle = getHandle;
// @NOTE we parse to type/publicKeyMultibase to avoid the dependency on @atproto/crypto
const getSigningKey = (doc)=>{
    return (0, exports.getVerificationMaterial)(doc, 'atproto');
};
exports.getSigningKey = getSigningKey;
const getVerificationMaterial = (doc, keyId)=>{
    // /!\ Hot path
    const key = findItemById(doc, 'verificationMethod', `#${keyId}`);
    if (!key) {
        return undefined;
    }
    if (!key.publicKeyMultibase) {
        return undefined;
    }
    return {
        type: key.type,
        publicKeyMultibase: key.publicKeyMultibase
    };
};
exports.getVerificationMaterial = getVerificationMaterial;
const getSigningDidKey = (doc)=>{
    const parsed = (0, exports.getSigningKey)(doc);
    if (!parsed) return;
    return `did:key:${parsed.publicKeyMultibase}`;
};
exports.getSigningDidKey = getSigningDidKey;
const getPdsEndpoint = (doc)=>{
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#atproto_pds',
        type: 'AtprotoPersonalDataServer'
    });
};
exports.getPdsEndpoint = getPdsEndpoint;
const getFeedGenEndpoint = (doc)=>{
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#bsky_fg',
        type: 'BskyFeedGenerator'
    });
};
exports.getFeedGenEndpoint = getFeedGenEndpoint;
const getNotifEndpoint = (doc)=>{
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#bsky_notif',
        type: 'BskyNotificationService'
    });
};
exports.getNotifEndpoint = getNotifEndpoint;
const getServiceEndpoint = (doc, opts)=>{
    // /!\ Hot path
    const service = findItemById(doc, 'service', opts.id);
    if (!service) {
        return undefined;
    }
    if (opts.type && service.type !== opts.type) {
        return undefined;
    }
    if (typeof service.serviceEndpoint !== 'string') {
        return undefined;
    }
    return validateUrl(service.serviceEndpoint);
};
exports.getServiceEndpoint = getServiceEndpoint;
function findItemById(doc, type, id) {
    // /!\ Hot path
    const items = doc[type];
    if (items) {
        for(let i = 0; i < items.length; i++){
            const item = items[i];
            const itemId = item.id;
            if (itemId[0] === '#' ? itemId === id : itemId.length === doc.id.length + id.length && itemId[doc.id.length] === '#' && itemId.endsWith(id) && itemId.startsWith(doc.id) // <== We could probably skip this check
            ) {
                return item;
            }
        }
    }
    return undefined;
}
// Check protocol and hostname to prevent potential SSRF
const validateUrl = (urlStr)=>{
    if (!urlStr.startsWith('http://') && !urlStr.startsWith('https://')) {
        return undefined;
    }
    if (!canParseUrl(urlStr)) {
        return undefined;
    }
    return urlStr;
};
const canParseUrl = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
((urlStr)=>{
    try {
        new URL(urlStr);
        return true;
    } catch  {
        return false;
    }
});
// Types
// --------
const verificationMethod = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.string(),
    controller: zod_1.z.string(),
    publicKeyMultibase: zod_1.z.string().optional()
});
const service = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.string(),
    serviceEndpoint: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.record(zod_1.z.unknown())
    ])
});
exports.didDocument = zod_1.z.object({
    id: zod_1.z.string(),
    alsoKnownAs: zod_1.z.array(zod_1.z.string()).optional(),
    verificationMethod: zod_1.z.array(verificationMethod).optional(),
    service: zod_1.z.array(service).optional()
}); //# sourceMappingURL=did-doc.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.util = exports.check = void 0;
exports.check = __importStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/check.js [app-client] (ecmascript)"));
exports.util = __importStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-client] (ecmascript)"));
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/arrays.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/async.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/tid.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/ipld.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/retry.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/types.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/times.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/strings.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/did-doc.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/multiformats/esm/vendor/varint.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var encode_1 = encode;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 255 | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1)
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
const __TURBOPACK__default__export__ = _brrp_varint;
}}),
"[project]/node_modules/multiformats/esm/src/varint.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "decode": (()=>decode),
    "encodeTo": (()=>encodeTo),
    "encodingLength": (()=>encodingLength)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/vendor/varint.js [app-client] (ecmascript)");
;
const decode = (data, offset = 0)=>{
    const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(data, offset);
    return [
        code,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes
    ];
};
const encodeTo = (int, target, offset = 0)=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(int, target, offset);
    return target;
};
const encodingLength = (int)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(int);
};
}}),
"[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "coerce": (()=>coerce),
    "empty": (()=>empty),
    "equals": (()=>equals),
    "fromHex": (()=>fromHex),
    "fromString": (()=>fromString),
    "isBinary": (()=>isBinary),
    "toHex": (()=>toHex),
    "toString": (()=>toString)
});
const empty = new Uint8Array(0);
const toHex = (d)=>d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, '0'), '');
const fromHex = (hex)=>{
    const hexes = hex.match(/../g);
    return hexes ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
};
const equals = (aa, bb)=>{
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
};
const coerce = (o)=>{
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
};
const isBinary = (o)=>o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString = (str)=>new TextEncoder().encode(str);
const toString = (b)=>new TextDecoder().decode(b);
;
}}),
"[project]/node_modules/multiformats/esm/src/hashes/digest.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Digest": (()=>Digest),
    "create": (()=>create),
    "decode": (()=>decode),
    "equals": (()=>equals)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/varint.js [app-client] (ecmascript)");
;
;
const create = (code, digest)=>{
    const size = digest.byteLength;
    const sizeOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(code);
    const digestOffset = sizeOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(code, bytes, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
};
const decode = (multihash)=>{
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(multihash);
    const [code, sizeOffset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(bytes);
    const [size, digestOffset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error('Incorrect length');
    }
    return new Digest(code, size, digest, bytes);
};
const equals = (a, b)=>{
    if (a === b) {
        return true;
    } else {
        return a.code === b.code && a.size === b.size && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(a.bytes, b.bytes);
    }
};
class Digest {
    constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}
}}),
"[project]/node_modules/multiformats/esm/vendor/base-x.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while(pbegin !== pend){
            var carry = source[pbegin];
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === ' ') {
            return;
        }
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while(source[psz]){
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        if (source[psz] === ' ') {
            return;
        }
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const __TURBOPACK__default__export__ = _brrp__multiformats_scope_baseX;
}}),
"[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Codec": (()=>Codec),
    "baseX": (()=>baseX),
    "from": (()=>from),
    "or": (()=>or),
    "rfc4648": (()=>rfc4648)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$base$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/vendor/base-x.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
;
;
class Encoder {
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
class Decoder {
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        } else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
            return decoder.decode(input);
        } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
const or = (left, right)=>new ComposedDecoder({
        ...left.decoders || {
            [left.prefix]: left
        },
        ...right.decoders || {
            [right.prefix]: right
        }
    });
class Codec {
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
const from = ({ name, prefix, encode, decode })=>new Codec(name, prefix, encode, decode);
const baseX = ({ prefix, name, alphabet })=>{
    const { encode, decode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$vendor$2f$base$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(decode(text))
    });
};
const decode = (string, alphabet, bitsPerChar, name)=>{
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i){
        codes[alphabet[i]] = i;
    }
    let end = string.length;
    while(string[end - 1] === '='){
        --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for(let i = 0; i < end; ++i){
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
        }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
};
const encode = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0;
    let buffer = 0;
    for(let i = 0; i < data.length; ++i){
        buffer = buffer << 8 | data[i];
        bits += 8;
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
        while(out.length * bitsPerChar & 7){
            out += '=';
        }
    }
    return out;
};
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet })=>{
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
};
}}),
"[project]/node_modules/multiformats/esm/src/bases/base58.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base58btc": (()=>base58btc),
    "base58flickr": (()=>base58flickr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base58btc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base32.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base32": (()=>base32),
    "base32hex": (()=>base32hex),
    "base32hexpad": (()=>base32hexpad),
    "base32hexpadupper": (()=>base32hexpadupper),
    "base32hexupper": (()=>base32hexupper),
    "base32pad": (()=>base32pad),
    "base32padupper": (()=>base32padupper),
    "base32upper": (()=>base32upper),
    "base32z": (()=>base32z)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
const base32upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
const base32pad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
const base32padupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
const base32hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
const base32hexupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
const base32hexpad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
const base32hexpadupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
const base32z = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
});
}}),
"[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CID": (()=>CID)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/varint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
;
;
;
;
;
class CID {
    constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = new Map();
        Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
        });
    }
    toV0() {
        switch(this.version){
            case 0:
                {
                    return this;
                }
            default:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) {
                        throw new Error('Cannot convert a non dag-pb CID to CIDv0');
                    }
                    if (multihash.code !== SHA_256_CODE) {
                        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
                    }
                    return CID.createV0(multihash);
                }
        }
    }
    toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest } = this.multihash;
                    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(code, digest);
                    return CID.createV1(this.code, multihash);
                }
            case 1:
                {
                    return this;
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
                }
        }
    }
    equals(other) {
        return other && this.code === other.code && this.version === other.version && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.equals(this.multihash, other.multihash);
    }
    toString(base) {
        const { bytes, version, _baseCache } = this;
        switch(version){
            case 0:
                return toStringV0(bytes, _baseCache, base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encoder);
            default:
                return toStringV1(bytes, _baseCache, base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].encoder);
        }
    }
    toJSON() {
        return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
        };
    }
    get [Symbol.toStringTag]() {
        return 'CID';
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return 'CID(' + this.toString() + ')';
    }
    static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
    }
    get toBaseEncodedString() {
        throw new Error('Deprecated, use .toString()');
    }
    get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
        throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
    }
    get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
        throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
        if (value instanceof CID) {
            return value;
        } else if (value != null && value.asCID === value) {
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
            const { version, multihash, code } = value;
            const digest = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(multihash);
            return CID.create(version, code, digest);
        } else {
            return null;
        }
    }
    static create(version, code, digest) {
        if (typeof code !== 'number') {
            throw new Error('String codecs are no longer supported');
        }
        switch(version){
            case 0:
                {
                    if (code !== DAG_PB_CODE) {
                        throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                    } else {
                        return new CID(version, code, digest, digest.bytes);
                    }
                }
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                {
                    throw new Error('Invalid version');
                }
        }
    }
    static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
            throw new Error('Incorrect length');
        }
        return cid;
    }
    static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error('Incorrect length');
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [
            cid,
            bytes.subarray(specs.size)
        ];
    }
    static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            version = 0;
            offset = 0;
        } else if (version === 1) {
            codec = next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
    }
}
const parseCIDtoBytes = (source, base)=>{
    switch(source[0]){
        case 'Q':
            {
                const decoder = base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix,
                    decoder.decode(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix}${source}`)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix:
            {
                const decoder = base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix,
                    decoder.decode(source)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].prefix:
            {
                const decoder = base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].prefix,
                    decoder.decode(source)
                ];
            }
        default:
            {
                if (base == null) {
                    throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
                }
                return [
                    source[0],
                    base.decode(source)
                ];
            }
    }
};
const toStringV0 = (bytes, cache, base)=>{
    const { prefix } = base;
    if (prefix !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    }
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
};
const toStringV1 = (bytes, cache, base)=>{
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version, code, multihash)=>{
    const codeOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(version);
    const hashOffset = codeOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(version, bytes, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
};
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
const readonly = {
    writable: false,
    configurable: false,
    enumerable: true
};
const hidden = {
    writable: false,
    enumerable: false,
    configurable: false
};
const version = '0.0.0-dev';
const deprecate = (range, message)=>{
    if (range.test(version)) {
        console.warn(message);
    } else {
        throw new Error(message);
    }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
}}),
"[project]/node_modules/multiformats/esm/src/bases/identity.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "identity": (()=>identity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
;
;
const identity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    prefix: '\0',
    name: 'identity',
    encode: (buf)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf),
    decode: (str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(str)
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base2": (()=>base2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base8.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base8": (()=>base8)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base8 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base10.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base10": (()=>base10)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base10 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base16.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base16": (()=>base16),
    "base16upper": (()=>base16upper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base16 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
});
const base16upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base36.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base36": (()=>base36),
    "base36upper": (()=>base36upper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base36 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base64.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base64": (()=>base64),
    "base64pad": (()=>base64pad),
    "base64url": (()=>base64url),
    "base64urlpad": (()=>base64urlpad)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const base64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
});
}}),
"[project]/node_modules/multiformats/esm/src/bases/base256emoji.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base256emoji": (()=>base256emoji)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base.js [app-client] (ecmascript)");
;
const alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42');
const alphabetBytesToChars = alphabet.reduce((p, c, i)=>{
    p[i] = c;
    return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i)=>{
    p[c.codePointAt(0)] = i;
    return p;
}, []);
function encode(data) {
    return data.reduce((p, c)=>{
        p += alphabetBytesToChars[c];
        return p;
    }, '');
}
function decode(str) {
    const byts = [];
    for (const char of str){
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) {
            throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    prefix: '\uD83D\uDE80',
    name: 'base256emoji',
    encode,
    decode
});
}}),
"[project]/node_modules/multiformats/esm/src/hashes/hasher.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Hasher": (()=>Hasher),
    "from": (()=>from)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/digest.js [app-client] (ecmascript)");
;
const from = ({ name, code, encode })=>new Hasher(name, code, encode);
class Hasher {
    constructor(name, code, encode){
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(this.code, result) : result.then((digest)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(this.code, digest));
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
}}),
"[project]/node_modules/multiformats/esm/src/hashes/sha2-browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "sha256": (()=>sha256),
    "sha512": (()=>sha512)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/hasher.js [app-client] (ecmascript)");
;
const sha = (name)=>async (data)=>new Uint8Array(await crypto.subtle.digest(name, data));
const sha256 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'sha2-256',
    code: 18,
    encode: sha('SHA-256')
});
const sha512 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'sha2-512',
    code: 19,
    encode: sha('SHA-512')
});
}}),
"[project]/node_modules/multiformats/esm/src/hashes/identity.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "identity": (()=>identity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/digest.js [app-client] (ecmascript)");
;
;
const code = 0;
const name = 'identity';
const encode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"];
const digest = (input)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(code, encode(input));
const identity = {
    code,
    name,
    encode,
    digest
};
}}),
"[project]/node_modules/multiformats/esm/src/codecs/raw.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "name": (()=>name)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
;
const name = 'raw';
const code = 85;
const encode = (node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(node);
const decode = (data)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(data);
}}),
"[project]/node_modules/multiformats/esm/src/codecs/json.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "name": (()=>name)
});
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 512;
const encode = (node)=>textEncoder.encode(JSON.stringify(node));
const decode = (data)=>JSON.parse(textDecoder.decode(data));
}}),
"[project]/node_modules/multiformats/esm/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
}}),
"[project]/node_modules/multiformats/esm/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/cid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/varint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/hasher.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bases": (()=>bases),
    "codecs": (()=>codecs),
    "hashes": (()=>hashes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base10.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base16.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base256emoji.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/codecs/json.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const bases = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const hashes = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const codecs = {
    raw: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    json: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
;
}}),
"[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base10.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base16.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/bases/base256emoji.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/codecs/json.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "compare": (()=>compare)
});
function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
}
}}),
"[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "concat": (()=>concat)
});
function concat(arrays, length) {
    if (!length) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return output;
}
}}),
"[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "equals": (()=>equals)
});
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
}}),
"[project]/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <locals>");
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
}}),
"[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "fromString": (()=>fromString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)");
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base.decoder.decode(`${base.prefix}${string}`);
}
}}),
"[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base.encoder.encode(array).substring(1);
}
}}),
"[project]/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "xor": (()=>xor)
});
function xor(a, b) {
    if (a.length !== b.length) {
        throw new Error('Inputs should have the same length');
    }
    const result = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++){
        result[i] = a[i] ^ b[i];
    }
    return result;
}
}}),
"[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
;
}}),
"[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "compare": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compare"]),
    "concat": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"]),
    "equals": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"]),
    "fromString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"]),
    "toString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"]),
    "xor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["xor"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "compare": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["compare"]),
    "concat": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["concat"]),
    "equals": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["equals"]),
    "fromString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["fromString"]),
    "toString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toString"]),
    "xor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["xor"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/iso-datestring-validator/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        d: (t, r)=>{
            for(var n in r)e.o(r, n) && !e.o(t, n) && Object.defineProperty(t, n, {
                enumerable: !0,
                get: r[n]
            });
        },
        o: (e, t)=>Object.prototype.hasOwnProperty.call(e, t),
        r: (e)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        }
    }, t = {};
    function r(e, t) {
        return void 0 === t && (t = "-"), new RegExp("^(?!0{4}" + t + "0{2}" + t + "0{2})((?=[0-9]{4}" + t + "(((0[^2])|1[0-2])|02(?=" + t + "(([0-1][0-9])|2[0-8])))" + t + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t + "02" + t + "29))([0-9]{4})" + t + "(?!((0[469])|11)" + t + "31)((0[1,3-9]|1[0-2])|(02(?!" + t + "3)))" + t + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e);
    }
    function n(e) {
        var t = /\D/.exec(e);
        return t ? t[0] : "";
    }
    function i(e, t, r) {
        void 0 === t && (t = ":"), void 0 === r && (r = !1);
        var i = new RegExp("^([0-1]|2(?=([0-3])|4" + t + "00))[0-9]" + t + "[0-5][0-9](" + t + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
        if (!r || !/[Z+\-]/.test(e)) return i.test(e);
        if (/Z$/.test(e)) return i.test(e.replace("Z", ""));
        var o = e.includes("+"), a = e.split(/[+-]/), u = a[0], d = a[1];
        return i.test(u) && function(e, t, r) {
            return void 0 === r && (r = ":"), new RegExp(t ? "^(0(?!(2" + r + "4)|0" + r + "3)|1(?=([0-1]|2(?=" + r + "[04])|[34](?=" + r + "0))))([03469](?=" + r + "[03])|[17](?=" + r + "0)|2(?=" + r + "[04])|5(?=" + r + "[034])|8(?=" + r + "[04]))" + r + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r + "[03])|[0-24-8](?=" + r + "00))" + r + "[03]0$").test(e);
        }(d, o, n(d));
    }
    function o(e) {
        var t = e.split("T"), o = t[0], a = t[1], u = r(o, n(o));
        if (!a) return !1;
        var d, s = (d = a.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d) ? d[0] : "");
        return u && i(a, s, !0);
    }
    function a(e, t) {
        return void 0 === t && (t = "-"), new RegExp("^[0-9]{4}" + t + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e);
    }
    e.r(t), e.d(t, {
        isValidDate: ()=>r,
        isValidISODateString: ()=>o,
        isValidTime: ()=>i,
        isValidYearMonth: ()=>a
    });
    var u = exports;
    for(var d in t)u[d] = t[d];
    t.__esModule && Object.defineProperty(u, "__esModule", {
        value: !0
    });
})();
}}),
"[project]/node_modules/@atproto/xrpc/dist/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XRPCInvalidResponseError = exports.XRPCError = exports.XRPCResponse = exports.ResponseTypeStrings = exports.ResponseTypeNames = exports.ResponseType = exports.errorResponseBody = void 0;
exports.httpResponseCodeToEnum = httpResponseCodeToEnum;
exports.httpResponseCodeToName = httpResponseCodeToName;
exports.httpResponseCodeToString = httpResponseCodeToString;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-client] (ecmascript)");
exports.errorResponseBody = zod_1.z.object({
    error: zod_1.z.string().optional(),
    message: zod_1.z.string().optional()
});
var ResponseType;
(function(ResponseType) {
    ResponseType[ResponseType["Unknown"] = 1] = "Unknown";
    ResponseType[ResponseType["InvalidResponse"] = 2] = "InvalidResponse";
    ResponseType[ResponseType["Success"] = 200] = "Success";
    ResponseType[ResponseType["InvalidRequest"] = 400] = "InvalidRequest";
    ResponseType[ResponseType["AuthRequired"] = 401] = "AuthRequired";
    ResponseType[ResponseType["Forbidden"] = 403] = "Forbidden";
    ResponseType[ResponseType["XRPCNotSupported"] = 404] = "XRPCNotSupported";
    ResponseType[ResponseType["NotAcceptable"] = 406] = "NotAcceptable";
    ResponseType[ResponseType["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    ResponseType[ResponseType["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    ResponseType[ResponseType["RateLimitExceeded"] = 429] = "RateLimitExceeded";
    ResponseType[ResponseType["InternalServerError"] = 500] = "InternalServerError";
    ResponseType[ResponseType["MethodNotImplemented"] = 501] = "MethodNotImplemented";
    ResponseType[ResponseType["UpstreamFailure"] = 502] = "UpstreamFailure";
    ResponseType[ResponseType["NotEnoughResources"] = 503] = "NotEnoughResources";
    ResponseType[ResponseType["UpstreamTimeout"] = 504] = "UpstreamTimeout";
})(ResponseType || (exports.ResponseType = ResponseType = {}));
function httpResponseCodeToEnum(status) {
    if (status in ResponseType) {
        return status;
    } else if (status >= 100 && status < 200) {
        return ResponseType.XRPCNotSupported;
    } else if (status >= 200 && status < 300) {
        return ResponseType.Success;
    } else if (status >= 300 && status < 400) {
        return ResponseType.XRPCNotSupported;
    } else if (status >= 400 && status < 500) {
        return ResponseType.InvalidRequest;
    } else {
        return ResponseType.InternalServerError;
    }
}
exports.ResponseTypeNames = {
    [ResponseType.Unknown]: 'Unknown',
    [ResponseType.InvalidResponse]: 'InvalidResponse',
    [ResponseType.Success]: 'Success',
    [ResponseType.InvalidRequest]: 'InvalidRequest',
    [ResponseType.AuthRequired]: 'AuthenticationRequired',
    [ResponseType.Forbidden]: 'Forbidden',
    [ResponseType.XRPCNotSupported]: 'XRPCNotSupported',
    [ResponseType.PayloadTooLarge]: 'PayloadTooLarge',
    [ResponseType.UnsupportedMediaType]: 'UnsupportedMediaType',
    [ResponseType.RateLimitExceeded]: 'RateLimitExceeded',
    [ResponseType.InternalServerError]: 'InternalServerError',
    [ResponseType.MethodNotImplemented]: 'MethodNotImplemented',
    [ResponseType.UpstreamFailure]: 'UpstreamFailure',
    [ResponseType.NotEnoughResources]: 'NotEnoughResources',
    [ResponseType.UpstreamTimeout]: 'UpstreamTimeout'
};
function httpResponseCodeToName(status) {
    return exports.ResponseTypeNames[httpResponseCodeToEnum(status)];
}
exports.ResponseTypeStrings = {
    [ResponseType.Unknown]: 'Unknown',
    [ResponseType.InvalidResponse]: 'Invalid Response',
    [ResponseType.Success]: 'Success',
    [ResponseType.InvalidRequest]: 'Invalid Request',
    [ResponseType.AuthRequired]: 'Authentication Required',
    [ResponseType.Forbidden]: 'Forbidden',
    [ResponseType.XRPCNotSupported]: 'XRPC Not Supported',
    [ResponseType.PayloadTooLarge]: 'Payload Too Large',
    [ResponseType.UnsupportedMediaType]: 'Unsupported Media Type',
    [ResponseType.RateLimitExceeded]: 'Rate Limit Exceeded',
    [ResponseType.InternalServerError]: 'Internal Server Error',
    [ResponseType.MethodNotImplemented]: 'Method Not Implemented',
    [ResponseType.UpstreamFailure]: 'Upstream Failure',
    [ResponseType.NotEnoughResources]: 'Not Enough Resources',
    [ResponseType.UpstreamTimeout]: 'Upstream Timeout'
};
function httpResponseCodeToString(status) {
    return exports.ResponseTypeStrings[httpResponseCodeToEnum(status)];
}
class XRPCResponse {
    constructor(data, headers){
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: data
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
        });
        Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
    }
}
exports.XRPCResponse = XRPCResponse;
class XRPCError extends Error {
    constructor(statusCode, error = httpResponseCodeToName(statusCode), message, headers, options){
        super(message || error || httpResponseCodeToString(statusCode), options);
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: error
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
        });
        Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.status = httpResponseCodeToEnum(statusCode);
        // Pre 2022 runtimes won't handle the "options" constructor argument
        const cause = options?.cause;
        if (this.cause === undefined && cause !== undefined) {
            this.cause = cause;
        }
    }
    static from(cause, fallbackStatus) {
        if (cause instanceof XRPCError) {
            return cause;
        }
        // Type cast the cause to an Error if it is one
        const causeErr = cause instanceof Error ? cause : undefined;
        // Try and find a Response object in the cause
        const causeResponse = cause instanceof Response ? cause : cause?.['response'] instanceof Response ? cause['response'] : undefined;
        const statusCode = // Extract status code from "http-errors" like errors
        causeErr?.['statusCode'] ?? causeErr?.['status'] ?? // Use the status code from the response object as fallback
        causeResponse?.status;
        // Convert the status code to a ResponseType
        const status = typeof statusCode === 'number' ? httpResponseCodeToEnum(statusCode) : fallbackStatus ?? ResponseType.Unknown;
        const message = causeErr?.message ?? String(cause);
        const headers = causeResponse ? Object.fromEntries(causeResponse.headers.entries()) : undefined;
        return new XRPCError(status, undefined, message, headers, {
            cause
        });
    }
}
exports.XRPCError = XRPCError;
class XRPCInvalidResponseError extends XRPCError {
    constructor(lexiconNsid, validationError, responseBody){
        super(ResponseType.InvalidResponse, exports.ResponseTypeStrings[ResponseType.InvalidResponse], `The server gave an invalid response and may be out of date.`, undefined, {
            cause: validationError
        });
        Object.defineProperty(this, "lexiconNsid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lexiconNsid
        });
        Object.defineProperty(this, "validationError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: validationError
        });
        Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: responseBody
        });
    }
}
exports.XRPCInvalidResponseError = XRPCInvalidResponseError; //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isErrorResponseBody = isErrorResponseBody;
exports.getMethodSchemaHTTPMethod = getMethodSchemaHTTPMethod;
exports.constructMethodCallUri = constructMethodCallUri;
exports.constructMethodCallUrl = constructMethodCallUrl;
exports.encodeQueryParam = encodeQueryParam;
exports.constructMethodCallHeaders = constructMethodCallHeaders;
exports.combineHeaders = combineHeaders;
exports.isBodyInit = isBodyInit;
exports.isIterable = isIterable;
exports.encodeMethodCallBody = encodeMethodCallBody;
exports.httpResponseBodyParse = httpResponseBodyParse;
const lexicon_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/index.js [app-client] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/types.js [app-client] (ecmascript)");
const ReadableStream = globalThis.ReadableStream || class {
    constructor(){
        // This anonymous class will never pass any "instanceof" check and cannot
        // be instantiated.
        throw new Error('ReadableStream is not supported in this environment');
    }
};
function isErrorResponseBody(v) {
    return types_1.errorResponseBody.safeParse(v).success;
}
function getMethodSchemaHTTPMethod(schema) {
    if (schema.type === 'procedure') {
        return 'post';
    }
    return 'get';
}
function constructMethodCallUri(nsid, schema, serviceUri, params) {
    const uri = new URL(constructMethodCallUrl(nsid, schema, params), serviceUri);
    return uri.toString();
}
function constructMethodCallUrl(nsid, schema, params) {
    const pathname = `/xrpc/${encodeURIComponent(nsid)}`;
    if (!params) return pathname;
    const searchParams = [];
    for (const [key, value] of Object.entries(params)){
        const paramSchema = schema.parameters?.properties?.[key];
        if (!paramSchema) {
            throw new Error(`Invalid query parameter: ${key}`);
        }
        if (value !== undefined) {
            if (paramSchema.type === 'array') {
                const values = Array.isArray(value) ? value : [
                    value
                ];
                for (const val of values){
                    searchParams.push([
                        key,
                        encodeQueryParam(paramSchema.items.type, val)
                    ]);
                }
            } else {
                searchParams.push([
                    key,
                    encodeQueryParam(paramSchema.type, value)
                ]);
            }
        }
    }
    if (!searchParams.length) return pathname;
    return `${pathname}?${new URLSearchParams(searchParams).toString()}`;
}
function encodeQueryParam(type, value) {
    if (type === 'string' || type === 'unknown') {
        return String(value);
    }
    if (type === 'float') {
        return String(Number(value));
    } else if (type === 'integer') {
        return String(Number(value) | 0);
    } else if (type === 'boolean') {
        return value ? 'true' : 'false';
    } else if (type === 'datetime') {
        if (value instanceof Date) {
            return value.toISOString();
        }
        return String(value);
    }
    throw new Error(`Unsupported query param type: ${type}`);
}
function constructMethodCallHeaders(schema, data, opts) {
    // Not using `new Headers(opts?.headers)` to avoid duplicating headers values
    // due to inconsistent casing in headers name. In case of multiple headers
    // with the same name (but using a different case), the last one will be used.
    // new Headers({ 'content-type': 'foo', 'Content-Type': 'bar' }).get('content-type')
    // => 'foo, bar'
    const headers = new Headers();
    if (opts?.headers) {
        for(const name in opts.headers){
            if (headers.has(name)) {
                throw new TypeError(`Duplicate header: ${name}`);
            }
            const value = opts.headers[name];
            if (value != null) {
                headers.set(name, value);
            }
        }
    }
    if (schema.type === 'procedure') {
        if (opts?.encoding) {
            headers.set('content-type', opts.encoding);
        } else if (!headers.has('content-type') && typeof data !== 'undefined') {
            // Special handling of BodyInit types before falling back to JSON encoding
            if (data instanceof ArrayBuffer || data instanceof ReadableStream || ArrayBuffer.isView(data)) {
                headers.set('content-type', 'application/octet-stream');
            } else if (data instanceof FormData) {
                // Note: The multipart form data boundary is missing from the header
                // we set here, making that header invalid. This special case will be
                // handled in encodeMethodCallBody()
                headers.set('content-type', 'multipart/form-data');
            } else if (data instanceof URLSearchParams) {
                headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            } else if (isBlobLike(data)) {
                headers.set('content-type', data.type || 'application/octet-stream');
            } else if (typeof data === 'string') {
                headers.set('content-type', 'text/plain;charset=UTF-8');
            } else if (isIterable(data)) {
                headers.set('content-type', 'application/octet-stream');
            } else if (typeof data === 'boolean' || typeof data === 'number' || typeof data === 'string' || typeof data === 'object' // covers "null"
            ) {
                headers.set('content-type', 'application/json');
            } else {
                // symbol, function, bigint
                throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unsupported data type: ${typeof data}`);
            }
        }
    }
    return headers;
}
function combineHeaders(headersInit, defaultHeaders) {
    if (!defaultHeaders) return headersInit;
    let headers = undefined;
    for (const [name, definition] of defaultHeaders){
        // Ignore undefined values (allowed for convenience when using
        // Object.entries).
        if (definition === undefined) continue;
        // Lazy initialization of the headers object
        headers ?? (headers = new Headers(headersInit));
        if (headers.has(name)) continue;
        const value = typeof definition === 'function' ? definition() : definition;
        if (typeof value === 'string') headers.set(name, value);
        else if (value === null) headers.delete(name);
        else throw new TypeError(`Invalid "${name}" header value: ${typeof value}`);
    }
    return headers ?? headersInit;
}
function isBlobLike(value) {
    if (value == null) return false;
    if (typeof value !== 'object') return false;
    if (typeof Blob === 'function' && value instanceof Blob) return true;
    // Support for Blobs provided by libraries that don't use the native Blob
    // (e.g. fetch-blob from node-fetch).
    // https://github.com/node-fetch/fetch-blob/blob/a1a182e5978811407bef4ea1632b517567dda01f/index.js#L233-L244
    const tag = value[Symbol.toStringTag];
    if (tag === 'Blob' || tag === 'File') {
        return 'stream' in value && typeof value.stream === 'function';
    }
    return false;
}
function isBodyInit(value) {
    switch(typeof value){
        case 'string':
            return true;
        case 'object':
            return value instanceof ArrayBuffer || value instanceof FormData || value instanceof URLSearchParams || value instanceof ReadableStream || ArrayBuffer.isView(value) || isBlobLike(value);
        default:
            return false;
    }
}
function isIterable(value) {
    return value != null && typeof value === 'object' && (Symbol.iterator in value || Symbol.asyncIterator in value);
}
function encodeMethodCallBody(headers, data) {
    // Silently ignore the body if there is no content-type header.
    const contentType = headers.get('content-type');
    if (!contentType) {
        return undefined;
    }
    if (typeof data === 'undefined') {
        // This error would be returned by the server, but we can catch it earlier
        // to avoid un-necessary requests. Note that a content-length of 0 does not
        // necessary mean that the body is "empty" (e.g. an empty txt file).
        throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `A request body is expected but none was provided`);
    }
    if (isBodyInit(data)) {
        if (data instanceof FormData && contentType === 'multipart/form-data') {
            // fetch() will encode FormData payload itself, but it won't override the
            // content-type header if already present. This would cause the boundary
            // to be missing from the content-type header, resulting in a 400 error.
            // Deleting the content-type header here to let fetch() re-create it.
            headers.delete('content-type');
        }
        // Will be encoded by the fetch API.
        return data;
    }
    if (isIterable(data)) {
        // Note that some environments support using Iterable & AsyncIterable as the
        // body (e.g. Node's fetch), but not all of them do (browsers).
        return iterableToReadableStream(data);
    }
    if (contentType.startsWith('text/')) {
        return new TextEncoder().encode(String(data));
    }
    if (contentType.startsWith('application/json')) {
        const json = (0, lexicon_1.stringifyLex)(data);
        // Server would return a 400 error if the JSON is invalid (e.g. trying to
        // JSONify a function, or an object that implements toJSON() poorly).
        if (json === undefined) {
            throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Failed to encode request body as JSON`);
        }
        return new TextEncoder().encode(json);
    }
    // At this point, "data" is not a valid BodyInit value, and we don't know how
    // to encode it into one. Passing it to fetch would result in an error. Let's
    // throw our own error instead.
    const type = !data || typeof data !== 'object' ? typeof data : data.constructor !== Object && typeof data.constructor === 'function' && typeof data.constructor?.name === 'string' ? data.constructor.name : 'object';
    throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unable to encode ${type} as ${contentType} data`);
}
/**
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/from_static}
 */ function iterableToReadableStream(iterable) {
    // Use the native ReadableStream.from() if available.
    if ('from' in ReadableStream && typeof ReadableStream.from === 'function') {
        return ReadableStream.from(iterable);
    }
    // If you see this error, consider using a polyfill for ReadableStream. For
    // example, the "web-streams-polyfill" package:
    // https://github.com/MattiasBuelens/web-streams-polyfill
    throw new TypeError('ReadableStream.from() is not supported in this environment. ' + 'It is required to support using iterables as the request body. ' + 'Consider using a polyfill or re-write your code to use a different body type.');
}
function httpResponseBodyParse(mimeType, data) {
    try {
        if (mimeType) {
            if (mimeType.includes('application/json')) {
                const str = new TextDecoder().decode(data);
                return (0, lexicon_1.jsonStringToLex)(str);
            }
            if (mimeType.startsWith('text/')) {
                return new TextDecoder().decode(data);
            }
        }
        if (data instanceof ArrayBuffer) {
            return new Uint8Array(data);
        }
        return data;
    } catch (cause) {
        throw new types_1.XRPCError(types_1.ResponseType.InvalidResponse, undefined, `Failed to parse response body: ${String(cause)}`, undefined, {
            cause
        });
    }
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/fetch-handler.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildFetchHandler = buildFetchHandler;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-client] (ecmascript)");
function buildFetchHandler(options) {
    // Already a fetch handler (allowed for convenience)
    if (typeof options === 'function') return options;
    if (typeof options === 'object' && 'fetchHandler' in options) {
        return options.fetchHandler.bind(options);
    }
    const { service, headers: defaultHeaders = undefined, fetch = globalThis.fetch } = typeof options === 'string' || options instanceof URL ? {
        service: options
    } : options;
    if (typeof fetch !== 'function') {
        throw new TypeError('XrpcDispatcher requires fetch() to be available in your environment.');
    }
    const defaultHeadersEntries = defaultHeaders != null ? Object.entries(defaultHeaders) : undefined;
    return async function(url, init) {
        const base = typeof service === 'function' ? service() : service;
        const fullUrl = new URL(url, base);
        const headers = (0, util_1.combineHeaders)(init.headers, defaultHeadersEntries);
        return fetch(fullUrl, {
            ...init,
            headers
        });
    };
} //# sourceMappingURL=fetch-handler.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/xrpc-client.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XrpcClient = void 0;
const lexicon_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/index.js [app-client] (ecmascript)");
const fetch_handler_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/fetch-handler.js [app-client] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/types.js [app-client] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-client] (ecmascript)");
class XrpcClient {
    constructor(fetchHandlerOpts, // "Lexicons" is redundant here (because that class implements
    // "Iterable<LexiconDoc>") but we keep it for explicitness:
    lex){
        Object.defineProperty(this, "fetchHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "lex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetchHandler = (0, fetch_handler_1.buildFetchHandler)(fetchHandlerOpts);
        this.lex = lex instanceof lexicon_1.Lexicons ? lex : new lexicon_1.Lexicons(lex);
    }
    setHeader(key, value) {
        this.headers.set(key.toLowerCase(), value);
    }
    unsetHeader(key) {
        this.headers.delete(key.toLowerCase());
    }
    clearHeaders() {
        this.headers.clear();
    }
    async call(methodNsid, params, data, opts) {
        const def = this.lex.getDefOrThrow(methodNsid);
        if (!def || def.type !== 'query' && def.type !== 'procedure') {
            throw new TypeError(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
        }
        // @TODO: should we validate the params and data here?
        // this.lex.assertValidXrpcParams(methodNsid, params)
        // if (data !== undefined) {
        //   this.lex.assertValidXrpcInput(methodNsid, data)
        // }
        const reqUrl = (0, util_1.constructMethodCallUrl)(methodNsid, def, params);
        const reqMethod = (0, util_1.getMethodSchemaHTTPMethod)(def);
        const reqHeaders = (0, util_1.constructMethodCallHeaders)(def, data, opts);
        const reqBody = (0, util_1.encodeMethodCallBody)(reqHeaders, data);
        // The duplex field is required for streaming bodies, but not yet reflected
        // anywhere in docs or types. See whatwg/fetch#1438, nodejs/node#46221.
        const init = {
            method: reqMethod,
            headers: (0, util_1.combineHeaders)(reqHeaders, this.headers),
            body: reqBody,
            duplex: 'half',
            signal: opts?.signal
        };
        try {
            const response = await this.fetchHandler.call(undefined, reqUrl, init);
            const resStatus = response.status;
            const resHeaders = Object.fromEntries(response.headers.entries());
            const resBodyBytes = await response.arrayBuffer();
            const resBody = (0, util_1.httpResponseBodyParse)(response.headers.get('content-type'), resBodyBytes);
            const resCode = (0, types_1.httpResponseCodeToEnum)(resStatus);
            if (resCode !== types_1.ResponseType.Success) {
                const { error = undefined, message = undefined } = resBody && (0, util_1.isErrorResponseBody)(resBody) ? resBody : {};
                throw new types_1.XRPCError(resCode, error, message, resHeaders);
            }
            try {
                this.lex.assertValidXrpcOutput(methodNsid, resBody);
            } catch (e) {
                if (e instanceof lexicon_1.ValidationError) {
                    throw new types_1.XRPCInvalidResponseError(methodNsid, e, resBody);
                }
                throw e;
            }
            return new types_1.XRPCResponse(resBody, resHeaders);
        } catch (err) {
            throw types_1.XRPCError.from(err);
        }
    }
}
exports.XrpcClient = XrpcClient; //# sourceMappingURL=xrpc-client.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/client.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceClient = exports.Client = void 0;
const lexicon_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/index.js [app-client] (ecmascript)");
const xrpc_client_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/xrpc-client.js [app-client] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-client] (ecmascript)");
/** @deprecated Use {@link XrpcClient} instead */ class Client {
    constructor(){
        Object.defineProperty(this, "lex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new lexicon_1.Lexicons()
        });
    }
    /** @deprecated */ get fetch() {
        throw new Error('Client.fetch is no longer supported. Use an XrpcClient instead.');
    }
    /** @deprecated */ set fetch(_) {
        throw new Error('Client.fetch is no longer supported. Use an XrpcClient instead.');
    }
    // method calls
    //
    async call(serviceUri, methodNsid, params, data, opts) {
        return this.service(serviceUri).call(methodNsid, params, data, opts);
    }
    service(serviceUri) {
        return new ServiceClient(this, serviceUri);
    }
    // schemas
    // =
    addLexicon(doc) {
        this.lex.add(doc);
    }
    addLexicons(docs) {
        for (const doc of docs){
            this.addLexicon(doc);
        }
    }
    removeLexicon(uri) {
        this.lex.remove(uri);
    }
}
exports.Client = Client;
/** @deprecated Use {@link XrpcClient} instead */ class ServiceClient extends xrpc_client_1.XrpcClient {
    constructor(baseClient, serviceUri){
        super(async (input, init)=>{
            const headers = (0, util_1.combineHeaders)(init.headers, Object.entries(this.headers));
            return fetch(new URL(input, this.uri), {
                ...init,
                headers
            });
        }, baseClient.lex);
        Object.defineProperty(this, "baseClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: baseClient
        });
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.uri = typeof serviceUri === 'string' ? new URL(serviceUri) : serviceUri;
    }
}
exports.ServiceClient = ServiceClient; //# sourceMappingURL=client.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/client.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/fetch-handler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/types.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/xrpc-client.js [app-client] (ecmascript)"), exports);
const client_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/client.js [app-client] (ecmascript)");
/** @deprecated create a local {@link XrpcClient} instance instead */ const defaultInst = new client_1.Client();
exports.default = defaultInst; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/tlds/index.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("[\"aaa\",\"aarp\",\"abb\",\"abbott\",\"abbvie\",\"abc\",\"able\",\"abogado\",\"abudhabi\",\"ac\",\"academy\",\"accenture\",\"accountant\",\"accountants\",\"aco\",\"actor\",\"ad\",\"ads\",\"adult\",\"ae\",\"aeg\",\"aero\",\"aetna\",\"af\",\"afl\",\"africa\",\"ag\",\"agakhan\",\"agency\",\"ai\",\"aig\",\"airbus\",\"airforce\",\"airtel\",\"akdn\",\"al\",\"alibaba\",\"alipay\",\"allfinanz\",\"allstate\",\"ally\",\"alsace\",\"alstom\",\"am\",\"amazon\",\"americanexpress\",\"americanfamily\",\"amex\",\"amfam\",\"amica\",\"amsterdam\",\"analytics\",\"android\",\"anquan\",\"anz\",\"ao\",\"aol\",\"apartments\",\"app\",\"apple\",\"aq\",\"aquarelle\",\"ar\",\"arab\",\"aramco\",\"archi\",\"army\",\"arpa\",\"art\",\"arte\",\"as\",\"asda\",\"asia\",\"associates\",\"at\",\"athleta\",\"attorney\",\"au\",\"auction\",\"audi\",\"audible\",\"audio\",\"auspost\",\"author\",\"auto\",\"autos\",\"aw\",\"aws\",\"ax\",\"axa\",\"az\",\"azure\",\"ba\",\"baby\",\"baidu\",\"banamex\",\"band\",\"bank\",\"bar\",\"barcelona\",\"barclaycard\",\"barclays\",\"barefoot\",\"bargains\",\"baseball\",\"basketball\",\"bauhaus\",\"bayern\",\"bb\",\"bbc\",\"bbt\",\"bbva\",\"bcg\",\"bcn\",\"bd\",\"be\",\"beats\",\"beauty\",\"beer\",\"bentley\",\"berlin\",\"best\",\"bestbuy\",\"bet\",\"bf\",\"bg\",\"bh\",\"bharti\",\"bi\",\"bible\",\"bid\",\"bike\",\"bing\",\"bingo\",\"bio\",\"biz\",\"bj\",\"black\",\"blackfriday\",\"blockbuster\",\"blog\",\"bloomberg\",\"blue\",\"bm\",\"bms\",\"bmw\",\"bn\",\"bnpparibas\",\"bo\",\"boats\",\"boehringer\",\"bofa\",\"bom\",\"bond\",\"boo\",\"book\",\"booking\",\"bosch\",\"bostik\",\"boston\",\"bot\",\"boutique\",\"box\",\"br\",\"bradesco\",\"bridgestone\",\"broadway\",\"broker\",\"brother\",\"brussels\",\"bs\",\"bt\",\"build\",\"builders\",\"business\",\"buy\",\"buzz\",\"bv\",\"bw\",\"by\",\"bz\",\"bzh\",\"ca\",\"cab\",\"cafe\",\"cal\",\"call\",\"calvinklein\",\"cam\",\"camera\",\"camp\",\"canon\",\"capetown\",\"capital\",\"capitalone\",\"car\",\"caravan\",\"cards\",\"care\",\"career\",\"careers\",\"cars\",\"casa\",\"case\",\"cash\",\"casino\",\"cat\",\"catering\",\"catholic\",\"cba\",\"cbn\",\"cbre\",\"cc\",\"cd\",\"center\",\"ceo\",\"cern\",\"cf\",\"cfa\",\"cfd\",\"cg\",\"ch\",\"chanel\",\"channel\",\"charity\",\"chase\",\"chat\",\"cheap\",\"chintai\",\"christmas\",\"chrome\",\"church\",\"ci\",\"cipriani\",\"circle\",\"cisco\",\"citadel\",\"citi\",\"citic\",\"city\",\"ck\",\"cl\",\"claims\",\"cleaning\",\"click\",\"clinic\",\"clinique\",\"clothing\",\"cloud\",\"club\",\"clubmed\",\"cm\",\"cn\",\"co\",\"coach\",\"codes\",\"coffee\",\"college\",\"cologne\",\"com\",\"commbank\",\"community\",\"company\",\"compare\",\"computer\",\"comsec\",\"condos\",\"construction\",\"consulting\",\"contact\",\"contractors\",\"cooking\",\"cool\",\"coop\",\"corsica\",\"country\",\"coupon\",\"coupons\",\"courses\",\"cpa\",\"cr\",\"credit\",\"creditcard\",\"creditunion\",\"cricket\",\"crown\",\"crs\",\"cruise\",\"cruises\",\"cu\",\"cuisinella\",\"cv\",\"cw\",\"cx\",\"cy\",\"cymru\",\"cyou\",\"cz\",\"dad\",\"dance\",\"data\",\"date\",\"dating\",\"datsun\",\"day\",\"dclk\",\"dds\",\"de\",\"deal\",\"dealer\",\"deals\",\"degree\",\"delivery\",\"dell\",\"deloitte\",\"delta\",\"democrat\",\"dental\",\"dentist\",\"desi\",\"design\",\"dev\",\"dhl\",\"diamonds\",\"diet\",\"digital\",\"direct\",\"directory\",\"discount\",\"discover\",\"dish\",\"diy\",\"dj\",\"dk\",\"dm\",\"dnp\",\"do\",\"docs\",\"doctor\",\"dog\",\"domains\",\"dot\",\"download\",\"drive\",\"dtv\",\"dubai\",\"dunlop\",\"dupont\",\"durban\",\"dvag\",\"dvr\",\"dz\",\"earth\",\"eat\",\"ec\",\"eco\",\"edeka\",\"edu\",\"education\",\"ee\",\"eg\",\"email\",\"emerck\",\"energy\",\"engineer\",\"engineering\",\"enterprises\",\"epson\",\"equipment\",\"er\",\"ericsson\",\"erni\",\"es\",\"esq\",\"estate\",\"et\",\"eu\",\"eurovision\",\"eus\",\"events\",\"exchange\",\"expert\",\"exposed\",\"express\",\"extraspace\",\"fage\",\"fail\",\"fairwinds\",\"faith\",\"family\",\"fan\",\"fans\",\"farm\",\"farmers\",\"fashion\",\"fast\",\"fedex\",\"feedback\",\"ferrari\",\"ferrero\",\"fi\",\"fidelity\",\"fido\",\"film\",\"final\",\"finance\",\"financial\",\"fire\",\"firestone\",\"firmdale\",\"fish\",\"fishing\",\"fit\",\"fitness\",\"fj\",\"fk\",\"flickr\",\"flights\",\"flir\",\"florist\",\"flowers\",\"fly\",\"fm\",\"fo\",\"foo\",\"food\",\"football\",\"ford\",\"forex\",\"forsale\",\"forum\",\"foundation\",\"fox\",\"fr\",\"free\",\"fresenius\",\"frl\",\"frogans\",\"frontier\",\"ftr\",\"fujitsu\",\"fun\",\"fund\",\"furniture\",\"futbol\",\"fyi\",\"ga\",\"gal\",\"gallery\",\"gallo\",\"gallup\",\"game\",\"games\",\"gap\",\"garden\",\"gay\",\"gb\",\"gbiz\",\"gd\",\"gdn\",\"ge\",\"gea\",\"gent\",\"genting\",\"george\",\"gf\",\"gg\",\"ggee\",\"gh\",\"gi\",\"gift\",\"gifts\",\"gives\",\"giving\",\"gl\",\"glass\",\"gle\",\"global\",\"globo\",\"gm\",\"gmail\",\"gmbh\",\"gmo\",\"gmx\",\"gn\",\"godaddy\",\"gold\",\"goldpoint\",\"golf\",\"goo\",\"goodyear\",\"goog\",\"google\",\"gop\",\"got\",\"gov\",\"gp\",\"gq\",\"gr\",\"grainger\",\"graphics\",\"gratis\",\"green\",\"gripe\",\"grocery\",\"group\",\"gs\",\"gt\",\"gu\",\"gucci\",\"guge\",\"guide\",\"guitars\",\"guru\",\"gw\",\"gy\",\"hair\",\"hamburg\",\"hangout\",\"haus\",\"hbo\",\"hdfc\",\"hdfcbank\",\"health\",\"healthcare\",\"help\",\"helsinki\",\"here\",\"hermes\",\"hiphop\",\"hisamitsu\",\"hitachi\",\"hiv\",\"hk\",\"hkt\",\"hm\",\"hn\",\"hockey\",\"holdings\",\"holiday\",\"homedepot\",\"homegoods\",\"homes\",\"homesense\",\"honda\",\"horse\",\"hospital\",\"host\",\"hosting\",\"hot\",\"hotels\",\"hotmail\",\"house\",\"how\",\"hr\",\"hsbc\",\"ht\",\"hu\",\"hughes\",\"hyatt\",\"hyundai\",\"ibm\",\"icbc\",\"ice\",\"icu\",\"id\",\"ie\",\"ieee\",\"ifm\",\"ikano\",\"il\",\"im\",\"imamat\",\"imdb\",\"immo\",\"immobilien\",\"in\",\"inc\",\"industries\",\"infiniti\",\"info\",\"ing\",\"ink\",\"institute\",\"insurance\",\"insure\",\"int\",\"international\",\"intuit\",\"investments\",\"io\",\"ipiranga\",\"iq\",\"ir\",\"irish\",\"is\",\"ismaili\",\"ist\",\"istanbul\",\"it\",\"itau\",\"itv\",\"jaguar\",\"java\",\"jcb\",\"je\",\"jeep\",\"jetzt\",\"jewelry\",\"jio\",\"jll\",\"jm\",\"jmp\",\"jnj\",\"jo\",\"jobs\",\"joburg\",\"jot\",\"joy\",\"jp\",\"jpmorgan\",\"jprs\",\"juegos\",\"juniper\",\"kaufen\",\"kddi\",\"ke\",\"kerryhotels\",\"kerrylogistics\",\"kerryproperties\",\"kfh\",\"kg\",\"kh\",\"ki\",\"kia\",\"kids\",\"kim\",\"kindle\",\"kitchen\",\"kiwi\",\"km\",\"kn\",\"koeln\",\"komatsu\",\"kosher\",\"kp\",\"kpmg\",\"kpn\",\"kr\",\"krd\",\"kred\",\"kuokgroup\",\"kw\",\"ky\",\"kyoto\",\"kz\",\"la\",\"lacaixa\",\"lamborghini\",\"lamer\",\"lancaster\",\"land\",\"landrover\",\"lanxess\",\"lasalle\",\"lat\",\"latino\",\"latrobe\",\"law\",\"lawyer\",\"lb\",\"lc\",\"lds\",\"lease\",\"leclerc\",\"lefrak\",\"legal\",\"lego\",\"lexus\",\"lgbt\",\"li\",\"lidl\",\"life\",\"lifeinsurance\",\"lifestyle\",\"lighting\",\"like\",\"lilly\",\"limited\",\"limo\",\"lincoln\",\"link\",\"lipsy\",\"live\",\"living\",\"lk\",\"llc\",\"llp\",\"loan\",\"loans\",\"locker\",\"locus\",\"lol\",\"london\",\"lotte\",\"lotto\",\"love\",\"lpl\",\"lplfinancial\",\"lr\",\"ls\",\"lt\",\"ltd\",\"ltda\",\"lu\",\"lundbeck\",\"luxe\",\"luxury\",\"lv\",\"ly\",\"ma\",\"madrid\",\"maif\",\"maison\",\"makeup\",\"man\",\"management\",\"mango\",\"map\",\"market\",\"marketing\",\"markets\",\"marriott\",\"marshalls\",\"mattel\",\"mba\",\"mc\",\"mckinsey\",\"md\",\"me\",\"med\",\"media\",\"meet\",\"melbourne\",\"meme\",\"memorial\",\"men\",\"menu\",\"merckmsd\",\"mg\",\"mh\",\"miami\",\"microsoft\",\"mil\",\"mini\",\"mint\",\"mit\",\"mitsubishi\",\"mk\",\"ml\",\"mlb\",\"mls\",\"mm\",\"mma\",\"mn\",\"mo\",\"mobi\",\"mobile\",\"moda\",\"moe\",\"moi\",\"mom\",\"monash\",\"money\",\"monster\",\"mormon\",\"mortgage\",\"moscow\",\"moto\",\"motorcycles\",\"mov\",\"movie\",\"mp\",\"mq\",\"mr\",\"ms\",\"msd\",\"mt\",\"mtn\",\"mtr\",\"mu\",\"museum\",\"music\",\"mv\",\"mw\",\"mx\",\"my\",\"mz\",\"na\",\"nab\",\"nagoya\",\"name\",\"navy\",\"nba\",\"nc\",\"ne\",\"nec\",\"net\",\"netbank\",\"netflix\",\"network\",\"neustar\",\"new\",\"news\",\"next\",\"nextdirect\",\"nexus\",\"nf\",\"nfl\",\"ng\",\"ngo\",\"nhk\",\"ni\",\"nico\",\"nike\",\"nikon\",\"ninja\",\"nissan\",\"nissay\",\"nl\",\"no\",\"nokia\",\"norton\",\"now\",\"nowruz\",\"nowtv\",\"np\",\"nr\",\"nra\",\"nrw\",\"ntt\",\"nu\",\"nyc\",\"nz\",\"obi\",\"observer\",\"office\",\"okinawa\",\"olayan\",\"olayangroup\",\"ollo\",\"om\",\"omega\",\"one\",\"ong\",\"onl\",\"online\",\"ooo\",\"open\",\"oracle\",\"orange\",\"org\",\"organic\",\"origins\",\"osaka\",\"otsuka\",\"ott\",\"ovh\",\"pa\",\"page\",\"panasonic\",\"paris\",\"pars\",\"partners\",\"parts\",\"party\",\"pay\",\"pccw\",\"pe\",\"pet\",\"pf\",\"pfizer\",\"pg\",\"ph\",\"pharmacy\",\"phd\",\"philips\",\"phone\",\"photo\",\"photography\",\"photos\",\"physio\",\"pics\",\"pictet\",\"pictures\",\"pid\",\"pin\",\"ping\",\"pink\",\"pioneer\",\"pizza\",\"pk\",\"pl\",\"place\",\"play\",\"playstation\",\"plumbing\",\"plus\",\"pm\",\"pn\",\"pnc\",\"pohl\",\"poker\",\"politie\",\"porn\",\"post\",\"pr\",\"pramerica\",\"praxi\",\"press\",\"prime\",\"pro\",\"prod\",\"productions\",\"prof\",\"progressive\",\"promo\",\"properties\",\"property\",\"protection\",\"pru\",\"prudential\",\"ps\",\"pt\",\"pub\",\"pw\",\"pwc\",\"py\",\"qa\",\"qpon\",\"quebec\",\"quest\",\"racing\",\"radio\",\"re\",\"read\",\"realestate\",\"realtor\",\"realty\",\"recipes\",\"red\",\"redstone\",\"redumbrella\",\"rehab\",\"reise\",\"reisen\",\"reit\",\"reliance\",\"ren\",\"rent\",\"rentals\",\"repair\",\"report\",\"republican\",\"rest\",\"restaurant\",\"review\",\"reviews\",\"rexroth\",\"rich\",\"richardli\",\"ricoh\",\"ril\",\"rio\",\"rip\",\"ro\",\"rocks\",\"rodeo\",\"rogers\",\"room\",\"rs\",\"rsvp\",\"ru\",\"rugby\",\"ruhr\",\"run\",\"rw\",\"rwe\",\"ryukyu\",\"sa\",\"saarland\",\"safe\",\"safety\",\"sakura\",\"sale\",\"salon\",\"samsclub\",\"samsung\",\"sandvik\",\"sandvikcoromant\",\"sanofi\",\"sap\",\"sarl\",\"sas\",\"save\",\"saxo\",\"sb\",\"sbi\",\"sbs\",\"sc\",\"scb\",\"schaeffler\",\"schmidt\",\"scholarships\",\"school\",\"schule\",\"schwarz\",\"science\",\"scot\",\"sd\",\"se\",\"search\",\"seat\",\"secure\",\"security\",\"seek\",\"select\",\"sener\",\"services\",\"seven\",\"sew\",\"sex\",\"sexy\",\"sfr\",\"sg\",\"sh\",\"shangrila\",\"sharp\",\"shell\",\"shia\",\"shiksha\",\"shoes\",\"shop\",\"shopping\",\"shouji\",\"show\",\"si\",\"silk\",\"sina\",\"singles\",\"site\",\"sj\",\"sk\",\"ski\",\"skin\",\"sky\",\"skype\",\"sl\",\"sling\",\"sm\",\"smart\",\"smile\",\"sn\",\"sncf\",\"so\",\"soccer\",\"social\",\"softbank\",\"software\",\"sohu\",\"solar\",\"solutions\",\"song\",\"sony\",\"soy\",\"spa\",\"space\",\"sport\",\"spot\",\"sr\",\"srl\",\"ss\",\"st\",\"stada\",\"staples\",\"star\",\"statebank\",\"statefarm\",\"stc\",\"stcgroup\",\"stockholm\",\"storage\",\"store\",\"stream\",\"studio\",\"study\",\"style\",\"su\",\"sucks\",\"supplies\",\"supply\",\"support\",\"surf\",\"surgery\",\"suzuki\",\"sv\",\"swatch\",\"swiss\",\"sx\",\"sy\",\"sydney\",\"systems\",\"sz\",\"tab\",\"taipei\",\"talk\",\"taobao\",\"target\",\"tatamotors\",\"tatar\",\"tattoo\",\"tax\",\"taxi\",\"tc\",\"tci\",\"td\",\"tdk\",\"team\",\"tech\",\"technology\",\"tel\",\"temasek\",\"tennis\",\"teva\",\"tf\",\"tg\",\"th\",\"thd\",\"theater\",\"theatre\",\"tiaa\",\"tickets\",\"tienda\",\"tips\",\"tires\",\"tirol\",\"tj\",\"tjmaxx\",\"tjx\",\"tk\",\"tkmaxx\",\"tl\",\"tm\",\"tmall\",\"tn\",\"to\",\"today\",\"tokyo\",\"tools\",\"top\",\"toray\",\"toshiba\",\"total\",\"tours\",\"town\",\"toyota\",\"toys\",\"tr\",\"trade\",\"trading\",\"training\",\"travel\",\"travelers\",\"travelersinsurance\",\"trust\",\"trv\",\"tt\",\"tube\",\"tui\",\"tunes\",\"tushu\",\"tv\",\"tvs\",\"tw\",\"tz\",\"ua\",\"ubank\",\"ubs\",\"ug\",\"uk\",\"unicom\",\"university\",\"uno\",\"uol\",\"ups\",\"us\",\"uy\",\"uz\",\"va\",\"vacations\",\"vana\",\"vanguard\",\"vc\",\"ve\",\"vegas\",\"ventures\",\"verisign\",\"vermgensberater\",\"vermgensberatung\",\"versicherung\",\"vet\",\"vg\",\"vi\",\"viajes\",\"video\",\"vig\",\"viking\",\"villas\",\"vin\",\"vip\",\"virgin\",\"visa\",\"vision\",\"viva\",\"vivo\",\"vlaanderen\",\"vn\",\"vodka\",\"volvo\",\"vote\",\"voting\",\"voto\",\"voyage\",\"vu\",\"wales\",\"walmart\",\"walter\",\"wang\",\"wanggou\",\"watch\",\"watches\",\"weather\",\"weatherchannel\",\"webcam\",\"weber\",\"website\",\"wed\",\"wedding\",\"weibo\",\"weir\",\"wf\",\"whoswho\",\"wien\",\"wiki\",\"williamhill\",\"win\",\"windows\",\"wine\",\"winners\",\"wme\",\"wolterskluwer\",\"woodside\",\"work\",\"works\",\"world\",\"wow\",\"ws\",\"wtc\",\"wtf\",\"xbox\",\"xerox\",\"xihuan\",\"xin\",\"xxx\",\"xyz\",\"yachts\",\"yahoo\",\"yamaxun\",\"yandex\",\"ye\",\"yodobashi\",\"yoga\",\"yokohama\",\"you\",\"youtube\",\"yt\",\"yun\",\"za\",\"zappos\",\"zara\",\"zero\",\"zip\",\"zm\",\"zone\",\"zuerich\",\"zw\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]"));}}),
"[project]/node_modules/await-lock/build/AwaitLock.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AwaitLock_acquired, _AwaitLock_waitingResolvers;
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * A mutex lock for coordination across async functions
 */ class AwaitLock {
    constructor(){
        _AwaitLock_acquired.set(this, false);
        _AwaitLock_waitingResolvers.set(this, new Set());
    }
    /**
     * Whether the lock is currently acquired or not. Accessing this property does not affect the
     * status of the lock.
     */ get acquired() {
        return __classPrivateFieldGet(this, _AwaitLock_acquired, "f");
    }
    /**
     * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
     * returned promise is fulfilled once the lock is acquired.
     *
     * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
     * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
     * timeout values depends on how `setTimeout` handles those values.
     *
     * After acquiring the lock, you **must** call `release` when you are done with it.
     */ acquireAsync({ timeout } = {}) {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
            __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
            return Promise.resolve();
        }
        if (timeout == null) {
            return new Promise((resolve)=>{
                __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolve);
            });
        }
        let resolver;
        let timer;
        return Promise.race([
            new Promise((resolve)=>{
                resolver = ()=>{
                    clearTimeout(timer);
                    resolve();
                };
                __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolver);
            }),
            new Promise((_, reject)=>{
                timer = setTimeout(()=>{
                    __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolver);
                    reject(new Error(`Timed out waiting for lock`));
                }, timeout);
            })
        ]);
    }
    /**
     * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
     * `true` if the lock was free and is now acquired, and `false` otherwise.
     *
     * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
     * synchronously without waiting for the JavaScript task queue.
     */ tryAcquire() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
            __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
            return true;
        }
        return false;
    }
    /**
     * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
     * must release the lock exactly once.
     */ release() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
            throw new Error(`Cannot release an unacquired lock`);
        }
        if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").size > 0) {
            // Sets preserve insertion order like a queue
            const [resolve] = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f");
            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolve);
            resolve();
        } else {
            __classPrivateFieldSet(this, _AwaitLock_acquired, false, "f");
        }
    }
}
exports.default = AwaitLock;
_AwaitLock_acquired = new WeakMap(), _AwaitLock_waitingResolvers = new WeakMap(); //# sourceMappingURL=AwaitLock.js.map
}}),
}]);

//# sourceMappingURL=node_modules_b429b3._.js.map