module.exports = {

"[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            module.exports = __turbopack_require__("[externals]/next/dist/compiled/next-server/app-page.runtime.dev.js [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)");
        } else {
            "TURBOPACK unreachable";
        }
    }
} //# sourceMappingURL=module.compiled.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
module.exports = __turbopack_require__("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
module.exports = __turbopack_require__("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/disposable-polyfill/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code compiled with tsc supports "using" and "await using" syntax. This
// features is supported by downleveling the code to ES2017. The downleveling
// relies on `Symbol.dispose` and `Symbol.asyncDispose` symbols. These symbols
// might not be available in all environments. This package provides a polyfill
// for these symbols.
// @ts-expect-error
Symbol.dispose ?? (Symbol.dispose = Symbol('@@dispose'));
// @ts-expect-error
Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol('@@asyncDispose')); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/zod/lib/helpers/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
var util;
(function(util) {
    util.assertEqual = (val)=>val;
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items)=>{
        const obj = {};
        for (const item of items){
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj)=>{
        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys){
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj)=>{
        return util.objectKeys(obj).map(function(e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban
     : (object)=>{
        const keys = [];
        for(const key in object){
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    util.find = (arr, checker)=>{
        for (const item of arr){
            if (checker(item)) return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban
     : (val)=>typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val)=>typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value)=>{
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (exports.util = util = {}));
var objectUtil;
(function(objectUtil) {
    objectUtil.mergeShapes = (first, second)=>{
        return {
            ...first,
            ...second
        };
    };
})(objectUtil || (exports.objectUtil = objectUtil = {}));
exports.ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]);
const getParsedType = (data)=>{
    const t = typeof data;
    switch(t){
        case "undefined":
            return exports.ZodParsedType.undefined;
        case "string":
            return exports.ZodParsedType.string;
        case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
            return exports.ZodParsedType.boolean;
        case "function":
            return exports.ZodParsedType.function;
        case "bigint":
            return exports.ZodParsedType.bigint;
        case "symbol":
            return exports.ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return exports.ZodParsedType.array;
            }
            if (data === null) {
                return exports.ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
        default:
            return exports.ZodParsedType.unknown;
    }
};
exports.getParsedType = getParsedType;
}}),
"[project]/node_modules/zod/lib/ZodError.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
const util_1 = __turbopack_require__("[project]/node_modules/zod/lib/helpers/util.js [app-ssr] (ecmascript)");
exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
const quotelessJson = (obj)=>{
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
exports.quotelessJson = quotelessJson;
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues){
        super();
        this.issues = [];
        this.addIssue = (sub)=>{
            this.issues = [
                ...this.issues,
                sub
            ];
        };
        this.addIssues = (subs = [])=>{
            this.issues = [
                ...this.issues,
                ...subs
            ];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        } else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper || function(issue) {
            return issue.message;
        };
        const fieldErrors = {
            _errors: []
        };
        const processError = (error)=>{
            for (const issue of error.issues){
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                } else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                } else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                } else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                } else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                        // if (typeof el === "string") {
                        //   curr[el] = curr[el] || { _errors: [] };
                        // } else if (typeof el === "number") {
                        //   const errorArray: any = [];
                        //   errorArray._errors = [];
                        //   curr[el] = curr[el] || errorArray;
                        // }
                        } else {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue)=>issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues){
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
                formErrors.push(mapper(sub));
            }
        }
        return {
            formErrors,
            fieldErrors
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
exports.ZodError = ZodError;
ZodError.create = (issues)=>{
    const error = new ZodError(issues);
    return error;
};
}}),
"[project]/node_modules/zod/lib/locales/en.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const util_1 = __turbopack_require__("[project]/node_modules/zod/lib/helpers/util.js [app-ssr] (ecmascript)");
const ZodError_1 = __turbopack_require__("[project]/node_modules/zod/lib/ZodError.js [app-ssr] (ecmascript)");
const errorMap = (issue, _ctx)=>{
    let message;
    switch(issue.code){
        case ZodError_1.ZodIssueCode.invalid_type:
            if (issue.received === util_1.ZodParsedType.undefined) {
                message = "Required";
            } else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                } else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                } else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                } else {
                    util_1.util.assertNever(issue.validation);
                }
            } else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            } else {
                message = "Invalid";
            }
            break;
        case ZodError_1.ZodIssueCode.too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1.util.assertNever(issue);
    }
    return {
        message
    };
};
exports.default = errorMap;
}}),
"[project]/node_modules/zod/lib/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
const en_1 = __importDefault(__turbopack_require__("[project]/node_modules/zod/lib/locales/en.js [app-ssr] (ecmascript)"));
exports.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(map) {
    overrideErrorMap = map;
}
exports.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap;
}
exports.getErrorMap = getErrorMap;
}}),
"[project]/node_modules/zod/lib/helpers/parseUtil.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
const errors_1 = __turbopack_require__("[project]/node_modules/zod/lib/errors.js [app-ssr] (ecmascript)");
const en_1 = __importDefault(__turbopack_require__("[project]/node_modules/zod/lib/locales/en.js [app-ssr] (ecmascript)"));
const makeIssue = (params)=>{
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
        ...path,
        ...issueData.path || []
    ];
    const fullIssue = {
        ...issueData,
        path: fullPath
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message
        };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m)=>!!m).slice().reverse();
    for (const map of maps){
        errorMessage = map(fullIssue, {
            data,
            defaultError: errorMessage
        }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage
    };
};
exports.makeIssue = makeIssue;
exports.EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = (0, errors_1.getErrorMap)();
    const issue = (0, exports.makeIssue)({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === en_1.default ? undefined : en_1.default
        ].filter((x)=>!!x)
    });
    ctx.common.issues.push(issue);
}
exports.addIssueToContext = addIssueToContext;
class ParseStatus {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results){
            if (s.status === "aborted") return exports.INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return {
            status: status.value,
            value: arrayValue
        };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs){
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs){
            const { key, value } = pair;
            if (key.status === "aborted") return exports.INVALID;
            if (value.status === "aborted") return exports.INVALID;
            if (key.status === "dirty") status.dirty();
            if (value.status === "dirty") status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return {
            status: status.value,
            value: finalObject
        };
    }
}
exports.ParseStatus = ParseStatus;
exports.INVALID = Object.freeze({
    status: "aborted"
});
const DIRTY = (value)=>({
        status: "dirty",
        value
    });
exports.DIRTY = DIRTY;
const OK = (value)=>({
        status: "valid",
        value
    });
exports.OK = OK;
const isAborted = (x)=>x.status === "aborted";
exports.isAborted = isAborted;
const isDirty = (x)=>x.status === "dirty";
exports.isDirty = isDirty;
const isValid = (x)=>x.status === "valid";
exports.isValid = isValid;
const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;
exports.isAsync = isAsync;
}}),
"[project]/node_modules/zod/lib/helpers/typeAliases.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
}}),
"[project]/node_modules/zod/lib/helpers/errorUtil.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.errorUtil = void 0;
var errorUtil;
(function(errorUtil) {
    errorUtil.errToObj = (message)=>typeof message === "string" ? {
            message
        } : message || {};
    errorUtil.toString = (message)=>typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (exports.errorUtil = errorUtil = {}));
}}),
"[project]/node_modules/zod/lib/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ZodEnum_cache, _ZodNativeEnum_cache;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.datetimeRegex = exports.ZodType = void 0;
exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = exports.date = void 0;
const errors_1 = __turbopack_require__("[project]/node_modules/zod/lib/errors.js [app-ssr] (ecmascript)");
const errorUtil_1 = __turbopack_require__("[project]/node_modules/zod/lib/helpers/errorUtil.js [app-ssr] (ecmascript)");
const parseUtil_1 = __turbopack_require__("[project]/node_modules/zod/lib/helpers/parseUtil.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/zod/lib/helpers/util.js [app-ssr] (ecmascript)");
const ZodError_1 = __turbopack_require__("[project]/node_modules/zod/lib/ZodError.js [app-ssr] (ecmascript)");
class ParseInputLazyPath {
    constructor(parent, value, path, key){
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            } else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result)=>{
    if ((0, parseUtil_1.isValid)(result)) {
        return {
            success: true,
            data: result.value
        };
    } else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new ZodError_1.ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap) return {
        errorMap: errorMap,
        description
    };
    const customMap = (iss, ctx)=>{
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return {
                message: message !== null && message !== void 0 ? message : ctx.defaultError
            };
        }
        if (typeof ctx.data === "undefined") {
            return {
                message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError
            };
        }
        if (iss.code !== "invalid_type") return {
            message: ctx.defaultError
        };
        return {
            message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError
        };
    };
    return {
        errorMap: customMap,
        description
    };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
        };
    }
    _processInputParams(input) {
        return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, util_1.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            }
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({
            data,
            path: ctx.path,
            parent: ctx
        });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        var _a, _b;
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data)
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({
                    data,
                    path: [],
                    parent: ctx
                });
                return (0, parseUtil_1.isValid)(result) ? {
                    value: result.value
                } : {
                    issues: ctx.common.issues
                };
            } catch (err) {
                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true
                };
            }
        }
        return this._parseAsync({
            data,
            path: [],
            parent: ctx
        }).then((result)=>(0, parseUtil_1.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val)=>{
            if (typeof message === "string" || typeof message === "undefined") {
                return {
                    message
                };
            } else if (typeof message === "function") {
                return message(val);
            } else {
                return message;
            }
        };
        return this._refinement((val, ctx)=>{
            const result = check(val);
            const setError = ()=>ctx.addIssue({
                    code: ZodError_1.ZodIssueCode.custom,
                    ...getIssueProperties(val)
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data)=>{
                    if (!data) {
                        setError();
                        return false;
                    } else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            } else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx)=>{
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            } else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement
            }
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def){
        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data)=>this["~validate"](data)
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([
            this,
            option
        ], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform
            }
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
exports.ZodType = ZodType;
exports.Schema = ZodType;
exports.ZodSchema = ZodType;
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
exports.datetimeRegex = datetimeRegex;
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt)) return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null) return false;
        if (!decoded.typ || !decoded.alg) return false;
        if (alg && decoded.alg !== alg) return false;
        return true;
    } catch (_a) {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.string,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                    } else if (tooSmall) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                    }
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "email",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "nanoid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") {
                try {
                    new URL(input.data);
                } catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") {
                input.data = input.data.trim();
            } else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "duration",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "jwt",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cidr",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "base64",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "base64url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _regex(regex, validation, message) {
        return this.refinement((data)=>regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    email(message) {
        return this._addCheck({
            kind: "email",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    url(message) {
        return this._addCheck({
            kind: "url",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    emoji(message) {
        return this._addCheck({
            kind: "emoji",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    uuid(message) {
        return this._addCheck({
            kind: "uuid",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    nanoid(message) {
        return this._addCheck({
            kind: "nanoid",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    cuid(message) {
        return this._addCheck({
            kind: "cuid",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    cuid2(message) {
        return this._addCheck({
            kind: "cuid2",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    ulid(message) {
        return this._addCheck({
            kind: "ulid",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    base64(message) {
        return this._addCheck({
            kind: "base64",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    jwt(options) {
        return this._addCheck({
            kind: "jwt",
            ...errorUtil_1.errorUtil.errToObj(options)
        });
    }
    ip(options) {
        return this._addCheck({
            kind: "ip",
            ...errorUtil_1.errorUtil.errToObj(options)
        });
    }
    cidr(options) {
        return this._addCheck({
            kind: "cidr",
            ...errorUtil_1.errorUtil.errToObj(options)
        });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
    }
    date(message) {
        return this._addCheck({
            kind: "date",
            message
        });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
    }
    duration(message) {
        return this._addCheck({
            kind: "duration",
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message)
        });
    }
    /**
     * Equivalent to `.min(1)`
     */ nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch)=>ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch)=>ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch)=>ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch)=>ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch)=>ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch)=>ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch)=>ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch)=>ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch)=>ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch)=>ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch)=>ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch)=>ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch)=>ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodString = ZodString;
ZodString.create = (params)=>{
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.number,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks){
            if (check.kind === "int") {
                if (!util_1.util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message)
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            } else if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            } else if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
exports.ZodNumber = ZodNumber;
ZodNumber.create = (params)=>{
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
    });
};
class ZodBigInt extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            } catch (_a) {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks){
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodBigInt = ZodBigInt;
ZodBigInt.create = (params)=>{
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.boolean,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodBoolean = ZodBoolean;
ZodBoolean.create = (params)=>{
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.date,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_date
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime())
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message)
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
exports.ZodDate = ZodDate;
ZodDate.create = (params)=>{
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.symbol,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodSymbol = ZodSymbol;
ZodSymbol.create = (params)=>{
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.undefined,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUndefined = ZodUndefined;
ZodUndefined.create = (params)=>{
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.null,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodNull = ZodNull;
ZodNull.create = (params)=>{
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
    });
};
class ZodAny extends ZodType {
    constructor(){
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodAny = ZodAny;
ZodAny.create = (params)=>{
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
    });
};
class ZodUnknown extends ZodType {
    constructor(){
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUnknown = ZodUnknown;
ZodUnknown.create = (params)=>{
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.never,
            received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
    }
}
exports.ZodNever = ZodNever;
ZodNever.create = (params)=>{
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.void,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodVoid = ZodVoid;
ZodVoid.create = (params)=>{
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                    minimum: tooSmall ? def.exactLength.value : undefined,
                    maximum: tooBig ? def.exactLength.value : undefined,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([
                ...ctx.data
            ].map((item, i)=>{
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result)=>{
                return parseUtil_1.ParseStatus.mergeArray(status, result);
            });
        }
        const result = [
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: minLength,
                message: errorUtil_1.errorUtil.toString(message)
            }
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: maxLength,
                message: errorUtil_1.errorUtil.toString(message)
            }
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: len,
                message: errorUtil_1.errorUtil.toString(message)
            }
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodArray = ZodArray;
ZodArray.create = (schema, params)=>{
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for(const key in schema.shape){
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: ()=>newShape
        });
    } else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element)
        });
    } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
    } else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor(){
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */ this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */ this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return this._cached = {
            shape,
            keys
        };
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for(const key in ctx.data){
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys){
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys){
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: {
                            status: "valid",
                            value: ctx.data[key]
                        }
                    });
                }
            } else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
                        keys: extraKeys
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip") {} else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        } else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys){
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve().then(async ()=>{
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet
                    });
                }
                return syncPairs;
            }).then((syncPairs)=>{
                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
        } else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== undefined ? {
                errorMap: (issue, ctx)=>{
                    var _a, _b, _c, _d;
                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                    if (issue.code === "unrecognized_keys") return {
                        message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                    };
                    return {
                        message: defaultError
                    };
                }
            } : {}
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...augmentation
                })
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */ merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...merging._def.shape()
                }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({
            [key]: schema
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index
        });
    }
    pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key)=>{
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key)=>{
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    /**
     * @deprecated
     */ deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key)=>{
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            } else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key)=>{
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            } else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while(newField instanceof ZodOptional){
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
    }
}
exports.ZodObject = ZodObject;
ZodObject.create = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.strictCreate = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.lazycreate = (shape, params)=>{
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results){
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results){
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result)=>new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option)=>{
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx
                    }),
                    ctx: childCtx
                };
            })).then(handleResults);
        } else {
            let dirty = undefined;
            const issues = [];
            for (const option of options){
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                });
                if (result.status === "valid") {
                    return result;
                } else if (result.status === "dirty" && !dirty) {
                    dirty = {
                        result,
                        ctx: childCtx
                    };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues)=>new ZodError_1.ZodError(issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors
            });
            return parseUtil_1.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
exports.ZodUnion = ZodUnion;
ZodUnion.create = (types, params)=>{
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type)=>{
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
        return [
            type.value
        ];
    } else if (type instanceof ZodEnum) {
        return type.options;
    } else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util_1.util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
        return [
            undefined
        ];
    } else if (type instanceof ZodNull) {
        return [
            null
        ];
    } else if (type instanceof ZodOptional) {
        return [
            undefined,
            ...getDiscriminator(type.unwrap())
        ];
    } else if (type instanceof ZodNullable) {
        return [
            null,
            ...getDiscriminator(type.unwrap())
        ];
    } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    } else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [
                    discriminator
                ]
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        } else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */ static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options){
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues){
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
        });
    }
}
exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
function mergeValues(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
        return {
            valid: true,
            data: a
        };
    } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
        const newObj = {
            ...a,
            ...b
        };
        for (const key of sharedKeys){
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return {
                    valid: false
                };
            }
            newObj[key] = sharedValue.data;
        }
        return {
            valid: true,
            data: newObj
        };
    } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
            return {
                valid: false
            };
        }
        const newArray = [];
        for(let index = 0; index < a.length; index++){
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return {
                    valid: false
                };
            }
            newArray.push(sharedValue.data);
        }
        return {
            valid: true,
            data: newArray
        };
    } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return {
            valid: true,
            data: a
        };
    } else {
        return {
            valid: false
        };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight)=>{
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
                return parseUtil_1.INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.invalid_intersection_types
                });
                return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
                status.dirty();
            }
            return {
                status: status.value,
                value: merged.data
            };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                })
            ]).then(([left, right])=>handleParsed(left, right));
        } else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }));
        }
    }
}
exports.ZodIntersection = ZodIntersection;
ZodIntersection.create = (left, right, params)=>{
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            status.dirty();
        }
        const items = [
            ...ctx.data
        ].map((item, itemIndex)=>{
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema) return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x)=>!!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results)=>{
                return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
        } else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest
        });
    }
}
exports.ZodTuple = ZodTuple;
ZodTuple.create = (schemas, params)=>{
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for(const key in ctx.data){
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third)
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
        });
    }
}
exports.ZodRecord = ZodRecord;
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.map,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [
            ...ctx.data.entries()
        ].map(([key, value], index)=>{
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                    index,
                    "key"
                ])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                    index,
                    "value"
                ]))
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async ()=>{
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return parseUtil_1.INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            });
        } else {
            const finalMap = new Map();
            for (const pair of pairs){
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return {
                status: status.value,
                value: finalMap
            };
        }
    }
}
exports.ZodMap = ZodMap;
ZodMap.create = (keyType, valueType, params)=>{
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.set,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements){
                if (element.status === "aborted") return parseUtil_1.INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return {
                status: status.value,
                value: parsedSet
            };
        }
        const elements = [
            ...ctx.data.values()
        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements)=>finalizeSet(elements));
        } else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: minSize,
                message: errorUtil_1.errorUtil.toString(message)
            }
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: maxSize,
                message: errorUtil_1.errorUtil.toString(message)
            }
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodSet = ZodSet;
ZodSet.create = (valueType, params)=>{
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
    });
};
class ZodFunction extends ZodType {
    constructor(){
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.function,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap
                ].filter((x)=>!!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_arguments,
                    argumentsError: error
                }
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap
                ].filter((x)=>!!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_return_type,
                    returnTypeError: error
                }
            });
        }
        const params = {
            errorMap: ctx.common.contextualErrorMap
        };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(async function(...args) {
                const error = new ZodError_1.ZodError([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(function(...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError_1.ZodError([
                        makeArgsIssue(args, parsedArgs.error)
                    ]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError_1.ZodError([
                        makeReturnsIssue(result, parsedReturns.error)
                    ]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
        });
    }
}
exports.ZodFunction = ZodFunction;
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
}
exports.ZodLazy = ZodLazy;
ZodLazy.create = (getter, params)=>{
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_literal,
                expected: this._def.value
            });
            return parseUtil_1.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    get value() {
        return this._def.value;
    }
}
exports.ZodLiteral = ZodLiteral;
ZodLiteral.create = (value, params)=>{
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
    });
}
class ZodEnum extends ZodType {
    constructor(){
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type
            });
            return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values){
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values){
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values){
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
            ...this._def,
            ...newDef
        });
    }
}
exports.ZodEnum = ZodEnum;
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor(){
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type
            });
            return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
exports.ZodNativeEnum = ZodNativeEnum;
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params)=>{
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.promise,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data)=>{
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap
            });
        }));
    }
}
exports.ZodPromise = ZodPromise;
ZodPromise.create = (schema, params)=>{
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg)=>{
                (0, parseUtil_1.addIssueToContext)(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                } else {
                    status.dirty();
                }
            },
            get path () {
                return ctx.path;
            }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed)=>{
                    if (status.value === "aborted") return parseUtil_1.INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (result.status === "aborted") return parseUtil_1.INVALID;
                    if (result.status === "dirty") return (0, parseUtil_1.DIRTY)(result.value);
                    if (status.value === "dirty") return (0, parseUtil_1.DIRTY)(result.value);
                    return result;
                });
            } else {
                if (status.value === "aborted") return parseUtil_1.INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return parseUtil_1.INVALID;
                if (result.status === "dirty") return (0, parseUtil_1.DIRTY)(result.value);
                if (status.value === "dirty") return (0, parseUtil_1.DIRTY)(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc)=>{
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inner.status === "aborted") return parseUtil_1.INVALID;
                if (inner.status === "dirty") status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return {
                    status: status.value,
                    value: inner.value
                };
            } else {
                return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((inner)=>{
                    if (inner.status === "aborted") return parseUtil_1.INVALID;
                    if (inner.status === "dirty") status.dirty();
                    return executeRefinement(inner.value).then(()=>{
                        return {
                            status: status.value,
                            value: inner.value
                        };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!(0, parseUtil_1.isValid)(base)) return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return {
                    status: status.value,
                    value: result
                };
            } else {
                return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((base)=>{
                    if (!(0, parseUtil_1.isValid)(base)) return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                            status: status.value,
                            value: result
                        }));
                });
            }
        }
        util_1.util.assertNever(effect);
    }
}
exports.ZodEffects = ZodEffects;
exports.ZodTransformer = ZodEffects;
ZodEffects.create = (schema, effect, params)=>{
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params)=>{
    return new ZodEffects({
        schema,
        effect: {
            type: "preprocess",
            transform: preprocess
        },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodOptional = ZodOptional;
ZodOptional.create = (type, params)=>{
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodNullable = ZodNullable;
ZodNullable.create = (type, params)=>{
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
exports.ZodDefault = ZodDefault;
ZodDefault.create = (type, params)=>{
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
        ...processCreateParams(params)
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: []
            }
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx
            }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result)=>{
                return {
                    status: "valid",
                    value: result.status === "valid" ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError_1.ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            });
        } else {
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue({
                    get error () {
                        return new ZodError_1.ZodError(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
exports.ZodCatch = ZodCatch;
ZodCatch.create = (type, params)=>{
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
        ...processCreateParams(params)
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.nan,
                received: ctx.parsedType
            });
            return parseUtil_1.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
}
exports.ZodNaN = ZodNaN;
ZodNaN.create = (params)=>{
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
    });
};
exports.BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
exports.ZodBranded = ZodBranded;
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async ()=>{
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return parseUtil_1.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, parseUtil_1.DIRTY)(inResult.value);
                } else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                }
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            if (inResult.status === "aborted") return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            } else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
    }
}
exports.ZodPipeline = ZodPipeline;
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data)=>{
            if ((0, parseUtil_1.isValid)(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return (0, parseUtil_1.isAsync)(result) ? result.then((data)=>freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodReadonly = ZodReadonly;
ZodReadonly.create = (type, params)=>{
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
    });
};
function custom(check, params = {}, /**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */ fatal) {
    if (check) return ZodAny.create().superRefine((data, ctx)=>{
        var _a, _b;
        if (!check(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? {
                message: params
            } : params;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? {
                message: p
            } : p;
            ctx.addIssue({
                code: "custom",
                ...p2,
                fatal: _fatal
            });
        }
    });
    return ZodAny.create();
}
exports.custom = custom;
exports.late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
// requires TS 4.4+
class Class {
    constructor(..._){}
}
const instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`
})=>custom((data)=>data instanceof cls, params);
exports.instanceof = instanceOfType;
const stringType = ZodString.create;
exports.string = stringType;
const numberType = ZodNumber.create;
exports.number = numberType;
const nanType = ZodNaN.create;
exports.nan = nanType;
const bigIntType = ZodBigInt.create;
exports.bigint = bigIntType;
const booleanType = ZodBoolean.create;
exports.boolean = booleanType;
const dateType = ZodDate.create;
exports.date = dateType;
const symbolType = ZodSymbol.create;
exports.symbol = symbolType;
const undefinedType = ZodUndefined.create;
exports.undefined = undefinedType;
const nullType = ZodNull.create;
exports.null = nullType;
const anyType = ZodAny.create;
exports.any = anyType;
const unknownType = ZodUnknown.create;
exports.unknown = unknownType;
const neverType = ZodNever.create;
exports.never = neverType;
const voidType = ZodVoid.create;
exports.void = voidType;
const arrayType = ZodArray.create;
exports.array = arrayType;
const objectType = ZodObject.create;
exports.object = objectType;
const strictObjectType = ZodObject.strictCreate;
exports.strictObject = strictObjectType;
const unionType = ZodUnion.create;
exports.union = unionType;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
exports.discriminatedUnion = discriminatedUnionType;
const intersectionType = ZodIntersection.create;
exports.intersection = intersectionType;
const tupleType = ZodTuple.create;
exports.tuple = tupleType;
const recordType = ZodRecord.create;
exports.record = recordType;
const mapType = ZodMap.create;
exports.map = mapType;
const setType = ZodSet.create;
exports.set = setType;
const functionType = ZodFunction.create;
exports.function = functionType;
const lazyType = ZodLazy.create;
exports.lazy = lazyType;
const literalType = ZodLiteral.create;
exports.literal = literalType;
const enumType = ZodEnum.create;
exports.enum = enumType;
const nativeEnumType = ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
const promiseType = ZodPromise.create;
exports.promise = promiseType;
const effectsType = ZodEffects.create;
exports.effect = effectsType;
exports.transformer = effectsType;
const optionalType = ZodOptional.create;
exports.optional = optionalType;
const nullableType = ZodNullable.create;
exports.nullable = nullableType;
const preprocessType = ZodEffects.createWithPreprocess;
exports.preprocess = preprocessType;
const pipelineType = ZodPipeline.create;
exports.pipeline = pipelineType;
const ostring = ()=>stringType().optional();
exports.ostring = ostring;
const onumber = ()=>numberType().optional();
exports.onumber = onumber;
const oboolean = ()=>booleanType().optional();
exports.oboolean = oboolean;
exports.coerce = {
    string: (arg)=>ZodString.create({
            ...arg,
            coerce: true
        }),
    number: (arg)=>ZodNumber.create({
            ...arg,
            coerce: true
        }),
    boolean: (arg)=>ZodBoolean.create({
            ...arg,
            coerce: true
        }),
    bigint: (arg)=>ZodBigInt.create({
            ...arg,
            coerce: true
        }),
    date: (arg)=>ZodDate.create({
            ...arg,
            coerce: true
        })
};
exports.NEVER = parseUtil_1.INVALID;
}}),
"[project]/node_modules/zod/lib/external.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/errors.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/helpers/parseUtil.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/helpers/typeAliases.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/helpers/util.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/ZodError.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.z = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/external.js [app-ssr] (ecmascript)"));
exports.z = z;
__exportStar(__turbopack_require__("[project]/node_modules/zod/lib/external.js [app-ssr] (ecmascript)"), exports);
exports.default = z;
}}),
"[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JwtVerifyError = exports.JwtCreateError = exports.JwkError = exports.ERR_JWT_VERIFY = exports.ERR_JWT_CREATE = exports.ERR_JWT_INVALID = exports.ERR_JWK_NOT_FOUND = exports.ERR_JWK_INVALID = exports.ERR_JWKS_NO_MATCHING_KEY = void 0;
exports.ERR_JWKS_NO_MATCHING_KEY = 'ERR_JWKS_NO_MATCHING_KEY';
exports.ERR_JWK_INVALID = 'ERR_JWK_INVALID';
exports.ERR_JWK_NOT_FOUND = 'ERR_JWK_NOT_FOUND';
exports.ERR_JWT_INVALID = 'ERR_JWT_INVALID';
exports.ERR_JWT_CREATE = 'ERR_JWT_CREATE';
exports.ERR_JWT_VERIFY = 'ERR_JWT_VERIFY';
class JwkError extends TypeError {
    constructor(message = 'JWK error', code = exports.ERR_JWK_INVALID, options){
        super(message, options);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
}
exports.JwkError = JwkError;
class JwtCreateError extends Error {
    constructor(message = 'Unable to create JWT', code = exports.ERR_JWT_CREATE, options){
        super(message, options);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
    static from(cause, code, message) {
        if (cause instanceof JwtCreateError) return cause;
        if (cause instanceof JwkError) {
            return new JwtCreateError(message, cause.code, {
                cause
            });
        }
        return new JwtCreateError(message, code, {
            cause
        });
    }
}
exports.JwtCreateError = JwtCreateError;
class JwtVerifyError extends Error {
    constructor(message = 'Invalid JWT', code = exports.ERR_JWT_VERIFY, options){
        super(message, options);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
    static from(cause, code, message) {
        if (cause instanceof JwtVerifyError) return cause;
        if (cause instanceof JwkError) {
            return new JwtVerifyError(message, cause.code, {
                cause
            });
        }
        return new JwtVerifyError(message, code, {
            cause
        });
    }
}
exports.JwtVerifyError = JwtVerifyError; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/alg.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwkAlgorithms = jwkAlgorithms;
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
// Copy variable to prevent bundlers from automatically polyfilling "process" (e.g. parcel)
const { process } = globalThis;
const IS_NODE_RUNTIME = typeof process !== 'undefined' && typeof process?.versions?.node === 'string';
function* jwkAlgorithms(jwk) {
    // Ed25519, Ed448, and secp256k1 always have "alg"
    // OKP always has "use"
    if (jwk.alg) {
        yield jwk.alg;
        return;
    }
    switch(jwk.kty){
        case 'EC':
            {
                if (jwk.use === 'enc' || jwk.use === undefined) {
                    yield 'ECDH-ES';
                    yield 'ECDH-ES+A128KW';
                    yield 'ECDH-ES+A192KW';
                    yield 'ECDH-ES+A256KW';
                }
                if (jwk.use === 'sig' || jwk.use === undefined) {
                    const crv = 'crv' in jwk ? jwk.crv : undefined;
                    switch(crv){
                        case 'P-256':
                        case 'P-384':
                            yield `ES${crv.slice(-3)}`;
                            break;
                        case 'P-521':
                            yield 'ES512';
                            break;
                        case 'secp256k1':
                            if (IS_NODE_RUNTIME) yield 'ES256K';
                            break;
                        default:
                            throw new errors_js_1.JwkError(`Unsupported crv "${crv}"`);
                    }
                }
                return;
            }
        case 'OKP':
            {
                if (!jwk.use) throw new errors_js_1.JwkError('Missing "use" Parameter value');
                yield 'ECDH-ES';
                yield 'ECDH-ES+A128KW';
                yield 'ECDH-ES+A192KW';
                yield 'ECDH-ES+A256KW';
                return;
            }
        case 'RSA':
            {
                if (jwk.use === 'enc' || jwk.use === undefined) {
                    yield 'RSA-OAEP';
                    yield 'RSA-OAEP-256';
                    yield 'RSA-OAEP-384';
                    yield 'RSA-OAEP-512';
                    if (IS_NODE_RUNTIME) yield 'RSA1_5';
                }
                if (jwk.use === 'sig' || jwk.use === undefined) {
                    yield 'PS256';
                    yield 'PS384';
                    yield 'PS512';
                    yield 'RS256';
                    yield 'RS384';
                    yield 'RS512';
                }
                return;
            }
        case 'oct':
            {
                if (jwk.use === 'enc' || jwk.use === undefined) {
                    yield 'A128GCMKW';
                    yield 'A192GCMKW';
                    yield 'A256GCMKW';
                    yield 'A128KW';
                    yield 'A192KW';
                    yield 'A256KW';
                }
                if (jwk.use === 'sig' || jwk.use === undefined) {
                    yield 'HS256';
                    yield 'HS384';
                    yield 'HS512';
                }
                return;
            }
        default:
            throw new errors_js_1.JwkError(`Unsupported kty "${jwk.kty}"`);
    }
} //# sourceMappingURL=alg.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwkPubSchema = exports.jwkValidator = exports.jwkSchema = exports.jwkUnknownKeySchema = exports.jwkSymKeySchema = exports.jwkOkpKeySchema = exports.jwkEcSecp256k1KeySchema = exports.jwkEcKeySchema = exports.jwkRsaKeySchema = exports.jwkBaseSchema = exports.keyUsageSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.keyUsageSchema = zod_1.z.enum([
    'sign',
    'verify',
    'encrypt',
    'decrypt',
    'wrapKey',
    'unwrapKey',
    'deriveKey',
    'deriveBits'
]);
/**
 * The "use" and "key_ops" JWK members SHOULD NOT be used together;
 * however, if both are used, the information they convey MUST be
 * consistent.  Applications should specify which of these members they
 * use, if either is to be used by the application.
 *
 * @todo Actually check that "use" and "key_ops" are consistent when both are present.
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7517#section-4.3}
 */ exports.jwkBaseSchema = zod_1.z.object({
    kty: zod_1.z.string().min(1),
    alg: zod_1.z.string().min(1).optional(),
    kid: zod_1.z.string().min(1).optional(),
    ext: zod_1.z.boolean().optional(),
    use: zod_1.z.enum([
        'sig',
        'enc'
    ]).optional(),
    key_ops: zod_1.z.array(exports.keyUsageSchema).optional(),
    x5c: zod_1.z.array(zod_1.z.string()).optional(),
    x5t: zod_1.z.string().min(1).optional(),
    'x5t#S256': zod_1.z.string().min(1).optional(),
    x5u: zod_1.z.string().url().optional()
});
/**
 * @todo: properly implement this
 */ exports.jwkRsaKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('RSA'),
    alg: zod_1.z.enum([
        'RS256',
        'RS384',
        'RS512',
        'PS256',
        'PS384',
        'PS512'
    ]).optional(),
    n: zod_1.z.string().min(1),
    e: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional(),
    p: zod_1.z.string().min(1).optional(),
    q: zod_1.z.string().min(1).optional(),
    dp: zod_1.z.string().min(1).optional(),
    dq: zod_1.z.string().min(1).optional(),
    qi: zod_1.z.string().min(1).optional(),
    oth: zod_1.z.array(zod_1.z.object({
        r: zod_1.z.string().optional(),
        d: zod_1.z.string().optional(),
        t: zod_1.z.string().optional()
    })).nonempty().optional()
});
exports.jwkEcKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('EC'),
    alg: zod_1.z.enum([
        'ES256',
        'ES384',
        'ES512'
    ]).optional(),
    crv: zod_1.z.enum([
        'P-256',
        'P-384',
        'P-521'
    ]),
    x: zod_1.z.string().min(1),
    y: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional()
});
exports.jwkEcSecp256k1KeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('EC'),
    alg: zod_1.z.enum([
        'ES256K'
    ]).optional(),
    crv: zod_1.z.enum([
        'secp256k1'
    ]),
    x: zod_1.z.string().min(1),
    y: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional()
});
exports.jwkOkpKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('OKP'),
    alg: zod_1.z.enum([
        'EdDSA'
    ]).optional(),
    crv: zod_1.z.enum([
        'Ed25519',
        'Ed448'
    ]),
    x: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional()
});
exports.jwkSymKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('oct'),
    alg: zod_1.z.enum([
        'HS256',
        'HS384',
        'HS512'
    ]).optional(),
    k: zod_1.z.string()
});
exports.jwkUnknownKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.string().refine((v)=>v !== 'RSA' && v !== 'EC' && v !== 'OKP' && v !== 'oct')
});
exports.jwkSchema = zod_1.z.union([
    exports.jwkUnknownKeySchema,
    exports.jwkRsaKeySchema,
    exports.jwkEcKeySchema,
    exports.jwkEcSecp256k1KeySchema,
    exports.jwkOkpKeySchema,
    exports.jwkSymKeySchema
]);
exports.jwkValidator = exports.jwkSchema.refine((k)=>k.use != null || k.key_ops != null, 'use or key_ops required').refine((k)=>!k.use || !k.key_ops || k.key_ops.every((o)=>k.use === 'sig' ? o === 'sign' || o === 'verify' : o === 'encrypt' || o === 'decrypt'), 'use and key_ops must be consistent');
exports.jwkPubSchema = exports.jwkValidator.refine((k)=>k.kid != null, 'kid is required').refine((k)=>!('k' in k) && !('d' in k), 'private key not allowed'); //# sourceMappingURL=jwk.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwks.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwksPubSchema = exports.jwksSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const jwk_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)");
exports.jwksSchema = zod_1.z.object({
    keys: zod_1.z.array(jwk_js_1.jwkSchema)
});
exports.jwksPubSchema = zod_1.z.object({
    keys: zod_1.z.array(jwk_js_1.jwkPubSchema)
}); //# sourceMappingURL=jwks.js.map
}}),
"[project]/node_modules/multiformats/cjs/vendor/base-x.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while(pbegin !== pend){
            var carry = source[pbegin];
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === ' ') {
            return;
        }
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while(source[psz]){
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        if (source[psz] === ' ') {
            return;
        }
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
module.exports = _brrp__multiformats_scope_baseX;
}}),
"[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
const empty = new Uint8Array(0);
const toHex = (d)=>d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, '0'), '');
const fromHex = (hex)=>{
    const hexes = hex.match(/../g);
    return hexes ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
};
const equals = (aa, bb)=>{
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
};
const coerce = (o)=>{
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
};
const isBinary = (o)=>o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString = (str)=>new TextEncoder().encode(str);
const toString = (b)=>new TextDecoder().decode(b);
exports.coerce = coerce;
exports.empty = empty;
exports.equals = equals;
exports.fromHex = fromHex;
exports.fromString = fromString;
exports.isBinary = isBinary;
exports.toHex = toHex;
exports.toString = toString;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var baseX$1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/vendor/base-x.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
class Encoder {
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
class Decoder {
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        } else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
            return decoder.decode(input);
        } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
const or = (left, right)=>new ComposedDecoder({
        ...left.decoders || {
            [left.prefix]: left
        },
        ...right.decoders || {
            [right.prefix]: right
        }
    });
class Codec {
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
const from = ({ name, prefix, encode, decode })=>new Codec(name, prefix, encode, decode);
const baseX = ({ prefix, name, alphabet })=>{
    const { encode, decode } = baseX$1(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>bytes.coerce(decode(text))
    });
};
const decode = (string, alphabet, bitsPerChar, name)=>{
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i){
        codes[alphabet[i]] = i;
    }
    let end = string.length;
    while(string[end - 1] === '='){
        --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for(let i = 0; i < end; ++i){
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
        }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
};
const encode = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0;
    let buffer = 0;
    for(let i = 0; i < data.length; ++i){
        buffer = buffer << 8 | data[i];
        bits += 8;
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
        while(out.length * bitsPerChar & 7){
            out += '=';
        }
    }
    return out;
};
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet })=>{
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
};
exports.Codec = Codec;
exports.baseX = baseX;
exports.from = from;
exports.or = or;
exports.rfc4648 = rfc4648;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base64 = base.rfc4648({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = base.rfc4648({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = base.rfc4648({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = base.rfc4648({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
});
exports.base64 = base64;
exports.base64pad = base64pad;
exports.base64url = base64url;
exports.base64urlpad = base64urlpad;
}}),
"[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.segmentedStringRefinementFactory = exports.jwtCharsRefinement = exports.cachedGetter = exports.preferredOrderCmp = exports.isDefined = void 0;
exports.matchesAny = matchesAny;
exports.parseB64uJson = parseB64uJson;
const base64_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const isDefined = (i)=>i !== undefined;
exports.isDefined = isDefined;
const preferredOrderCmp = (order)=>(a, b)=>{
        const aIdx = order.indexOf(a);
        const bIdx = order.indexOf(b);
        if (aIdx === bIdx) return 0;
        if (aIdx === -1) return 1;
        if (bIdx === -1) return -1;
        return aIdx - bIdx;
    };
exports.preferredOrderCmp = preferredOrderCmp;
function matchesAny(value) {
    return value == null ? (v)=>true : Array.isArray(value) ? (v)=>value.includes(v) : (v)=>v === value;
}
/**
 * Decorator to cache the result of a getter on a class instance.
 */ const cachedGetter = (target, _context)=>{
    return function() {
        const value = target.call(this);
        Object.defineProperty(this, target.name, {
            get: ()=>value,
            enumerable: true,
            configurable: true
        });
        return value;
    };
};
exports.cachedGetter = cachedGetter;
const decoder = new TextDecoder();
function parseB64uJson(input) {
    const inputBytes = base64_1.base64url.baseDecode(input);
    const json = decoder.decode(inputBytes);
    return JSON.parse(json);
}
/**
 * @example
 * ```ts
 * // jwtSchema will only allow base64url chars & "." (dot)
 * const jwtSchema = z.string().superRefine(jwtCharsRefinement)
 * ```
 */ const jwtCharsRefinement = (data, ctx)=>{
    // Note: this is a hot path, let's avoid using a RegExp
    let char;
    for(let i = 0; i < data.length; i++){
        char = data.charCodeAt(i);
        if (// Base64 URL encoding (most frequent)
        65 <= char && char <= 90 || 97 <= char && char <= 122 || 48 <= char && char <= 57 || // 0-9
        char === 45 || // -
        char === 95 || // _
        // Boundary (least frequent, check last)
        char === 46 // .
        ) {
        // continue
        } else {
            // Invalid char might be a surrogate pair
            const invalidChar = String.fromCodePoint(data.codePointAt(i));
            return ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `Invalid character "${invalidChar}" in JWT at position ${i}`
            });
        }
    }
};
exports.jwtCharsRefinement = jwtCharsRefinement;
/**
 * @example
 * ```ts
 * const jwtSchema = z.string().superRefine(segmentedStringRefinementFactory(3))
 * type Jwt = z.infer<typeof jwtSchema> // `${string}.${string}.${string}`
 * ```
 */ const segmentedStringRefinementFactory = (count, minPartLength = 2)=>{
    if (!Number.isFinite(count) || count < 1 || (count | 0) !== count) {
        throw new TypeError(`Count must be a natural number (got ${count})`);
    }
    const minTotalLength = count * minPartLength + (count - 1);
    const errorPrefix = `Invalid JWT format`;
    return (data, ctx)=>{
        if (data.length < minTotalLength) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `${errorPrefix}: too short`
            });
            return false;
        }
        let currentStart = 0;
        for(let i = 0; i < count - 1; i++){
            const nextDot = data.indexOf('.', currentStart);
            if (nextDot === -1) {
                ctx.addIssue({
                    code: zod_1.ZodIssueCode.custom,
                    message: `${errorPrefix}: expected ${count} segments, got ${i + 1}`
                });
                return false;
            }
            if (nextDot - currentStart < minPartLength) {
                ctx.addIssue({
                    code: zod_1.ZodIssueCode.custom,
                    message: `${errorPrefix}: segment ${i + 1} is too short`
                });
                return false;
            }
            currentStart = nextDot + 1;
        }
        if (data.indexOf('.', currentStart) !== -1) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `${errorPrefix}: too many segments`
            });
            return false;
        }
        if (data.length - currentStart < minPartLength) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `${errorPrefix}: last segment is too short`
            });
            return false;
        }
        return true;
    };
};
exports.segmentedStringRefinementFactory = segmentedStringRefinementFactory; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwtPayloadSchema = exports.jwtHeaderSchema = exports.isUnsignedJwt = exports.unsignedJwtSchema = exports.isSignedJwt = exports.signedJwtSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const jwk_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
exports.signedJwtSchema = zod_1.z.string().superRefine(util_js_1.jwtCharsRefinement).superRefine((0, util_js_1.segmentedStringRefinementFactory)(3));
const isSignedJwt = (data)=>exports.signedJwtSchema.safeParse(data).success;
exports.isSignedJwt = isSignedJwt;
exports.unsignedJwtSchema = zod_1.z.string().superRefine(util_js_1.jwtCharsRefinement).superRefine((0, util_js_1.segmentedStringRefinementFactory)(2));
const isUnsignedJwt = (data)=>exports.unsignedJwtSchema.safeParse(data).success;
exports.isUnsignedJwt = isUnsignedJwt;
/**
 * @see {@link https://www.rfc-editor.org/rfc/rfc7515.html#section-4}
 */ exports.jwtHeaderSchema = zod_1.z.object({
    /** "alg" (Algorithm) Header Parameter */ alg: zod_1.z.string(),
    /** "jku" (JWK Set URL) Header Parameter */ jku: zod_1.z.string().url().optional(),
    /** "jwk" (JSON Web Key) Header Parameter */ jwk: zod_1.z.object({
        kty: zod_1.z.string(),
        crv: zod_1.z.string().optional(),
        x: zod_1.z.string().optional(),
        y: zod_1.z.string().optional(),
        e: zod_1.z.string().optional(),
        n: zod_1.z.string().optional()
    }).optional(),
    /** "kid" (Key ID) Header Parameter */ kid: zod_1.z.string().optional(),
    /** "x5u" (X.509 URL) Header Parameter */ x5u: zod_1.z.string().optional(),
    /** "x5c" (X.509 Certificate Chain) Header Parameter */ x5c: zod_1.z.array(zod_1.z.string()).optional(),
    /** "x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter */ x5t: zod_1.z.string().optional(),
    /** "x5t#S256" (X.509 Certificate SHA-256 Thumbprint) Header Parameter */ 'x5t#S256': zod_1.z.string().optional(),
    /** "typ" (Type) Header Parameter */ typ: zod_1.z.string().optional(),
    /** "cty" (Content Type) Header Parameter */ cty: zod_1.z.string().optional(),
    /** "crit" (Critical) Header Parameter */ crit: zod_1.z.array(zod_1.z.string()).optional()
}).passthrough();
// https://www.iana.org/assignments/jwt/jwt.xhtml
exports.jwtPayloadSchema = zod_1.z.object({
    iss: zod_1.z.string().optional(),
    aud: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.array(zod_1.z.string()).nonempty()
    ]).optional(),
    sub: zod_1.z.string().optional(),
    exp: zod_1.z.number().int().optional(),
    nbf: zod_1.z.number().int().optional(),
    iat: zod_1.z.number().int().optional(),
    jti: zod_1.z.string().optional(),
    htm: zod_1.z.string().optional(),
    htu: zod_1.z.string().optional(),
    ath: zod_1.z.string().optional(),
    acr: zod_1.z.string().optional(),
    azp: zod_1.z.string().optional(),
    amr: zod_1.z.array(zod_1.z.string()).optional(),
    // https://datatracker.ietf.org/doc/html/rfc7800
    cnf: zod_1.z.object({
        kid: zod_1.z.string().optional(),
        jwk: jwk_js_1.jwkPubSchema.optional(),
        jwe: zod_1.z.string().optional(),
        jku: zod_1.z.string().url().optional(),
        // https://datatracker.ietf.org/doc/html/rfc9449#section-6.1
        jkt: zod_1.z.string().optional(),
        // https://datatracker.ietf.org/doc/html/rfc8705
        'x5t#S256': zod_1.z.string().optional(),
        // https://datatracker.ietf.org/doc/html/rfc9203
        osc: zod_1.z.string().optional()
    }).optional(),
    client_id: zod_1.z.string().optional(),
    scope: zod_1.z.string().optional(),
    nonce: zod_1.z.string().optional(),
    at_hash: zod_1.z.string().optional(),
    c_hash: zod_1.z.string().optional(),
    s_hash: zod_1.z.string().optional(),
    auth_time: zod_1.z.number().int().optional(),
    // https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
    // OpenID: "profile" scope
    name: zod_1.z.string().optional(),
    family_name: zod_1.z.string().optional(),
    given_name: zod_1.z.string().optional(),
    middle_name: zod_1.z.string().optional(),
    nickname: zod_1.z.string().optional(),
    preferred_username: zod_1.z.string().optional(),
    gender: zod_1.z.string().optional(),
    picture: zod_1.z.string().url().optional(),
    profile: zod_1.z.string().url().optional(),
    website: zod_1.z.string().url().optional(),
    birthdate: zod_1.z.string().regex(/\d{4}-\d{2}-\d{2}/) // YYYY-MM-DD
    .optional(),
    zoneinfo: zod_1.z.string().regex(/^[A-Za-z0-9_/]+$/).optional(),
    locale: zod_1.z.string().regex(/^[a-z]{2}(-[A-Z]{2})?$/).optional(),
    updated_at: zod_1.z.number().int().optional(),
    // OpenID: "email" scope
    email: zod_1.z.string().optional(),
    email_verified: zod_1.z.boolean().optional(),
    // OpenID: "phone" scope
    phone_number: zod_1.z.string().optional(),
    phone_number_verified: zod_1.z.boolean().optional(),
    // OpenID: "address" scope
    // https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim
    address: zod_1.z.object({
        formatted: zod_1.z.string().optional(),
        street_address: zod_1.z.string().optional(),
        locality: zod_1.z.string().optional(),
        region: zod_1.z.string().optional(),
        postal_code: zod_1.z.string().optional(),
        country: zod_1.z.string().optional()
    }).optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396#section-14.2
    authorization_details: zod_1.z.array(zod_1.z.object({
        type: zod_1.z.string(),
        // https://datatracker.ietf.org/doc/html/rfc9396#section-2.2
        locations: zod_1.z.array(zod_1.z.string()).optional(),
        actions: zod_1.z.array(zod_1.z.string()).optional(),
        datatypes: zod_1.z.array(zod_1.z.string()).optional(),
        identifier: zod_1.z.string().optional(),
        privileges: zod_1.z.array(zod_1.z.string()).optional()
    }).passthrough()).optional()
}).passthrough(); //# sourceMappingURL=jwt.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwt-decode.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unsafeDecodeJwt = unsafeDecodeJwt;
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
const jwt_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
function unsafeDecodeJwt(jwt) {
    const { 0: headerEnc, 1: payloadEnc, length } = jwt.split('.');
    if (length > 3 || length < 2) {
        throw new errors_js_1.JwtVerifyError(undefined, errors_js_1.ERR_JWT_INVALID);
    }
    const header = jwt_js_1.jwtHeaderSchema.parse((0, util_js_1.parseB64uJson)(headerEnc));
    if (length === 2 && header?.alg !== 'none') {
        throw new errors_js_1.JwtVerifyError(undefined, errors_js_1.ERR_JWT_INVALID);
    }
    const payload = jwt_js_1.jwtPayloadSchema.parse((0, util_js_1.parseB64uJson)(payloadEnc));
    return {
        header,
        payload
    };
} //# sourceMappingURL=jwt-decode.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwt-verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=jwt-verify.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __runInitializers = this && this.__runInitializers || function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = this && this.__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Key = void 0;
const alg_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/alg.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
const jwk_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
const jwkSchemaReadonly = jwk_js_1.jwkSchema.readonly();
let Key = (()=>{
    var _a;
    let _instanceExtraInitializers = [];
    let _get_publicJwk_decorators;
    let _get_bareJwk_decorators;
    let _get_algorithms_decorators;
    return _a = class Key {
        constructor(jwk){
            Object.defineProperty(this, "jwk", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: (__runInitializers(this, _instanceExtraInitializers), jwk)
            });
            // A key should always be used either for signing or encryption.
            if (!jwk.use) throw new errors_js_1.JwkError('Missing "use" Parameter value');
        }
        get isPrivate() {
            const { jwk } = this;
            if ('d' in jwk && jwk.d !== undefined) return true;
            if ('k' in jwk && jwk.k !== undefined) return true;
            return false;
        }
        get isSymetric() {
            const { jwk } = this;
            if ('k' in jwk && jwk.k !== undefined) return true;
            return false;
        }
        get privateJwk() {
            return this.isPrivate ? this.jwk : undefined;
        }
        get publicJwk() {
            if (this.isSymetric) return undefined;
            return jwkSchemaReadonly.parse({
                ...this.jwk,
                d: undefined,
                k: undefined
            });
        }
        get bareJwk() {
            if (this.isSymetric) return undefined;
            const { kty, crv, e, n, x, y } = this.jwk;
            return jwkSchemaReadonly.parse({
                crv,
                e,
                kty,
                n,
                x,
                y
            });
        }
        get use() {
            return this.jwk.use;
        }
        /**
             * The (forced) algorithm to use. If not provided, the key will be usable with
             * any of the algorithms in {@link algorithms}.
             *
             * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1 | "alg" (Algorithm) Header Parameter Values for JWS}
             */ get alg() {
            return this.jwk.alg;
        }
        get kid() {
            return this.jwk.kid;
        }
        get crv() {
            return this.jwk.crv;
        }
        /**
             * All the algorithms that this key can be used with. If `alg` is provided,
             * this set will only contain that algorithm.
             */ get algorithms() {
            return Object.freeze(Array.from((0, alg_js_1.jwkAlgorithms)(this.jwk)));
        }
    }, (()=>{
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _get_publicJwk_decorators = [
            util_js_1.cachedGetter
        ];
        _get_bareJwk_decorators = [
            util_js_1.cachedGetter
        ];
        _get_algorithms_decorators = [
            util_js_1.cachedGetter
        ];
        __esDecorate(_a, null, _get_publicJwk_decorators, {
            kind: "getter",
            name: "publicJwk",
            static: false,
            private: false,
            access: {
                has: (obj)=>"publicJwk" in obj,
                get: (obj)=>obj.publicJwk
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_bareJwk_decorators, {
            kind: "getter",
            name: "bareJwk",
            static: false,
            private: false,
            access: {
                has: (obj)=>"bareJwk" in obj,
                get: (obj)=>obj.bareJwk
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_algorithms_decorators, {
            kind: "getter",
            name: "algorithms",
            static: false,
            private: false,
            access: {
                has: (obj)=>"algorithms" in obj,
                get: (obj)=>obj.algorithms
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        if (_metadata) Object.defineProperty(_a, Symbol.metadata, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _metadata
        });
    })(), _a;
})();
exports.Key = Key; //# sourceMappingURL=key.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/keyset.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __runInitializers = this && this.__runInitializers || function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = this && this.__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Keyset = void 0;
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
const jwt_decode_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt-decode.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
const extractPrivateJwk = (key)=>key.privateJwk;
const extractPublicJwk = (key)=>key.publicJwk;
let Keyset = (()=>{
    var _a;
    let _instanceExtraInitializers = [];
    let _get_signAlgorithms_decorators;
    let _get_publicJwks_decorators;
    let _get_privateJwks_decorators;
    return _a = class Keyset {
        constructor(iterable, /**
             * The preferred algorithms to use when signing a JWT using this keyset.
             *
             * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1}
             */ preferredSigningAlgorithms = iterable instanceof _a ? [
            ...iterable.preferredSigningAlgorithms
        ] : [
            // Prefer elliptic curve algorithms
            'EdDSA',
            'ES256K',
            'ES256',
            // https://datatracker.ietf.org/doc/html/rfc7518#section-3.5
            'PS256',
            'PS384',
            'PS512',
            'HS256',
            'HS384',
            'HS512'
        ]){
            Object.defineProperty(this, "preferredSigningAlgorithms", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: (__runInitializers(this, _instanceExtraInitializers), preferredSigningAlgorithms)
            });
            Object.defineProperty(this, "keys", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            const keys = [];
            const kids = new Set();
            for (const key of iterable){
                if (!key) continue;
                keys.push(key);
                if (key.kid) {
                    if (kids.has(key.kid)) throw new errors_js_1.JwkError(`Duplicate key: ${key.kid}`);
                    else kids.add(key.kid);
                }
            }
            this.keys = Object.freeze(keys);
        }
        get size() {
            return this.keys.length;
        }
        get signAlgorithms() {
            const algorithms = new Set();
            for (const key of this){
                if (key.use !== 'sig') continue;
                for (const alg of key.algorithms){
                    algorithms.add(alg);
                }
            }
            return Object.freeze([
                ...algorithms
            ].sort((0, util_js_1.preferredOrderCmp)(this.preferredSigningAlgorithms)));
        }
        get publicJwks() {
            return {
                keys: Array.from(this, extractPublicJwk).filter(util_js_1.isDefined)
            };
        }
        get privateJwks() {
            return {
                keys: Array.from(this, extractPrivateJwk).filter(util_js_1.isDefined)
            };
        }
        has(kid) {
            return this.keys.some((key)=>key.kid === kid);
        }
        get(search) {
            for (const key of this.list(search)){
                return key;
            }
            throw new errors_js_1.JwkError(`Key not found ${search.kid || search.alg || '<unknown>'}`, errors_js_1.ERR_JWK_NOT_FOUND);
        }
        *list(search) {
            // Optimization: Empty string or empty array will not match any key
            if (search.kid?.length === 0) return;
            if (search.alg?.length === 0) return;
            for (const key of this){
                if (search.use && key.use !== search.use) continue;
                if (Array.isArray(search.kid)) {
                    if (!key.kid || !search.kid.includes(key.kid)) continue;
                } else if (search.kid) {
                    if (key.kid !== search.kid) continue;
                }
                if (Array.isArray(search.alg)) {
                    if (!search.alg.some((a)=>key.algorithms.includes(a))) continue;
                } else if (typeof search.alg === 'string') {
                    if (!key.algorithms.includes(search.alg)) continue;
                }
                yield key;
            }
        }
        findKey({ kid, alg, use }) {
            const matchingKeys = [];
            for (const key of this.list({
                kid,
                alg,
                use
            })){
                // Not a signing key
                if (!key.isPrivate) continue;
                // Skip negotiation if a specific "alg" was provided
                if (typeof alg === 'string') return [
                    key,
                    alg
                ];
                matchingKeys.push(key);
            }
            const isAllowedAlg = (0, util_js_1.matchesAny)(alg);
            const candidates = matchingKeys.map((key)=>[
                    key,
                    key.algorithms.filter(isAllowedAlg)
                ]);
            // Return the first candidates that matches the preferred algorithms
            for (const prefAlg of this.preferredSigningAlgorithms){
                for (const [matchingKey, matchingAlgs] of candidates){
                    if (matchingAlgs.includes(prefAlg)) return [
                        matchingKey,
                        prefAlg
                    ];
                }
            }
            // Return any candidate
            for (const [matchingKey, matchingAlgs] of candidates){
                for (const alg of matchingAlgs){
                    return [
                        matchingKey,
                        alg
                    ];
                }
            }
            throw new errors_js_1.JwkError(`No singing key found for ${kid || alg || use || '<unknown>'}`, errors_js_1.ERR_JWK_NOT_FOUND);
        }
        [(_get_signAlgorithms_decorators = [
            util_js_1.cachedGetter
        ], _get_publicJwks_decorators = [
            util_js_1.cachedGetter
        ], _get_privateJwks_decorators = [
            util_js_1.cachedGetter
        ], Symbol.iterator)]() {
            return this.keys.values();
        }
        async createJwt({ alg: sAlg, kid: sKid, ...header }, payload) {
            try {
                const [key, alg] = this.findKey({
                    alg: sAlg,
                    kid: sKid,
                    use: 'sig'
                });
                const protectedHeader = {
                    ...header,
                    alg,
                    kid: key.kid
                };
                if (typeof payload === 'function') {
                    payload = await payload(protectedHeader, key);
                }
                return await key.createJwt(protectedHeader, payload);
            } catch (err) {
                throw errors_js_1.JwtCreateError.from(err);
            }
        }
        async verifyJwt(token, options) {
            const { header } = (0, jwt_decode_js_1.unsafeDecodeJwt)(token);
            const { kid, alg } = header;
            const errors = [];
            for (const key of this.list({
                kid,
                alg
            })){
                try {
                    const result = await key.verifyJwt(token, options);
                    return {
                        ...result,
                        key
                    };
                } catch (err) {
                    errors.push(err);
                }
            }
            switch(errors.length){
                case 0:
                    throw new errors_js_1.JwtVerifyError('No key matched', errors_js_1.ERR_JWKS_NO_MATCHING_KEY);
                case 1:
                    throw errors_js_1.JwtVerifyError.from(errors[0], errors_js_1.ERR_JWT_INVALID);
                default:
                    throw errors_js_1.JwtVerifyError.from(errors, errors_js_1.ERR_JWT_INVALID);
            }
        }
        toJSON() {
            // Make a copy to prevent mutation of the original keyset
            return structuredClone(this.publicJwks);
        }
    }, (()=>{
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        __esDecorate(_a, null, _get_signAlgorithms_decorators, {
            kind: "getter",
            name: "signAlgorithms",
            static: false,
            private: false,
            access: {
                has: (obj)=>"signAlgorithms" in obj,
                get: (obj)=>obj.signAlgorithms
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_publicJwks_decorators, {
            kind: "getter",
            name: "publicJwks",
            static: false,
            private: false,
            access: {
                has: (obj)=>"publicJwks" in obj,
                get: (obj)=>obj.publicJwks
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_privateJwks_decorators, {
            kind: "getter",
            name: "privateJwks",
            static: false,
            private: false,
            access: {
                has: (obj)=>"privateJwks" in obj,
                get: (obj)=>obj.privateJwks
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        if (_metadata) Object.defineProperty(_a, Symbol.metadata, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _metadata
        });
    })(), _a;
})();
exports.Keyset = Keyset; //# sourceMappingURL=keyset.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidationError = void 0;
// Since we expose zod schemas, let's expose ZodError (under a generic name) so
// that dependents can catch schema parsing errors without requiring an explicit
// dependency on zod, or risking a conflict in case of mismatching zob versions.
var zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ValidationError", {
    enumerable: true,
    get: function() {
        return zod_1.ZodError;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/alg.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwks.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt-decode.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt-verify.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/key.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/keyset.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/digest.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const digest = (algorithm, data)=>(0, node_crypto_1.createHash)(algorithm).update(data).digest();
exports.default = digest;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decoder = exports.encoder = void 0;
exports.concat = concat;
exports.p2s = p2s;
exports.uint64be = uint64be;
exports.uint32be = uint32be;
exports.lengthAndInput = lengthAndInput;
exports.concatKdf = concatKdf;
const digest_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/digest.js [app-ssr] (ecmascript)");
exports.encoder = new TextEncoder();
exports.decoder = new TextDecoder();
const MAX_INT32 = 2 ** 32;
function concat(...buffers) {
    const size = buffers.reduce((acc, { length })=>acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    for (const buffer of buffers){
        buf.set(buffer, i);
        i += buffer.length;
    }
    return buf;
}
function p2s(alg, p2sInput) {
    return concat(exports.encoder.encode(alg), new Uint8Array([
        0
    ]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) {
        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    }
    buf.set([
        value >>> 24,
        value >>> 16,
        value >>> 8,
        value & 0xff
    ], offset);
}
function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
}
function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
}
function lengthAndInput(input) {
    return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
    const iterations = Math.ceil((bits >> 3) / 32);
    const res = new Uint8Array(iterations * 32);
    for(let iter = 0; iter < iterations; iter++){
        const buf = new Uint8Array(4 + secret.length + value.length);
        buf.set(uint32be(iter + 1));
        buf.set(secret, 4);
        buf.set(value, 4 + secret.length);
        res.set(await (0, digest_js_1.default)('sha256', buf), iter * 32);
    }
    return res.slice(0, bits >> 3);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decode = exports.encode = exports.encodeBase64 = exports.decodeBase64 = void 0;
const node_buffer_1 = __turbopack_require__("[externals]/node:buffer [external] (node:buffer, cjs)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
function normalize(input) {
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = buffer_utils_js_1.decoder.decode(encoded);
    }
    return encoded;
}
const encode = (input)=>node_buffer_1.Buffer.from(input).toString('base64url');
exports.encode = encode;
const decodeBase64 = (input)=>new Uint8Array(node_buffer_1.Buffer.from(input, 'base64'));
exports.decodeBase64 = decodeBase64;
const encodeBase64 = (input)=>node_buffer_1.Buffer.from(input).toString('base64');
exports.encodeBase64 = encodeBase64;
const decode = (input)=>new Uint8Array(node_buffer_1.Buffer.from(normalize(input), 'base64url'));
exports.decode = decode;
}}),
"[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JWSSignatureVerificationFailed = exports.JWKSTimeout = exports.JWKSMultipleMatchingKeys = exports.JWKSNoMatchingKey = exports.JWKSInvalid = exports.JWKInvalid = exports.JWTInvalid = exports.JWSInvalid = exports.JWEInvalid = exports.JWEDecryptionFailed = exports.JOSENotSupported = exports.JOSEAlgNotAllowed = exports.JWTExpired = exports.JWTClaimValidationFailed = exports.JOSEError = void 0;
class JOSEError extends Error {
    static code = 'ERR_JOSE_GENERIC';
    code = 'ERR_JOSE_GENERIC';
    constructor(message, options){
        super(message, options);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
exports.JOSEError = JOSEError;
class JWTClaimValidationFailed extends JOSEError {
    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    claim;
    reason;
    payload;
    constructor(message, payload, claim = 'unspecified', reason = 'unspecified'){
        super(message, {
            cause: {
                claim,
                reason,
                payload
            }
        });
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
    }
}
exports.JWTClaimValidationFailed = JWTClaimValidationFailed;
class JWTExpired extends JOSEError {
    static code = 'ERR_JWT_EXPIRED';
    code = 'ERR_JWT_EXPIRED';
    claim;
    reason;
    payload;
    constructor(message, payload, claim = 'unspecified', reason = 'unspecified'){
        super(message, {
            cause: {
                claim,
                reason,
                payload
            }
        });
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
    }
}
exports.JWTExpired = JWTExpired;
class JOSEAlgNotAllowed extends JOSEError {
    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';
    code = 'ERR_JOSE_ALG_NOT_ALLOWED';
}
exports.JOSEAlgNotAllowed = JOSEAlgNotAllowed;
class JOSENotSupported extends JOSEError {
    static code = 'ERR_JOSE_NOT_SUPPORTED';
    code = 'ERR_JOSE_NOT_SUPPORTED';
}
exports.JOSENotSupported = JOSENotSupported;
class JWEDecryptionFailed extends JOSEError {
    static code = 'ERR_JWE_DECRYPTION_FAILED';
    code = 'ERR_JWE_DECRYPTION_FAILED';
    constructor(message = 'decryption operation failed', options){
        super(message, options);
    }
}
exports.JWEDecryptionFailed = JWEDecryptionFailed;
class JWEInvalid extends JOSEError {
    static code = 'ERR_JWE_INVALID';
    code = 'ERR_JWE_INVALID';
}
exports.JWEInvalid = JWEInvalid;
class JWSInvalid extends JOSEError {
    static code = 'ERR_JWS_INVALID';
    code = 'ERR_JWS_INVALID';
}
exports.JWSInvalid = JWSInvalid;
class JWTInvalid extends JOSEError {
    static code = 'ERR_JWT_INVALID';
    code = 'ERR_JWT_INVALID';
}
exports.JWTInvalid = JWTInvalid;
class JWKInvalid extends JOSEError {
    static code = 'ERR_JWK_INVALID';
    code = 'ERR_JWK_INVALID';
}
exports.JWKInvalid = JWKInvalid;
class JWKSInvalid extends JOSEError {
    static code = 'ERR_JWKS_INVALID';
    code = 'ERR_JWKS_INVALID';
}
exports.JWKSInvalid = JWKSInvalid;
class JWKSNoMatchingKey extends JOSEError {
    static code = 'ERR_JWKS_NO_MATCHING_KEY';
    code = 'ERR_JWKS_NO_MATCHING_KEY';
    constructor(message = 'no applicable key found in the JSON Web Key Set', options){
        super(message, options);
    }
}
exports.JWKSNoMatchingKey = JWKSNoMatchingKey;
class JWKSMultipleMatchingKeys extends JOSEError {
    [Symbol.asyncIterator];
    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options){
        super(message, options);
    }
}
exports.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;
class JWKSTimeout extends JOSEError {
    static code = 'ERR_JWKS_TIMEOUT';
    code = 'ERR_JWKS_TIMEOUT';
    constructor(message = 'request timed out', options){
        super(message, options);
    }
}
exports.JWKSTimeout = JWKSTimeout;
class JWSSignatureVerificationFailed extends JOSEError {
    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    constructor(message = 'signature verification failed', options){
        super(message, options);
    }
}
exports.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/random.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return node_crypto_1.randomFillSync;
    }
});
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/iv.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bitLength = bitLength;
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const random_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/random.js [app-ssr] (ecmascript)");
function bitLength(alg) {
    switch(alg){
        case 'A128GCM':
        case 'A128GCMKW':
        case 'A192GCM':
        case 'A192GCMKW':
        case 'A256GCM':
        case 'A256GCMKW':
            return 96;
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return 128;
        default:
            throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
exports.default = (alg)=>(0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/check_iv_length.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const iv_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/iv.js [app-ssr] (ecmascript)");
const checkIvLength = (enc, iv)=>{
    if (iv.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
        throw new errors_js_1.JWEInvalid('Invalid Initialization Vector length');
    }
};
exports.default = checkIvLength;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const util = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
exports.default = (obj)=>util.types.isKeyObject(obj);
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/check_cek_length.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const checkCekLength = (enc, cek)=>{
    let expected;
    switch(enc){
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            expected = parseInt(enc.slice(-3), 10);
            break;
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            expected = parseInt(enc.slice(1, 4), 10);
            break;
        default:
            throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
    }
    if (cek instanceof Uint8Array) {
        const actual = cek.byteLength << 3;
        if (actual !== expected) {
            throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
        }
        return;
    }
    if ((0, is_key_object_js_1.default)(cek) && cek.type === 'secret') {
        const actual = cek.symmetricKeySize << 3;
        if (actual !== expected) {
            throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
        }
        return;
    }
    throw new TypeError('Invalid Content Encryption Key type');
};
exports.default = checkCekLength;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const timingSafeEqual = node_crypto_1.timingSafeEqual;
exports.default = timingSafeEqual;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/cbc_tag.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cbcTag;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
    const macData = (0, buffer_utils_js_1.concat)(aad, iv, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
    const hmac = (0, node_crypto_1.createHmac)(`sha${macSize}`, macKey);
    hmac.update(macData);
    return hmac.digest().slice(0, keySize >> 3);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isCryptoKey = void 0;
const crypto = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const util = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const webcrypto = crypto.webcrypto;
exports.default = webcrypto;
const isCryptoKey = (key)=>util.types.isCryptoKey(key);
exports.isCryptoKey = isCryptoKey;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkSigCryptoKey = checkSigCryptoKey;
exports.checkEncCryptoKey = checkEncCryptoKey;
function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
    switch(alg){
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected)=>key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        } else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            {
                if (!isAlgorithm(key.algorithm, 'HMAC')) throw unusable('HMAC');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'RS256':
        case 'RS384':
        case 'RS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5')) throw unusable('RSASSA-PKCS1-v1_5');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'PS256':
        case 'PS384':
        case 'PS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-PSS')) throw unusable('RSA-PSS');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'EdDSA':
            {
                if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {
                    throw unusable('Ed25519 or Ed448');
                }
                break;
            }
        case 'ES256':
        case 'ES384':
        case 'ES512':
            {
                if (!isAlgorithm(key.algorithm, 'ECDSA')) throw unusable('ECDSA');
                const expected = getNamedCurve(alg);
                const actual = key.algorithm.namedCurve;
                if (actual !== expected) throw unusable(expected, 'algorithm.namedCurve');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            {
                if (!isAlgorithm(key.algorithm, 'AES-GCM')) throw unusable('AES-GCM');
                const expected = parseInt(alg.slice(1, 4), 10);
                const actual = key.algorithm.length;
                if (actual !== expected) throw unusable(expected, 'algorithm.length');
                break;
            }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            {
                if (!isAlgorithm(key.algorithm, 'AES-KW')) throw unusable('AES-KW');
                const expected = parseInt(alg.slice(1, 4), 10);
                const actual = key.algorithm.length;
                if (actual !== expected) throw unusable(expected, 'algorithm.length');
                break;
            }
        case 'ECDH':
            {
                switch(key.algorithm.name){
                    case 'ECDH':
                    case 'X25519':
                    case 'X448':
                        break;
                    default:
                        throw unusable('ECDH, X25519, or X448');
                }
                break;
            }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            if (!isAlgorithm(key.algorithm, 'PBKDF2')) throw unusable('PBKDF2');
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-OAEP')) throw unusable('RSA-OAEP');
                const expected = parseInt(alg.slice(9), 10) || 1;
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withAlg = withAlg;
function message(msg, actual, ...types) {
    types = types.filter(Boolean);
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    } else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    } else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    } else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor?.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
}
exports.default = (actual, ...types)=>{
    return message('Key must be ', actual, ...types);
};
function withAlg(alg, actual, ...types) {
    return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/ciphers.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
let ciphers;
exports.default = (algorithm)=>{
    ciphers ||= new Set((0, node_crypto_1.getCiphers)());
    return ciphers.has(algorithm);
};
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.types = void 0;
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
exports.default = (key)=>(0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
const types = [
    'KeyObject'
];
exports.types = types;
if (globalThis.CryptoKey || webcrypto_js_1.default?.CryptoKey) {
    types.push('CryptoKey');
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/decrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const check_iv_length_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_iv_length.js [app-ssr] (ecmascript)");
const check_cek_length_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/check_cek_length.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const timing_safe_equal_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js [app-ssr] (ecmascript)");
const cbc_tag_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/cbc_tag.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const ciphers_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/ciphers.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const macSize = parseInt(enc.slice(-3), 10);
    const algorithm = `aes-${keySize}-cbc`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const expectedTag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
    let macCheckPassed;
    try {
        macCheckPassed = (0, timing_safe_equal_js_1.default)(tag, expectedTag);
    } catch  {}
    if (!macCheckPassed) {
        throw new errors_js_1.JWEDecryptionFailed();
    }
    let plaintext;
    try {
        const decipher = (0, node_crypto_1.createDecipheriv)(algorithm, encKey, iv);
        plaintext = (0, buffer_utils_js_1.concat)(decipher.update(ciphertext), decipher.final());
    } catch  {}
    if (!plaintext) {
        throw new errors_js_1.JWEDecryptionFailed();
    }
    return plaintext;
}
function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    try {
        const decipher = (0, node_crypto_1.createDecipheriv)(algorithm, cek, iv, {
            authTagLength: 16
        });
        decipher.setAuthTag(tag);
        if (aad.byteLength) {
            decipher.setAAD(aad, {
                plaintextLength: ciphertext.length
            });
        }
        const plaintext = decipher.update(ciphertext);
        decipher.final();
        return plaintext;
    } catch  {
        throw new errors_js_1.JWEDecryptionFailed();
    }
}
const decrypt = (enc, cek, ciphertext, iv, tag, aad)=>{
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, 'decrypt');
        key = node_crypto_1.KeyObject.from(cek);
    } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, 'Uint8Array'));
    }
    if (!iv) {
        throw new errors_js_1.JWEInvalid('JWE Initialization Vector missing');
    }
    if (!tag) {
        throw new errors_js_1.JWEInvalid('JWE Authentication Tag missing');
    }
    (0, check_cek_length_js_1.default)(enc, key);
    (0, check_iv_length_js_1.default)(enc, iv);
    switch(enc){
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
    }
};
exports.default = decrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/is_disjoint.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const isDisjoint = (...headers)=>{
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources){
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters){
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
exports.default = isDisjoint;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isObject;
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/aeskw.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unwrap = exports.wrap = void 0;
const node_buffer_1 = __turbopack_require__("[externals]/node:buffer [external] (node:buffer, cjs)");
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const ciphers_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/ciphers.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
function checkKeySize(key, alg) {
    if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
        throw new TypeError(`Invalid key size for alg: ${alg}`);
    }
}
function ensureKeyObject(key, alg, usage) {
    if ((0, is_key_object_js_1.default)(key)) {
        return key;
    }
    if (key instanceof Uint8Array) {
        return (0, node_crypto_1.createSecretKey)(key);
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
        return node_crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
}
const wrap = (alg, key, cek)=>{
    const size = parseInt(alg.slice(1, 4), 10);
    const algorithm = `aes${size}-wrap`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, 'wrapKey');
    checkKeySize(keyObject, alg);
    const cipher = (0, node_crypto_1.createCipheriv)(algorithm, keyObject, node_buffer_1.Buffer.alloc(8, 0xa6));
    return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
};
exports.wrap = wrap;
const unwrap = (alg, key, encryptedKey)=>{
    const size = parseInt(alg.slice(1, 4), 10);
    const algorithm = `aes${size}-wrap`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, 'unwrapKey');
    checkKeySize(keyObject, alg);
    const cipher = (0, node_crypto_1.createDecipheriv)(algorithm, keyObject, node_buffer_1.Buffer.alloc(8, 0xa6));
    return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
};
exports.unwrap = unwrap;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/is_jwk.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isJWK = isJWK;
exports.isPrivateJWK = isPrivateJWK;
exports.isPublicJWK = isPublicJWK;
exports.isSecretJWK = isSecretJWK;
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
function isJWK(key) {
    return (0, is_object_js_1.default)(key) && typeof key.kty === 'string';
}
function isPrivateJWK(key) {
    return key.kty !== 'oct' && typeof key.d === 'string';
}
function isPublicJWK(key) {
    return key.kty !== 'oct' && typeof key.d === 'undefined';
}
function isSecretJWK(key) {
    return isJWK(key) && key.kty === 'oct' && typeof key.k === 'string';
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/get_named_curve.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.weakMap = void 0;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const is_jwk_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_jwk.js [app-ssr] (ecmascript)");
exports.weakMap = new WeakMap();
const namedCurveToJOSE = (namedCurve)=>{
    switch(namedCurve){
        case 'prime256v1':
            return 'P-256';
        case 'secp384r1':
            return 'P-384';
        case 'secp521r1':
            return 'P-521';
        case 'secp256k1':
            return 'secp256k1';
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported key curve for this operation');
    }
};
const getNamedCurve = (kee, raw)=>{
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = node_crypto_1.KeyObject.from(kee);
    } else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
    } else if ((0, is_jwk_js_1.isJWK)(kee)) {
        return kee.crv;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
    }
    if (key.type === 'secret') {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
    }
    switch(key.asymmetricKeyType){
        case 'ed25519':
        case 'ed448':
            return `Ed${key.asymmetricKeyType.slice(2)}`;
        case 'x25519':
        case 'x448':
            return `X${key.asymmetricKeyType.slice(1)}`;
        case 'ec':
            {
                const namedCurve = key.asymmetricKeyDetails.namedCurve;
                if (raw) {
                    return namedCurve;
                }
                return namedCurveToJOSE(namedCurve);
            }
        default:
            throw new TypeError('Invalid asymmetric key type for this operation');
    }
};
exports.default = getNamedCurve;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/ecdhes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ecdhAllowed = void 0;
exports.deriveKey = deriveKey;
exports.generateEpk = generateEpk;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_util_1 = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const get_named_curve_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/get_named_curve.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const generateKeyPair = (0, node_util_1.promisify)(node_crypto_1.generateKeyPair);
async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
    let publicKey;
    if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, 'ECDH');
        publicKey = node_crypto_1.KeyObject.from(publicKee);
    } else if ((0, is_key_object_js_1.default)(publicKee)) {
        publicKey = publicKee;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, ...is_key_like_js_1.types));
    }
    let privateKey;
    if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, 'ECDH', 'deriveBits');
        privateKey = node_crypto_1.KeyObject.from(privateKee);
    } else if ((0, is_key_object_js_1.default)(privateKee)) {
        privateKey = privateKee;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, ...is_key_like_js_1.types));
    }
    const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
    const sharedSecret = (0, node_crypto_1.diffieHellman)({
        privateKey,
        publicKey
    });
    return (0, buffer_utils_js_1.concatKdf)(sharedSecret, keyLength, value);
}
async function generateEpk(kee) {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = node_crypto_1.KeyObject.from(kee);
    } else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
    }
    switch(key.asymmetricKeyType){
        case 'x25519':
            return generateKeyPair('x25519');
        case 'x448':
            {
                return generateKeyPair('x448');
            }
        case 'ec':
            {
                const namedCurve = (0, get_named_curve_js_1.default)(key);
                return generateKeyPair('ec', {
                    namedCurve
                });
            }
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported EPK');
    }
}
const ecdhAllowed = (key)=>[
        'P-256',
        'P-384',
        'P-521',
        'X25519',
        'X448'
    ].includes((0, get_named_curve_js_1.default)(key));
exports.ecdhAllowed = ecdhAllowed;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/check_p2s.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = checkP2s;
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
function checkP2s(p2s) {
    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
        throw new errors_js_1.JWEInvalid('PBES2 Salt Input must be 8 or more octets');
    }
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/pbes2kw.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decrypt = exports.encrypt = void 0;
const node_util_1 = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const random_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/random.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const aeskw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/aeskw.js [app-ssr] (ecmascript)");
const check_p2s_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_p2s.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const pbkdf2 = (0, node_util_1.promisify)(node_crypto_1.pbkdf2);
function getPassword(key, alg) {
    if ((0, is_key_object_js_1.default)(key)) {
        return key.export();
    }
    if (key instanceof Uint8Array) {
        return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, 'deriveBits', 'deriveKey');
        return node_crypto_1.KeyObject.from(key).export();
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
}
const encrypt = async (alg, key, cek, p2c = 2048, p2s = (0, random_js_1.default)(new Uint8Array(16)))=>{
    (0, check_p2s_js_1.default)(p2s);
    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
    const encryptedKey = await (0, aeskw_js_1.wrap)(alg.slice(-6), derivedKey, cek);
    return {
        encryptedKey,
        p2c,
        p2s: (0, base64url_js_1.encode)(p2s)
    };
};
exports.encrypt = encrypt;
const decrypt = async (alg, key, encryptedKey, p2c, p2s)=>{
    (0, check_p2s_js_1.default)(p2s);
    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
    return (0, aeskw_js_1.unwrap)(alg.slice(-6), derivedKey, encryptedKey);
};
exports.decrypt = decrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/check_key_length.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
exports.default = (key, alg)=>{
    let modulusLength;
    try {
        if (key instanceof node_crypto_1.KeyObject) {
            modulusLength = key.asymmetricKeyDetails?.modulusLength;
        } else {
            modulusLength = Buffer.from(key.n, 'base64url').byteLength << 3;
        }
    } catch  {}
    if (typeof modulusLength !== 'number' || modulusLength < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
};
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/rsaes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decrypt = exports.encrypt = void 0;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_util_1 = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const check_key_length_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/check_key_length.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const checkKey = (key, alg)=>{
    if (key.asymmetricKeyType !== 'rsa') {
        throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
    }
    (0, check_key_length_js_1.default)(key, alg);
};
const RSA1_5 = (0, node_util_1.deprecate)(()=>node_crypto_1.constants.RSA_PKCS1_PADDING, 'The RSA1_5 "alg" (JWE Algorithm) is deprecated and will be removed in the next major revision.');
const resolvePadding = (alg)=>{
    switch(alg){
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            return node_crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
        case 'RSA1_5':
            return RSA1_5();
        default:
            return undefined;
    }
};
const resolveOaepHash = (alg)=>{
    switch(alg){
        case 'RSA-OAEP':
            return 'sha1';
        case 'RSA-OAEP-256':
            return 'sha256';
        case 'RSA-OAEP-384':
            return 'sha384';
        case 'RSA-OAEP-512':
            return 'sha512';
        default:
            return undefined;
    }
};
function ensureKeyObject(key, alg, ...usages) {
    if ((0, is_key_object_js_1.default)(key)) {
        return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
        return node_crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
}
const encrypt = (alg, key, cek)=>{
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = ensureKeyObject(key, alg, 'wrapKey', 'encrypt');
    checkKey(keyObject, alg);
    return (0, node_crypto_1.publicEncrypt)({
        key: keyObject,
        oaepHash,
        padding
    }, cek);
};
exports.encrypt = encrypt;
const decrypt = (alg, key, encryptedKey)=>{
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = ensureKeyObject(key, alg, 'unwrapKey', 'decrypt');
    checkKey(keyObject, alg);
    return (0, node_crypto_1.privateDecrypt)({
        key: keyObject,
        oaepHash,
        padding
    }, encryptedKey);
};
exports.decrypt = decrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/normalize_key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {};
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/cek.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bitLength = bitLength;
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const random_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/random.js [app-ssr] (ecmascript)");
function bitLength(alg) {
    switch(alg){
        case 'A128GCM':
            return 128;
        case 'A192GCM':
            return 192;
        case 'A256GCM':
        case 'A128CBC-HS256':
            return 256;
        case 'A192CBC-HS384':
            return 384;
        case 'A256CBC-HS512':
            return 512;
        default:
            throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
exports.default = (alg)=>(0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/asn1.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromX509 = exports.fromSPKI = exports.fromPKCS8 = exports.toPKCS8 = exports.toSPKI = void 0;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_buffer_1 = __turbopack_require__("[externals]/node:buffer [external] (node:buffer, cjs)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const genericExport = (keyType, keyFormat, key)=>{
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
            throw new TypeError('CryptoKey is not extractable');
        }
        keyObject = node_crypto_1.KeyObject.from(key);
    } else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
    }
    if (keyObject.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
    }
    return keyObject.export({
        format: 'pem',
        type: keyFormat
    });
};
const toSPKI = (key)=>{
    return genericExport('public', 'spki', key);
};
exports.toSPKI = toSPKI;
const toPKCS8 = (key)=>{
    return genericExport('private', 'pkcs8', key);
};
exports.toPKCS8 = toPKCS8;
const fromPKCS8 = (pem)=>(0, node_crypto_1.createPrivateKey)({
        key: node_buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ''), 'base64'),
        type: 'pkcs8',
        format: 'der'
    });
exports.fromPKCS8 = fromPKCS8;
const fromSPKI = (pem)=>(0, node_crypto_1.createPublicKey)({
        key: node_buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ''), 'base64'),
        type: 'spki',
        format: 'der'
    });
exports.fromSPKI = fromSPKI;
const fromX509 = (pem)=>(0, node_crypto_1.createPublicKey)({
        key: pem,
        type: 'spki',
        format: 'pem'
    });
exports.fromX509 = fromX509;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const parse = (key)=>{
    if (key.d) {
        return (0, node_crypto_1.createPrivateKey)({
            format: 'jwk',
            key
        });
    }
    return (0, node_crypto_1.createPublicKey)({
        format: 'jwk',
        key
    });
};
exports.default = parse;
}}),
"[project]/node_modules/jose/dist/node/cjs/key/import.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.importSPKI = importSPKI;
exports.importX509 = importX509;
exports.importPKCS8 = importPKCS8;
exports.importJWK = importJWK;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const asn1_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/asn1.js [app-ssr] (ecmascript)");
const jwk_to_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return (0, asn1_js_1.fromSPKI)(spki, alg, options);
}
async function importX509(x509, alg, options) {
    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {
        throw new TypeError('"x509" must be X.509 formatted string');
    }
    return (0, asn1_js_1.fromX509)(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
        throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
    }
    return (0, asn1_js_1.fromPKCS8)(pkcs8, alg, options);
}
async function importJWK(jwk, alg) {
    if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    alg ||= jwk.alg;
    switch(jwk.kty){
        case 'oct':
            if (typeof jwk.k !== 'string' || !jwk.k) {
                throw new TypeError('missing "k" (Key Value) Parameter value');
            }
            return (0, base64url_js_1.decode)(jwk.k);
        case 'RSA':
            if (jwk.oth !== undefined) {
                throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
            }
        case 'EC':
        case 'OKP':
            return (0, jwk_to_key_js_1.default)({
                ...jwk,
                alg
            });
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
}
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/check_key_type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkKeyTypeWithJwk = void 0;
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const jwk = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_jwk.js [app-ssr] (ecmascript)");
const tag = (key)=>key?.[Symbol.toStringTag];
const jwkMatchesOp = (alg, key, usage)=>{
    if (key.use !== undefined && key.use !== 'sig') {
        throw new TypeError('Invalid key for this operation, when present its use must be sig');
    }
    if (key.key_ops !== undefined && key.key_ops.includes?.(usage) !== true) {
        throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
    }
    if (key.alg !== undefined && key.alg !== alg) {
        throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);
    }
    return true;
};
const symmetricTypeCheck = (alg, key, usage, allowJwk)=>{
    if (key instanceof Uint8Array) return;
    if (allowJwk && jwk.isJWK(key)) {
        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage)) return;
        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
    }
    if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types, 'Uint8Array', allowJwk ? 'JSON Web Key' : null));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (alg, key, usage, allowJwk)=>{
    if (allowJwk && jwk.isJWK(key)) {
        switch(usage){
            case 'sign':
                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage)) return;
                throw new TypeError(`JSON Web Key for this operation be a private JWK`);
            case 'verify':
                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage)) return;
                throw new TypeError(`JSON Web Key for this operation be a public JWK`);
        }
    }
    if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types, allowJwk ? 'JSON Web Key' : null));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
function checkKeyType(allowJwk, alg, key, usage) {
    const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(alg, key, usage, allowJwk);
    } else {
        asymmetricTypeCheck(alg, key, usage, allowJwk);
    }
}
exports.default = checkKeyType.bind(undefined, false);
exports.checkKeyTypeWithJwk = checkKeyType.bind(undefined, true);
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/encrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const check_iv_length_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_iv_length.js [app-ssr] (ecmascript)");
const check_cek_length_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/check_cek_length.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const cbc_tag_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/cbc_tag.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const iv_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/iv.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const ciphers_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/ciphers.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
function cbcEncrypt(enc, plaintext, cek, iv, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const algorithm = `aes-${keySize}-cbc`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0, node_crypto_1.createCipheriv)(algorithm, encKey, iv);
    const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
    const macSize = parseInt(enc.slice(-3), 10);
    const tag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
    return {
        ciphertext,
        tag,
        iv
    };
}
function gcmEncrypt(enc, plaintext, cek, iv, aad) {
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0, node_crypto_1.createCipheriv)(algorithm, cek, iv, {
        authTagLength: 16
    });
    if (aad.byteLength) {
        cipher.setAAD(aad, {
            plaintextLength: plaintext.length
        });
    }
    const ciphertext = cipher.update(plaintext);
    cipher.final();
    const tag = cipher.getAuthTag();
    return {
        ciphertext,
        tag,
        iv
    };
}
const encrypt = (enc, plaintext, cek, iv, aad)=>{
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, 'encrypt');
        key = node_crypto_1.KeyObject.from(cek);
    } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, 'Uint8Array'));
    }
    (0, check_cek_length_js_1.default)(enc, key);
    if (iv) {
        (0, check_iv_length_js_1.default)(enc, iv);
    } else {
        iv = (0, iv_js_1.default)(enc);
    }
    switch(enc){
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return cbcEncrypt(enc, plaintext, key, iv, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            return gcmEncrypt(enc, plaintext, key, iv, aad);
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
    }
};
exports.default = encrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/aesgcmkw.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrap = wrap;
exports.unwrap = unwrap;
const encrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/encrypt.js [app-ssr] (ecmascript)");
const decrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/decrypt.js [app-ssr] (ecmascript)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
async function wrap(alg, key, cek, iv) {
    const jweAlgorithm = alg.slice(0, 7);
    const wrapped = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
    return {
        encryptedKey: wrapped.ciphertext,
        iv: (0, base64url_js_1.encode)(wrapped.iv),
        tag: (0, base64url_js_1.encode)(wrapped.tag)
    };
}
async function unwrap(alg, key, encryptedKey, iv, tag) {
    const jweAlgorithm = alg.slice(0, 7);
    return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const aeskw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/aeskw.js [app-ssr] (ecmascript)");
const ECDH = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/ecdhes.js [app-ssr] (ecmascript)");
const pbes2kw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/pbes2kw.js [app-ssr] (ecmascript)");
const rsaes_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/rsaes.js [app-ssr] (ecmascript)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const normalize_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/normalize_key.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const cek_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/cek.js [app-ssr] (ecmascript)");
const import_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/import.js [app-ssr] (ecmascript)");
const check_key_type_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_key_type.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const aesgcmkw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/aesgcmkw.js [app-ssr] (ecmascript)");
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
    (0, check_key_type_js_1.default)(alg, key, 'decrypt');
    key = await normalize_key_js_1.default.normalizePrivateKey?.(key, alg) || key;
    switch(alg){
        case 'dir':
            {
                if (encryptedKey !== undefined) throw new errors_js_1.JWEInvalid('Encountered unexpected JWE Encrypted Key');
                return key;
            }
        case 'ECDH-ES':
            if (encryptedKey !== undefined) throw new errors_js_1.JWEInvalid('Encountered unexpected JWE Encrypted Key');
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                if (!(0, is_object_js_1.default)(joseHeader.epk)) throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
                if (!ECDH.ecdhAllowed(key)) throw new errors_js_1.JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');
                const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
                let partyUInfo;
                let partyVInfo;
                if (joseHeader.apu !== undefined) {
                    if (typeof joseHeader.apu !== 'string') throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
                    try {
                        partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
                    } catch  {
                        throw new errors_js_1.JWEInvalid('Failed to base64url decode the apu');
                    }
                }
                if (joseHeader.apv !== undefined) {
                    if (typeof joseHeader.apv !== 'string') throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
                    try {
                        partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
                    } catch  {
                        throw new errors_js_1.JWEInvalid('Failed to base64url decode the apv');
                    }
                }
                const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? (0, cek_js_1.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
                if (alg === 'ECDH-ES') return sharedSecret;
                if (encryptedKey === undefined) throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
                return (0, aeskw_js_1.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
            }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            {
                if (encryptedKey === undefined) throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
                return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
            }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            {
                if (encryptedKey === undefined) throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
                if (typeof joseHeader.p2c !== 'number') throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
                const p2cLimit = options?.maxPBES2Count || 10_000;
                if (joseHeader.p2c > p2cLimit) throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
                if (typeof joseHeader.p2s !== 'string') throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
                let p2s;
                try {
                    p2s = (0, base64url_js_1.decode)(joseHeader.p2s);
                } catch  {
                    throw new errors_js_1.JWEInvalid('Failed to base64url decode the p2s');
                }
                return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, p2s);
            }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            {
                if (encryptedKey === undefined) throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
                return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
            }
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
            {
                if (encryptedKey === undefined) throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
                if (typeof joseHeader.iv !== 'string') throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
                if (typeof joseHeader.tag !== 'string') throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
                let iv;
                try {
                    iv = (0, base64url_js_1.decode)(joseHeader.iv);
                } catch  {
                    throw new errors_js_1.JWEInvalid('Failed to base64url decode the iv');
                }
                let tag;
                try {
                    tag = (0, base64url_js_1.decode)(joseHeader.tag);
                } catch  {
                    throw new errors_js_1.JWEInvalid('Failed to base64url decode the tag');
                }
                return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv, tag);
            }
        default:
            {
                throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
            }
    }
}
exports.default = decryptKeyManagement;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/validate_crit.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([
            ...Object.entries(recognizedOption),
            ...recognizedDefault.entries()
        ]);
    } else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit){
        if (!recognized.has(parameter)) {
            throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        }
        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
exports.default = validateCrit;
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/validate_algorithms.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const validateAlgorithms = (option, algorithms)=>{
    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s)=>typeof s !== 'string'))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};
exports.default = validateAlgorithms;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.flattenedDecrypt = flattenedDecrypt;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const decrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/decrypt.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_disjoint_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_disjoint.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const decrypt_key_management_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const cek_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/cek.js [app-ssr] (ecmascript)");
const validate_crit_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_crit.js [app-ssr] (ecmascript)");
const validate_algorithms_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_algorithms.js [app-ssr] (ecmascript)");
async function flattenedDecrypt(jwe, key, options) {
    if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid('Flattened JWE must be an object');
    }
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
        throw new errors_js_1.JWEInvalid('JOSE Header missing');
    }
    if (jwe.iv !== undefined && typeof jwe.iv !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Initialization Vector incorrect type');
    }
    if (typeof jwe.ciphertext !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Ciphertext missing or incorrect type');
    }
    if (jwe.tag !== undefined && typeof jwe.tag !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Authentication Tag incorrect type');
    }
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Protected Header incorrect type');
    }
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Encrypted Key incorrect type');
    }
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE AAD incorrect type');
    }
    if (jwe.header !== undefined && !(0, is_object_js_1.default)(jwe.header)) {
        throw new errors_js_1.JWEInvalid('JWE Shared Unprotected Header incorrect type');
    }
    if (jwe.unprotected !== undefined && !(0, is_object_js_1.default)(jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
    }
    let parsedProt;
    if (jwe.protected) {
        try {
            const protectedHeader = (0, base64url_js_1.decode)(jwe.protected);
            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
        } catch  {
            throw new errors_js_1.JWEInvalid('JWE Protected Header is invalid');
        }
    }
    if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected
    };
    (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options?.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
        throw new errors_js_1.JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
    }
    const { alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new errors_js_1.JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
    }
    if (typeof enc !== 'string' || !enc) {
        throw new errors_js_1.JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
    }
    const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options && (0, validate_algorithms_js_1.default)('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg) || !keyManagementAlgorithms && alg.startsWith('PBES2')) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
    }
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter value not allowed');
    }
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) {
        try {
            encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
        } catch  {
            throw new errors_js_1.JWEInvalid('Failed to base64url decode the encrypted_key');
        }
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
    }
    let cek;
    try {
        cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
    } catch (err) {
        if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) {
            throw err;
        }
        cek = (0, cek_js_1.default)(enc);
    }
    let iv;
    let tag;
    if (jwe.iv !== undefined) {
        try {
            iv = (0, base64url_js_1.decode)(jwe.iv);
        } catch  {
            throw new errors_js_1.JWEInvalid('Failed to base64url decode the iv');
        }
    }
    if (jwe.tag !== undefined) {
        try {
            tag = (0, base64url_js_1.decode)(jwe.tag);
        } catch  {
            throw new errors_js_1.JWEInvalid('Failed to base64url decode the tag');
        }
    }
    const protectedHeader = buffer_utils_js_1.encoder.encode(jwe.protected ?? '');
    let additionalData;
    if (jwe.aad !== undefined) {
        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(jwe.aad));
    } else {
        additionalData = protectedHeader;
    }
    let ciphertext;
    try {
        ciphertext = (0, base64url_js_1.decode)(jwe.ciphertext);
    } catch  {
        throw new errors_js_1.JWEInvalid('Failed to base64url decode the ciphertext');
    }
    const plaintext = await (0, decrypt_js_1.default)(enc, cek, ciphertext, iv, tag, additionalData);
    const result = {
        plaintext
    };
    if (jwe.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jwe.aad !== undefined) {
        try {
            result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
        } catch  {
            throw new errors_js_1.JWEInvalid('Failed to base64url decode the aad');
        }
    }
    if (jwe.unprotected !== undefined) {
        result.sharedUnprotectedHeader = jwe.unprotected;
    }
    if (jwe.header !== undefined) {
        result.unprotectedHeader = jwe.header;
    }
    if (resolvedKey) {
        return {
            ...result,
            key
        };
    }
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compactDecrypt = compactDecrypt;
const decrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
async function compactDecrypt(jwe, key, options) {
    if (jwe instanceof Uint8Array) {
        jwe = buffer_utils_js_1.decoder.decode(jwe);
    }
    if (typeof jwe !== 'string') {
        throw new errors_js_1.JWEInvalid('Compact JWE must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split('.');
    if (length !== 5) {
        throw new errors_js_1.JWEInvalid('Invalid Compact JWE');
    }
    const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
        ciphertext,
        iv: iv || undefined,
        protected: protectedHeader,
        tag: tag || undefined,
        encrypted_key: encryptedKey || undefined
    }, key, options);
    const result = {
        plaintext: decrypted.plaintext,
        protectedHeader: decrypted.protectedHeader
    };
    if (typeof key === 'function') {
        return {
            ...result,
            key: decrypted.key
        };
    }
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jwe/general/decrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generalDecrypt = generalDecrypt;
const decrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
async function generalDecrypt(jwe, key, options) {
    if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid('General JWE must be an object');
    }
    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
        throw new errors_js_1.JWEInvalid('JWE Recipients missing or incorrect type');
    }
    if (!jwe.recipients.length) {
        throw new errors_js_1.JWEInvalid('JWE Recipients has no members');
    }
    for (const recipient of jwe.recipients){
        try {
            return await (0, decrypt_js_1.flattenedDecrypt)({
                aad: jwe.aad,
                ciphertext: jwe.ciphertext,
                encrypted_key: recipient.encrypted_key,
                header: recipient.header,
                iv: jwe.iv,
                protected: jwe.protected,
                tag: jwe.tag,
                unprotected: jwe.unprotected
            }, key, options);
        } catch  {}
    }
    throw new errors_js_1.JWEDecryptionFailed();
}
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/private_symbols.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unprotected = void 0;
exports.unprotected = Symbol();
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const is_key_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_object.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const keyToJWK = (key)=>{
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
            throw new TypeError('CryptoKey is not extractable');
        }
        keyObject = node_crypto_1.KeyObject.from(key);
    } else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
    } else if (key instanceof Uint8Array) {
        return {
            kty: 'oct',
            k: (0, base64url_js_1.encode)(key)
        };
    } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
    }
    if (keyObject.type !== 'secret' && ![
        'rsa',
        'ec',
        'ed25519',
        'x25519',
        'ed448',
        'x448'
    ].includes(keyObject.asymmetricKeyType)) {
        throw new errors_js_1.JOSENotSupported('Unsupported key asymmetricKeyType');
    }
    return keyObject.export({
        format: 'jwk'
    });
};
exports.default = keyToJWK;
}}),
"[project]/node_modules/jose/dist/node/cjs/key/export.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.exportSPKI = exportSPKI;
exports.exportPKCS8 = exportPKCS8;
exports.exportJWK = exportJWK;
const asn1_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/asn1.js [app-ssr] (ecmascript)");
const asn1_js_2 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/asn1.js [app-ssr] (ecmascript)");
const key_to_jwk_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js [app-ssr] (ecmascript)");
async function exportSPKI(key) {
    return (0, asn1_js_1.toSPKI)(key);
}
async function exportPKCS8(key) {
    return (0, asn1_js_2.toPKCS8)(key);
}
async function exportJWK(key) {
    return (0, key_to_jwk_js_1.default)(key);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const aeskw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/aeskw.js [app-ssr] (ecmascript)");
const ECDH = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/ecdhes.js [app-ssr] (ecmascript)");
const pbes2kw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/pbes2kw.js [app-ssr] (ecmascript)");
const rsaes_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/rsaes.js [app-ssr] (ecmascript)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const normalize_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/normalize_key.js [app-ssr] (ecmascript)");
const cek_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/cek.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const export_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/export.js [app-ssr] (ecmascript)");
const check_key_type_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_key_type.js [app-ssr] (ecmascript)");
const aesgcmkw_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/aesgcmkw.js [app-ssr] (ecmascript)");
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
    let encryptedKey;
    let parameters;
    let cek;
    (0, check_key_type_js_1.default)(alg, key, 'encrypt');
    key = await normalize_key_js_1.default.normalizePublicKey?.(key, alg) || key;
    switch(alg){
        case 'dir':
            {
                cek = key;
                break;
            }
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                if (!ECDH.ecdhAllowed(key)) {
                    throw new errors_js_1.JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');
                }
                const { apu, apv } = providedParameters;
                let { epk: ephemeralKey } = providedParameters;
                ephemeralKey ||= (await ECDH.generateEpk(key)).privateKey;
                const { x, y, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
                const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? (0, cek_js_1.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
                parameters = {
                    epk: {
                        x,
                        crv,
                        kty
                    }
                };
                if (kty === 'EC') parameters.epk.y = y;
                if (apu) parameters.apu = (0, base64url_js_1.encode)(apu);
                if (apv) parameters.apv = (0, base64url_js_1.encode)(apv);
                if (alg === 'ECDH-ES') {
                    cek = sharedSecret;
                    break;
                }
                cek = providedCek || (0, cek_js_1.default)(enc);
                const kwAlg = alg.slice(-6);
                encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
                break;
            }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            {
                cek = providedCek || (0, cek_js_1.default)(enc);
                encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
                break;
            }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            {
                cek = providedCek || (0, cek_js_1.default)(enc);
                const { p2c, p2s } = providedParameters;
                ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
                break;
            }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            {
                cek = providedCek || (0, cek_js_1.default)(enc);
                encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
                break;
            }
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
            {
                cek = providedCek || (0, cek_js_1.default)(enc);
                const { iv } = providedParameters;
                ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv));
                break;
            }
        default:
            {
                throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
            }
    }
    return {
        cek,
        encryptedKey,
        parameters
    };
}
exports.default = encryptKeyManagement;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FlattenedEncrypt = void 0;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const private_symbols_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/private_symbols.js [app-ssr] (ecmascript)");
const encrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/encrypt.js [app-ssr] (ecmascript)");
const encrypt_key_management_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_disjoint_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_disjoint.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const validate_crit_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_crit.js [app-ssr] (ecmascript)");
class FlattenedEncrypt {
    _plaintext;
    _protectedHeader;
    _sharedUnprotectedHeader;
    _unprotectedHeader;
    _aad;
    _cek;
    _iv;
    _keyManagementParameters;
    constructor(plaintext){
        if (!(plaintext instanceof Uint8Array)) {
            throw new TypeError('plaintext must be an instance of Uint8Array');
        }
        this._plaintext = plaintext;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError('setKeyManagementParameters can only be called once');
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError('setContentEncryptionKey can only be called once');
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError('setInitializationVector can only be called once');
        }
        this._iv = iv;
        return this;
    }
    async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
            throw new errors_js_1.JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
            throw new errors_js_1.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader
        };
        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options?.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) {
            throw new errors_js_1.JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== 'string' || !enc) {
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (this._cek && (alg === 'dir' || alg === 'ECDH-ES')) {
            throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${alg}`);
        }
        let cek;
        {
            let parameters;
            ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) {
                if (options && private_symbols_js_1.unprotected in options) {
                    if (!this._unprotectedHeader) {
                        this.setUnprotectedHeader(parameters);
                    } else {
                        this._unprotectedHeader = {
                            ...this._unprotectedHeader,
                            ...parameters
                        };
                    }
                } else if (!this._protectedHeader) {
                    this.setProtectedHeader(parameters);
                } else {
                    this._protectedHeader = {
                        ...this._protectedHeader,
                        ...parameters
                    };
                }
            }
        }
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        } else {
            protectedHeader = buffer_utils_js_1.encoder.encode('');
        }
        if (this._aad) {
            aadMember = (0, base64url_js_1.encode)(this._aad);
            additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(aadMember));
        } else {
            additionalData = protectedHeader;
        }
        const { ciphertext, tag, iv } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData);
        const jwe = {
            ciphertext: (0, base64url_js_1.encode)(ciphertext)
        };
        if (iv) {
            jwe.iv = (0, base64url_js_1.encode)(iv);
        }
        if (tag) {
            jwe.tag = (0, base64url_js_1.encode)(tag);
        }
        if (encryptedKey) {
            jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
        }
        if (aadMember) {
            jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
            jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
            jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
            jwe.header = this._unprotectedHeader;
        }
        return jwe;
    }
}
exports.FlattenedEncrypt = FlattenedEncrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwe/general/encrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeneralEncrypt = void 0;
const encrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js [app-ssr] (ecmascript)");
const private_symbols_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/private_symbols.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const cek_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/cek.js [app-ssr] (ecmascript)");
const is_disjoint_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_disjoint.js [app-ssr] (ecmascript)");
const encrypt_key_management_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js [app-ssr] (ecmascript)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const validate_crit_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_crit.js [app-ssr] (ecmascript)");
class IndividualRecipient {
    parent;
    unprotectedHeader;
    key;
    options;
    constructor(enc, key, options){
        this.parent = enc;
        this.key = key;
        this.options = options;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
    }
    addRecipient(...args) {
        return this.parent.addRecipient(...args);
    }
    encrypt(...args) {
        return this.parent.encrypt(...args);
    }
    done() {
        return this.parent;
    }
}
class GeneralEncrypt {
    _plaintext;
    _recipients = [];
    _protectedHeader;
    _unprotectedHeader;
    _aad;
    constructor(plaintext){
        this._plaintext = plaintext;
    }
    addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, {
            crit: options?.crit
        });
        this._recipients.push(recipient);
        return recipient;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    async encrypt() {
        if (!this._recipients.length) {
            throw new errors_js_1.JWEInvalid('at least one recipient must be added');
        }
        if (this._recipients.length === 1) {
            const [recipient] = this._recipients;
            const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, {
                ...recipient.options
            });
            const jwe = {
                ciphertext: flattened.ciphertext,
                iv: flattened.iv,
                recipients: [
                    {}
                ],
                tag: flattened.tag
            };
            if (flattened.aad) jwe.aad = flattened.aad;
            if (flattened.protected) jwe.protected = flattened.protected;
            if (flattened.unprotected) jwe.unprotected = flattened.unprotected;
            if (flattened.encrypted_key) jwe.recipients[0].encrypted_key = flattened.encrypted_key;
            if (flattened.header) jwe.recipients[0].header = flattened.header;
            return jwe;
        }
        let enc;
        for(let i = 0; i < this._recipients.length; i++){
            const recipient = this._recipients[i];
            if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
                throw new errors_js_1.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
            }
            const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader
            };
            const { alg } = joseHeader;
            if (typeof alg !== 'string' || !alg) {
                throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
            }
            if (alg === 'dir' || alg === 'ECDH-ES') {
                throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
            }
            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {
                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
            }
            if (!enc) {
                enc = joseHeader.enc;
            } else if (enc !== joseHeader.enc) {
                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
            }
            (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
            if (joseHeader.zip !== undefined) {
                throw new errors_js_1.JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
            }
        }
        const cek = (0, cek_js_1.default)(enc);
        const jwe = {
            ciphertext: '',
            iv: '',
            recipients: [],
            tag: ''
        };
        for(let i = 0; i < this._recipients.length; i++){
            const recipient = this._recipients[i];
            const target = {};
            jwe.recipients.push(target);
            const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader
            };
            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;
            if (i === 0) {
                const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({
                    p2c
                }).encrypt(recipient.key, {
                    ...recipient.options,
                    [private_symbols_js_1.unprotected]: true
                });
                jwe.ciphertext = flattened.ciphertext;
                jwe.iv = flattened.iv;
                jwe.tag = flattened.tag;
                if (flattened.aad) jwe.aad = flattened.aad;
                if (flattened.protected) jwe.protected = flattened.protected;
                if (flattened.unprotected) jwe.unprotected = flattened.unprotected;
                target.encrypted_key = flattened.encrypted_key;
                if (flattened.header) target.header = flattened.header;
                continue;
            }
            const { encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(recipient.unprotectedHeader?.alg || this._protectedHeader?.alg || this._unprotectedHeader?.alg, enc, recipient.key, cek, {
                p2c
            });
            target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
            if (recipient.unprotectedHeader || parameters) target.header = {
                ...recipient.unprotectedHeader,
                ...parameters
            };
        }
        return jwe;
    }
}
exports.GeneralEncrypt = GeneralEncrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/dsa_digest.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = dsaDigest;
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
function dsaDigest(alg) {
    switch(alg){
        case 'PS256':
        case 'RS256':
        case 'ES256':
        case 'ES256K':
            return 'sha256';
        case 'PS384':
        case 'RS384':
        case 'ES384':
            return 'sha384';
        case 'PS512':
        case 'RS512':
        case 'ES512':
            return 'sha512';
        case 'EdDSA':
            return undefined;
        default:
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/node_key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = keyForCrypto;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const get_named_curve_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/get_named_curve.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const check_key_length_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/check_key_length.js [app-ssr] (ecmascript)");
const ecCurveAlgMap = new Map([
    [
        'ES256',
        'P-256'
    ],
    [
        'ES256K',
        'secp256k1'
    ],
    [
        'ES384',
        'P-384'
    ],
    [
        'ES512',
        'P-521'
    ]
]);
function keyForCrypto(alg, key) {
    let asymmetricKeyType;
    let asymmetricKeyDetails;
    let isJWK;
    if (key instanceof node_crypto_1.KeyObject) {
        asymmetricKeyType = key.asymmetricKeyType;
        asymmetricKeyDetails = key.asymmetricKeyDetails;
    } else {
        isJWK = true;
        switch(key.kty){
            case 'RSA':
                asymmetricKeyType = 'rsa';
                break;
            case 'EC':
                asymmetricKeyType = 'ec';
                break;
            case 'OKP':
                {
                    if (key.crv === 'Ed25519') {
                        asymmetricKeyType = 'ed25519';
                        break;
                    }
                    if (key.crv === 'Ed448') {
                        asymmetricKeyType = 'ed448';
                        break;
                    }
                    throw new TypeError('Invalid key for this operation, its crv must be Ed25519 or Ed448');
                }
            default:
                throw new TypeError('Invalid key for this operation, its kty must be RSA, OKP, or EC');
        }
    }
    let options;
    switch(alg){
        case 'EdDSA':
            if (![
                'ed25519',
                'ed448'
            ].includes(asymmetricKeyType)) {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');
            }
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            if (asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
            }
            (0, check_key_length_js_1.default)(key, alg);
            break;
        case 'PS256':
        case 'PS384':
        case 'PS512':
            if (asymmetricKeyType === 'rsa-pss') {
                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = asymmetricKeyDetails;
                const length = parseInt(alg.slice(-3), 10);
                if (hashAlgorithm !== undefined && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
                }
                if (saltLength !== undefined && saltLength > length >> 3) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
                }
            } else if (asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');
            }
            (0, check_key_length_js_1.default)(key, alg);
            options = {
                padding: node_crypto_1.constants.RSA_PKCS1_PSS_PADDING,
                saltLength: node_crypto_1.constants.RSA_PSS_SALTLEN_DIGEST
            };
            break;
        case 'ES256':
        case 'ES256K':
        case 'ES384':
        case 'ES512':
            {
                if (asymmetricKeyType !== 'ec') {
                    throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');
                }
                const actual = (0, get_named_curve_js_1.default)(key);
                const expected = ecCurveAlgMap.get(alg);
                if (actual !== expected) {
                    throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
                }
                options = {
                    dsaEncoding: 'ieee-p1363'
                };
                break;
            }
        default:
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    if (isJWK) {
        return {
            format: 'jwk',
            key,
            ...options
        };
    }
    return options ? {
        ...options,
        key
    } : key;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/hmac_digest.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = hmacDigest;
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
function hmacDigest(alg) {
    switch(alg){
        case 'HS256':
            return 'sha256';
        case 'HS384':
            return 'sha384';
        case 'HS512':
            return 'sha512';
        default:
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getSignVerifyKey;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const webcrypto_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/webcrypto.js [app-ssr] (ecmascript)");
const crypto_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/crypto_key.js [app-ssr] (ecmascript)");
const invalid_key_input_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js [app-ssr] (ecmascript)");
const is_key_like_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/is_key_like.js [app-ssr] (ecmascript)");
const jwk = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_jwk.js [app-ssr] (ecmascript)");
function getSignVerifyKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
        }
        return (0, node_crypto_1.createSecretKey)(key);
    }
    if (key instanceof node_crypto_1.KeyObject) {
        return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
        return node_crypto_1.KeyObject.from(key);
    }
    if (jwk.isJWK(key)) {
        if (alg.startsWith('HS')) {
            return (0, node_crypto_1.createSecretKey)(Buffer.from(key.k, 'base64url'));
        }
        return key;
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array', 'JSON Web Key'));
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/sign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const crypto = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_util_1 = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const dsa_digest_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/dsa_digest.js [app-ssr] (ecmascript)");
const hmac_digest_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/hmac_digest.js [app-ssr] (ecmascript)");
const node_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/node_key.js [app-ssr] (ecmascript)");
const get_sign_verify_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js [app-ssr] (ecmascript)");
const oneShotSign = (0, node_util_1.promisify)(crypto.sign);
const sign = async (alg, key, data)=>{
    const k = (0, get_sign_verify_key_js_1.default)(alg, key, 'sign');
    if (alg.startsWith('HS')) {
        const hmac = crypto.createHmac((0, hmac_digest_js_1.default)(alg), k);
        hmac.update(data);
        return hmac.digest();
    }
    return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, k));
};
exports.default = sign;
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const crypto = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_util_1 = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const dsa_digest_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/dsa_digest.js [app-ssr] (ecmascript)");
const node_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/node_key.js [app-ssr] (ecmascript)");
const sign_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/sign.js [app-ssr] (ecmascript)");
const get_sign_verify_key_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js [app-ssr] (ecmascript)");
const oneShotVerify = (0, node_util_1.promisify)(crypto.verify);
const verify = async (alg, key, signature, data)=>{
    const k = (0, get_sign_verify_key_js_1.default)(alg, key, 'verify');
    if (alg.startsWith('HS')) {
        const expected = await (0, sign_js_1.default)(alg, k, data);
        const actual = signature;
        try {
            return crypto.timingSafeEqual(actual, expected);
        } catch  {
            return false;
        }
    }
    const algorithm = (0, dsa_digest_js_1.default)(alg);
    const keyInput = (0, node_key_js_1.default)(alg, k);
    try {
        return await oneShotVerify(algorithm, data, keyInput, signature);
    } catch  {
        return false;
    }
};
exports.default = verify;
}}),
"[project]/node_modules/jose/dist/node/cjs/jws/flattened/verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.flattenedVerify = flattenedVerify;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const verify_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/verify.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const is_disjoint_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_disjoint.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const check_key_type_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_key_type.js [app-ssr] (ecmascript)");
const validate_crit_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_crit.js [app-ssr] (ecmascript)");
const validate_algorithms_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_algorithms.js [app-ssr] (ecmascript)");
const is_jwk_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_jwk.js [app-ssr] (ecmascript)");
const import_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/import.js [app-ssr] (ecmascript)");
async function flattenedVerify(jws, key, options) {
    if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid('Flattened JWS must be an object');
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
        throw new errors_js_1.JWSInvalid('JWS Protected Header incorrect type');
    }
    if (jws.payload === undefined) {
        throw new errors_js_1.JWSInvalid('JWS Payload missing');
    }
    if (typeof jws.signature !== 'string') {
        throw new errors_js_1.JWSInvalid('JWS Signature missing or incorrect type');
    }
    if (jws.header !== undefined && !(0, is_object_js_1.default)(jws.header)) {
        throw new errors_js_1.JWSInvalid('JWS Unprotected Header incorrect type');
    }
    let parsedProt = {};
    if (jws.protected) {
        try {
            const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
        } catch  {
            throw new errors_js_1.JWSInvalid('JWS Protected Header is invalid');
        }
    }
    if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
        throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header
    };
    const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([
        [
            'b64',
            true
        ]
    ]), options?.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') {
            throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && (0, validate_algorithms_js_1.default)('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== 'string') {
            throw new errors_js_1.JWSInvalid('JWS Payload must be a string');
        }
    } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
        throw new errors_js_1.JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
        (0, check_key_type_js_1.checkKeyTypeWithJwk)(alg, key, 'verify');
        if ((0, is_jwk_js_1.isJWK)(key)) {
            key = await (0, import_js_1.importJWK)(key, alg);
        }
    } else {
        (0, check_key_type_js_1.checkKeyTypeWithJwk)(alg, key, 'verify');
    }
    const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode(jws.protected ?? ''), buffer_utils_js_1.encoder.encode('.'), typeof jws.payload === 'string' ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
    let signature;
    try {
        signature = (0, base64url_js_1.decode)(jws.signature);
    } catch  {
        throw new errors_js_1.JWSInvalid('Failed to base64url decode the signature');
    }
    const verified = await (0, verify_js_1.default)(alg, key, signature, data);
    if (!verified) {
        throw new errors_js_1.JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        try {
            payload = (0, base64url_js_1.decode)(jws.payload);
        } catch  {
            throw new errors_js_1.JWSInvalid('Failed to base64url decode the payload');
        }
    } else if (typeof jws.payload === 'string') {
        payload = buffer_utils_js_1.encoder.encode(jws.payload);
    } else {
        payload = jws.payload;
    }
    const result = {
        payload
    };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return {
            ...result,
            key
        };
    }
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jws/compact/verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compactVerify = compactVerify;
const verify_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/flattened/verify.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = buffer_utils_js_1.decoder.decode(jws);
    }
    if (typeof jws !== 'string') {
        throw new errors_js_1.JWSInvalid('Compact JWS must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
    if (length !== 3) {
        throw new errors_js_1.JWSInvalid('Invalid Compact JWS');
    }
    const verified = await (0, verify_js_1.flattenedVerify)({
        payload,
        protected: protectedHeader,
        signature
    }, key, options);
    const result = {
        payload: verified.payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === 'function') {
        return {
            ...result,
            key: verified.key
        };
    }
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jws/general/verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generalVerify = generalVerify;
const verify_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/flattened/verify.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
async function generalVerify(jws, key, options) {
    if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid('General JWS must be an object');
    }
    if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
        throw new errors_js_1.JWSInvalid('JWS Signatures missing or incorrect type');
    }
    for (const signature of jws.signatures){
        try {
            return await (0, verify_js_1.flattenedVerify)({
                header: signature.header,
                payload: jws.payload,
                protected: signature.protected,
                signature: signature.signature
            }, key, options);
        } catch  {}
    }
    throw new errors_js_1.JWSSignatureVerificationFailed();
}
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/epoch.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = (date)=>Math.floor(date.getTime() / 1000);
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/secs.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
exports.default = (str)=>{
    const matched = REGEX.exec(str);
    if (!matched || matched[4] && matched[1]) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[2]);
    const unit = matched[3].toLowerCase();
    let numericDate;
    switch(unit){
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            numericDate = Math.round(value);
            break;
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            numericDate = Math.round(value * minute);
            break;
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            numericDate = Math.round(value * hour);
            break;
        case 'day':
        case 'days':
        case 'd':
            numericDate = Math.round(value * day);
            break;
        case 'week':
        case 'weeks':
        case 'w':
            numericDate = Math.round(value * week);
            break;
        default:
            numericDate = Math.round(value * year);
            break;
    }
    if (matched[1] === '-' || matched[4] === 'ago') {
        return -numericDate;
    }
    return numericDate;
};
}}),
"[project]/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const epoch_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/epoch.js [app-ssr] (ecmascript)");
const secs_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/secs.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const normalizeTyp = (value)=>value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption)=>{
    if (typeof audPayload === 'string') {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
exports.default = (protectedHeader, encodedPayload, options = {})=>{
    let payload;
    try {
        payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
    } catch  {}
    if (!(0, is_object_js_1.default)(payload)) {
        throw new errors_js_1.JWTInvalid('JWT Claims Set must be a top-level JSON object');
    }
    const { typ } = options;
    if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, 'typ', 'check_failed');
    }
    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
    const presenceCheck = [
        ...requiredClaims
    ];
    if (maxTokenAge !== undefined) presenceCheck.push('iat');
    if (audience !== undefined) presenceCheck.push('aud');
    if (subject !== undefined) presenceCheck.push('sub');
    if (issuer !== undefined) presenceCheck.push('iss');
    for (const claim of new Set(presenceCheck.reverse())){
        if (!(claim in payload)) {
            throw new errors_js_1.JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, 'missing');
        }
    }
    if (issuer && !(Array.isArray(issuer) ? issuer : [
        issuer
    ]).includes(payload.iss)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', payload, 'iss', 'check_failed');
    }
    if (subject && payload.sub !== subject) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', payload, 'sub', 'check_failed');
    }
    if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [
        audience
    ] : audience)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', payload, 'aud', 'check_failed');
    }
    let tolerance;
    switch(typeof options.clockTolerance){
        case 'string':
            tolerance = (0, secs_js_1.default)(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate } = options;
    const now = (0, epoch_js_1.default)(currentDate || new Date());
    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {
        throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', payload, 'iat', 'invalid');
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') {
            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', payload, 'nbf', 'invalid');
        }
        if (payload.nbf > now + tolerance) {
            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, 'nbf', 'check_failed');
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') {
            throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', payload, 'exp', 'invalid');
        }
        if (payload.exp <= now - tolerance) {
            throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', payload, 'exp', 'check_failed');
        }
    }
    if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === 'number' ? maxTokenAge : (0, secs_js_1.default)(maxTokenAge);
        if (age - tolerance > max) {
            throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');
        }
        if (age < 0 - tolerance) {
            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');
        }
    }
    return payload;
};
}}),
"[project]/node_modules/jose/dist/node/cjs/jwt/verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwtVerify = jwtVerify;
const verify_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/compact/verify.js [app-ssr] (ecmascript)");
const jwt_claims_set_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
async function jwtVerify(jwt, key, options) {
    const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {
        throw new errors_js_1.JWTInvalid('JWTs MUST NOT use unencoded payload');
    }
    const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
    const result = {
        payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === 'function') {
        return {
            ...result,
            key: verified.key
        };
    }
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jwt/decrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwtDecrypt = jwtDecrypt;
const decrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js [app-ssr] (ecmascript)");
const jwt_claims_set_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
async function jwtDecrypt(jwt, key, options) {
    const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
    const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
    const { protectedHeader } = decrypted;
    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', payload, 'iss', 'mismatch');
    }
    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', payload, 'sub', 'mismatch');
    }
    if (protectedHeader.aud !== undefined && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', payload, 'aud', 'mismatch');
    }
    const result = {
        payload,
        protectedHeader
    };
    if (typeof key === 'function') {
        return {
            ...result,
            key: decrypted.key
        };
    }
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompactEncrypt = void 0;
const encrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js [app-ssr] (ecmascript)");
class CompactEncrypt {
    _flattened;
    constructor(plaintext){
        this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
    }
    setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
    }
    setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
    }
    async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [
            jwe.protected,
            jwe.encrypted_key,
            jwe.iv,
            jwe.ciphertext,
            jwe.tag
        ].join('.');
    }
}
exports.CompactEncrypt = CompactEncrypt;
}}),
"[project]/node_modules/jose/dist/node/cjs/jws/flattened/sign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FlattenedSign = void 0;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const sign_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/sign.js [app-ssr] (ecmascript)");
const is_disjoint_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_disjoint.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const check_key_type_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/check_key_type.js [app-ssr] (ecmascript)");
const validate_crit_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/validate_crit.js [app-ssr] (ecmascript)");
class FlattenedSign {
    _payload;
    _protectedHeader;
    _unprotectedHeader;
    constructor(payload){
        if (!(payload instanceof Uint8Array)) {
            throw new TypeError('payload must be an instance of Uint8Array');
        }
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
            throw new errors_js_1.JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
            throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader
        };
        const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([
            [
                'b64',
                true
            ]
        ]), options?.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') {
                throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
        }
        const { alg } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        (0, check_key_type_js_1.checkKeyTypeWithJwk)(alg, key, 'sign');
        let payload = this._payload;
        if (b64) {
            payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        } else {
            protectedHeader = buffer_utils_js_1.encoder.encode('');
        }
        const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), payload);
        const signature = await (0, sign_js_1.default)(alg, key, data);
        const jws = {
            signature: (0, base64url_js_1.encode)(signature),
            payload: ''
        };
        if (b64) {
            jws.payload = buffer_utils_js_1.decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
            jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
            jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        return jws;
    }
}
exports.FlattenedSign = FlattenedSign;
}}),
"[project]/node_modules/jose/dist/node/cjs/jws/compact/sign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompactSign = void 0;
const sign_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/flattened/sign.js [app-ssr] (ecmascript)");
class CompactSign {
    _flattened;
    constructor(payload){
        this._flattened = new sign_js_1.FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) {
            throw new TypeError('use the flattened module for creating JWS with b64: false');
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}
exports.CompactSign = CompactSign;
}}),
"[project]/node_modules/jose/dist/node/cjs/jws/general/sign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeneralSign = void 0;
const sign_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/flattened/sign.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
class IndividualSignature {
    parent;
    protectedHeader;
    unprotectedHeader;
    options;
    key;
    constructor(sig, key, options){
        this.parent = sig;
        this.key = key;
        this.options = options;
    }
    setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this.protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
    }
    addSignature(...args) {
        return this.parent.addSignature(...args);
    }
    sign(...args) {
        return this.parent.sign(...args);
    }
    done() {
        return this.parent;
    }
}
class GeneralSign {
    _payload;
    _signatures = [];
    constructor(payload){
        this._payload = payload;
    }
    addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
    }
    async sign() {
        if (!this._signatures.length) {
            throw new errors_js_1.JWSInvalid('at least one signature must be added');
        }
        const jws = {
            signatures: [],
            payload: ''
        };
        for(let i = 0; i < this._signatures.length; i++){
            const signature = this._signatures[i];
            const flattened = new sign_js_1.FlattenedSign(this._payload);
            flattened.setProtectedHeader(signature.protectedHeader);
            flattened.setUnprotectedHeader(signature.unprotectedHeader);
            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
            if (i === 0) {
                jws.payload = payload;
            } else if (jws.payload !== payload) {
                throw new errors_js_1.JWSInvalid('inconsistent use of JWS Unencoded Payload (RFC7797)');
            }
            jws.signatures.push(rest);
        }
        return jws;
    }
}
exports.GeneralSign = GeneralSign;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwt/produce.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProduceJWT = void 0;
const epoch_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/epoch.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const secs_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/secs.js [app-ssr] (ecmascript)");
function validateInput(label, input) {
    if (!Number.isFinite(input)) {
        throw new TypeError(`Invalid ${label} input`);
    }
    return input;
}
class ProduceJWT {
    _payload;
    constructor(payload = {}){
        if (!(0, is_object_js_1.default)(payload)) {
            throw new TypeError('JWT Claims Set MUST be an object');
        }
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = {
            ...this._payload,
            iss: issuer
        };
        return this;
    }
    setSubject(subject) {
        this._payload = {
            ...this._payload,
            sub: subject
        };
        return this;
    }
    setAudience(audience) {
        this._payload = {
            ...this._payload,
            aud: audience
        };
        return this;
    }
    setJti(jwtId) {
        this._payload = {
            ...this._payload,
            jti: jwtId
        };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === 'number') {
            this._payload = {
                ...this._payload,
                nbf: validateInput('setNotBefore', input)
            };
        } else if (input instanceof Date) {
            this._payload = {
                ...this._payload,
                nbf: validateInput('setNotBefore', (0, epoch_js_1.default)(input))
            };
        } else {
            this._payload = {
                ...this._payload,
                nbf: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input)
            };
        }
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === 'number') {
            this._payload = {
                ...this._payload,
                exp: validateInput('setExpirationTime', input)
            };
        } else if (input instanceof Date) {
            this._payload = {
                ...this._payload,
                exp: validateInput('setExpirationTime', (0, epoch_js_1.default)(input))
            };
        } else {
            this._payload = {
                ...this._payload,
                exp: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input)
            };
        }
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === 'undefined') {
            this._payload = {
                ...this._payload,
                iat: (0, epoch_js_1.default)(new Date())
            };
        } else if (input instanceof Date) {
            this._payload = {
                ...this._payload,
                iat: validateInput('setIssuedAt', (0, epoch_js_1.default)(input))
            };
        } else if (typeof input === 'string') {
            this._payload = {
                ...this._payload,
                iat: validateInput('setIssuedAt', (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input))
            };
        } else {
            this._payload = {
                ...this._payload,
                iat: validateInput('setIssuedAt', input)
            };
        }
        return this;
    }
}
exports.ProduceJWT = ProduceJWT;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwt/sign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SignJWT = void 0;
const sign_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/compact/sign.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const produce_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/produce.js [app-ssr] (ecmascript)");
class SignJWT extends produce_js_1.ProduceJWT {
    _protectedHeader;
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes('b64') && this._protectedHeader.b64 === false) {
            throw new errors_js_1.JWTInvalid('JWTs MUST NOT use unencoded payload');
        }
        return sig.sign(key, options);
    }
}
exports.SignJWT = SignJWT;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwt/encrypt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EncryptJWT = void 0;
const encrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const produce_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/produce.js [app-ssr] (ecmascript)");
class EncryptJWT extends produce_js_1.ProduceJWT {
    _cek;
    _iv;
    _keyManagementParameters;
    _protectedHeader;
    _replicateIssuerAsHeader;
    _replicateSubjectAsHeader;
    _replicateAudienceAsHeader;
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError('setKeyManagementParameters can only be called once');
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError('setContentEncryptionKey can only be called once');
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError('setInitializationVector can only be called once');
        }
        this._iv = iv;
        return this;
    }
    replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
    }
    replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
    }
    replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
    }
    async encrypt(key, options) {
        const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
            this._protectedHeader = {
                ...this._protectedHeader,
                iss: this._payload.iss
            };
        }
        if (this._replicateSubjectAsHeader) {
            this._protectedHeader = {
                ...this._protectedHeader,
                sub: this._payload.sub
            };
        }
        if (this._replicateAudienceAsHeader) {
            this._protectedHeader = {
                ...this._protectedHeader,
                aud: this._payload.aud
            };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
            enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
            enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
            enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
    }
}
exports.EncryptJWT = EncryptJWT;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwk/thumbprint.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateJwkThumbprint = calculateJwkThumbprint;
exports.calculateJwkThumbprintUri = calculateJwkThumbprintUri;
const digest_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/digest.js [app-ssr] (ecmascript)");
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const check = (value, description)=>{
    if (typeof value !== 'string' || !value) {
        throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
    }
};
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
    if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    digestAlgorithm ??= 'sha256';
    if (digestAlgorithm !== 'sha256' && digestAlgorithm !== 'sha384' && digestAlgorithm !== 'sha512') {
        throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
    }
    let components;
    switch(jwk.kty){
        case 'EC':
            check(jwk.crv, '"crv" (Curve) Parameter');
            check(jwk.x, '"x" (X Coordinate) Parameter');
            check(jwk.y, '"y" (Y Coordinate) Parameter');
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x,
                y: jwk.y
            };
            break;
        case 'OKP':
            check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
            check(jwk.x, '"x" (Public Key) Parameter');
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x
            };
            break;
        case 'RSA':
            check(jwk.e, '"e" (Exponent) Parameter');
            check(jwk.n, '"n" (Modulus) Parameter');
            components = {
                e: jwk.e,
                kty: jwk.kty,
                n: jwk.n
            };
            break;
        case 'oct':
            check(jwk.k, '"k" (Key Value) Parameter');
            components = {
                k: jwk.k,
                kty: jwk.kty
            };
            break;
        default:
            throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components));
    return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
    digestAlgorithm ??= 'sha256';
    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jwk/embedded.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbeddedJWK = EmbeddedJWK;
const import_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/import.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
async function EmbeddedJWK(protectedHeader, token) {
    const joseHeader = {
        ...protectedHeader,
        ...token?.header
    };
    if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
    }
    const key = await (0, import_js_1.importJWK)({
        ...joseHeader.jwk,
        ext: true
    }, joseHeader.alg);
    if (key instanceof Uint8Array || key.type !== 'public') {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
    }
    return key;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/jwks/local.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createLocalJWKSet = createLocalJWKSet;
const import_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/import.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
function getKtyFromAlg(alg) {
    switch(typeof alg === 'string' && alg.slice(0, 2)){
        case 'RS':
        case 'PS':
            return 'RSA';
        case 'ES':
            return 'EC';
        case 'Ed':
            return 'OKP';
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
    }
}
function isJWKSLike(jwks) {
    return jwks && typeof jwks === 'object' && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
    return (0, is_object_js_1.default)(key);
}
function clone(obj) {
    if (typeof structuredClone === 'function') {
        return structuredClone(obj);
    }
    return JSON.parse(JSON.stringify(obj));
}
class LocalJWKSet {
    _jwks;
    _cached = new WeakMap();
    constructor(jwks){
        if (!isJWKSLike(jwks)) {
            throw new errors_js_1.JWKSInvalid('JSON Web Key Set malformed');
        }
        this._jwks = clone(jwks);
    }
    async getKey(protectedHeader, token) {
        const { alg, kid } = {
            ...protectedHeader,
            ...token?.header
        };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk)=>{
            let candidate = kty === jwk.kty;
            if (candidate && typeof kid === 'string') {
                candidate = kid === jwk.kid;
            }
            if (candidate && typeof jwk.alg === 'string') {
                candidate = alg === jwk.alg;
            }
            if (candidate && typeof jwk.use === 'string') {
                candidate = jwk.use === 'sig';
            }
            if (candidate && Array.isArray(jwk.key_ops)) {
                candidate = jwk.key_ops.includes('verify');
            }
            if (candidate && alg === 'EdDSA') {
                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';
            }
            if (candidate) {
                switch(alg){
                    case 'ES256':
                        candidate = jwk.crv === 'P-256';
                        break;
                    case 'ES256K':
                        candidate = jwk.crv === 'secp256k1';
                        break;
                    case 'ES384':
                        candidate = jwk.crv === 'P-384';
                        break;
                    case 'ES512':
                        candidate = jwk.crv === 'P-521';
                        break;
                }
            }
            return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
            throw new errors_js_1.JWKSNoMatchingKey();
        }
        if (length !== 1) {
            const error = new errors_js_1.JWKSMultipleMatchingKeys();
            const { _cached } = this;
            error[Symbol.asyncIterator] = async function*() {
                for (const jwk of candidates){
                    try {
                        yield await importWithAlgCache(_cached, jwk, alg);
                    } catch  {}
                }
            };
            throw error;
        }
        return importWithAlgCache(this._cached, jwk, alg);
    }
}
async function importWithAlgCache(cache, jwk, alg) {
    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
    if (cached[alg] === undefined) {
        const key = await (0, import_js_1.importJWK)({
            ...jwk,
            ext: true
        }, alg);
        if (key instanceof Uint8Array || key.type !== 'public') {
            throw new errors_js_1.JWKSInvalid('JSON Web Key Set members must be public keys');
        }
        cached[alg] = key;
    }
    return cached[alg];
}
function createLocalJWKSet(jwks) {
    const set = new LocalJWKSet(jwks);
    const localJWKSet = async (protectedHeader, token)=>set.getKey(protectedHeader, token);
    Object.defineProperties(localJWKSet, {
        jwks: {
            value: ()=>clone(set._jwks),
            enumerable: true,
            configurable: false,
            writable: false
        }
    });
    return localJWKSet;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const http = __turbopack_require__("[externals]/node:http [external] (node:http, cjs)");
const https = __turbopack_require__("[externals]/node:https [external] (node:https, cjs)");
const node_events_1 = __turbopack_require__("[externals]/node:events [external] (node:events, cjs)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const fetchJwks = async (url, timeout, options)=>{
    let get;
    switch(url.protocol){
        case 'https:':
            get = https.get;
            break;
        case 'http:':
            get = http.get;
            break;
        default:
            throw new TypeError('Unsupported URL protocol.');
    }
    const { agent, headers } = options;
    const req = get(url.href, {
        agent,
        timeout,
        headers
    });
    const [response] = await Promise.race([
        (0, node_events_1.once)(req, 'response'),
        (0, node_events_1.once)(req, 'timeout')
    ]);
    if (!response) {
        req.destroy();
        throw new errors_js_1.JWKSTimeout();
    }
    if (response.statusCode !== 200) {
        throw new errors_js_1.JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');
    }
    const parts = [];
    for await (const part of response){
        parts.push(part);
    }
    try {
        return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
    } catch  {
        throw new errors_js_1.JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');
    }
};
exports.default = fetchJwks;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwks/remote.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.experimental_jwksCache = exports.jwksCache = void 0;
exports.createRemoteJWKSet = createRemoteJWKSet;
const fetch_jwks_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const local_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwks/local.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
function isCloudflareWorkers() {
    return typeof WebSocketPair !== 'undefined' || typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers' || typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel';
}
let USER_AGENT;
if (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {
    const NAME = 'jose';
    const VERSION = 'v5.9.6';
    USER_AGENT = `${NAME}/${VERSION}`;
}
exports.jwksCache = Symbol();
function isFreshJwksCache(input, cacheMaxAge) {
    if (typeof input !== 'object' || input === null) {
        return false;
    }
    if (!('uat' in input) || typeof input.uat !== 'number' || Date.now() - input.uat >= cacheMaxAge) {
        return false;
    }
    if (!('jwks' in input) || !(0, is_object_js_1.default)(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, is_object_js_1.default)) {
        return false;
    }
    return true;
}
class RemoteJWKSet {
    _url;
    _timeoutDuration;
    _cooldownDuration;
    _cacheMaxAge;
    _jwksTimestamp;
    _pendingFetch;
    _options;
    _local;
    _cache;
    constructor(url, options){
        if (!(url instanceof URL)) {
            throw new TypeError('url must be an instance of URL');
        }
        this._url = new URL(url.href);
        this._options = {
            agent: options?.agent,
            headers: options?.headers
        };
        this._timeoutDuration = typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;
        this._cooldownDuration = typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;
        this._cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;
        if (options?.[exports.jwksCache] !== undefined) {
            this._cache = options?.[exports.jwksCache];
            if (isFreshJwksCache(options?.[exports.jwksCache], this._cacheMaxAge)) {
                this._jwksTimestamp = this._cache.uat;
                this._local = (0, local_js_1.createLocalJWKSet)(this._cache.jwks);
            }
        }
    }
    coolingDown() {
        return typeof this._jwksTimestamp === 'number' ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
    }
    fresh() {
        return typeof this._jwksTimestamp === 'number' ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
    }
    async getKey(protectedHeader, token) {
        if (!this._local || !this.fresh()) {
            await this.reload();
        }
        try {
            return await this._local(protectedHeader, token);
        } catch (err) {
            if (err instanceof errors_js_1.JWKSNoMatchingKey) {
                if (this.coolingDown() === false) {
                    await this.reload();
                    return this._local(protectedHeader, token);
                }
            }
            throw err;
        }
    }
    async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
            this._pendingFetch = undefined;
        }
        const headers = new Headers(this._options.headers);
        if (USER_AGENT && !headers.has('User-Agent')) {
            headers.set('User-Agent', USER_AGENT);
            this._options.headers = Object.fromEntries(headers.entries());
        }
        this._pendingFetch ||= (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options).then((json)=>{
            this._local = (0, local_js_1.createLocalJWKSet)(json);
            if (this._cache) {
                this._cache.uat = Date.now();
                this._cache.jwks = json;
            }
            this._jwksTimestamp = Date.now();
            this._pendingFetch = undefined;
        }).catch((err)=>{
            this._pendingFetch = undefined;
            throw err;
        });
        await this._pendingFetch;
    }
}
function createRemoteJWKSet(url, options) {
    const set = new RemoteJWKSet(url, options);
    const remoteJWKSet = async (protectedHeader, token)=>set.getKey(protectedHeader, token);
    Object.defineProperties(remoteJWKSet, {
        coolingDown: {
            get: ()=>set.coolingDown(),
            enumerable: true,
            configurable: false
        },
        fresh: {
            get: ()=>set.fresh(),
            enumerable: true,
            configurable: false
        },
        reload: {
            value: ()=>set.reload(),
            enumerable: true,
            configurable: false,
            writable: false
        },
        reloading: {
            get: ()=>!!set._pendingFetch,
            enumerable: true,
            configurable: false
        },
        jwks: {
            value: ()=>set._local?.jwks(),
            enumerable: true,
            configurable: false,
            writable: false
        }
    });
    return remoteJWKSet;
}
exports.experimental_jwksCache = exports.jwksCache;
}}),
"[project]/node_modules/jose/dist/node/cjs/jwt/unsecured.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnsecuredJWT = void 0;
const base64url = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const jwt_claims_set_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js [app-ssr] (ecmascript)");
const produce_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/produce.js [app-ssr] (ecmascript)");
class UnsecuredJWT extends produce_js_1.ProduceJWT {
    encode() {
        const header = base64url.encode(JSON.stringify({
            alg: 'none'
        }));
        const payload = base64url.encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
    }
    static decode(jwt, options) {
        if (typeof jwt !== 'string') {
            throw new errors_js_1.JWTInvalid('Unsecured JWT must be a string');
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
        if (length !== 3 || signature !== '') {
            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
        }
        let header;
        try {
            header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
            if (header.alg !== 'none') throw new Error();
        } catch  {
            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
        }
        const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
        return {
            payload,
            header
        };
    }
}
exports.UnsecuredJWT = UnsecuredJWT;
}}),
"[project]/node_modules/jose/dist/node/cjs/util/base64url.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decode = exports.encode = void 0;
const base64url = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/base64url.js [app-ssr] (ecmascript)");
exports.encode = base64url.encode;
exports.decode = base64url.decode;
}}),
"[project]/node_modules/jose/dist/node/cjs/util/decode_protected_header.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeProtectedHeader = decodeProtectedHeader;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/base64url.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
function decodeProtectedHeader(token) {
    let protectedB64u;
    if (typeof token === 'string') {
        const parts = token.split('.');
        if (parts.length === 3 || parts.length === 5) {
            ;
            [protectedB64u] = parts;
        }
    } else if (typeof token === 'object' && token) {
        if ('protected' in token) {
            protectedB64u = token.protected;
        } else {
            throw new TypeError('Token does not contain a Protected Header');
        }
    }
    try {
        if (typeof protectedB64u !== 'string' || !protectedB64u) {
            throw new Error();
        }
        const result = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
        if (!(0, is_object_js_1.default)(result)) {
            throw new Error();
        }
        return result;
    } catch  {
        throw new TypeError('Invalid Token or Protected Header formatting');
    }
}
}}),
"[project]/node_modules/jose/dist/node/cjs/util/decode_jwt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeJwt = decodeJwt;
const base64url_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/base64url.js [app-ssr] (ecmascript)");
const buffer_utils_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/buffer_utils.js [app-ssr] (ecmascript)");
const is_object_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/lib/is_object.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
function decodeJwt(jwt) {
    if (typeof jwt !== 'string') throw new errors_js_1.JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');
    const { 1: payload, length } = jwt.split('.');
    if (length === 5) throw new errors_js_1.JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');
    if (length !== 3) throw new errors_js_1.JWTInvalid('Invalid JWT');
    if (!payload) throw new errors_js_1.JWTInvalid('JWTs must contain a payload');
    let decoded;
    try {
        decoded = (0, base64url_js_1.decode)(payload);
    } catch  {
        throw new errors_js_1.JWTInvalid('Failed to base64url decode the payload');
    }
    let result;
    try {
        result = JSON.parse(buffer_utils_js_1.decoder.decode(decoded));
    } catch  {
        throw new errors_js_1.JWTInvalid('Failed to parse the decoded payload as JSON');
    }
    if (!(0, is_object_js_1.default)(result)) throw new errors_js_1.JWTInvalid('Invalid JWT Claims Set');
    return result;
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/generate.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateSecret = generateSecret;
exports.generateKeyPair = generateKeyPair;
const node_crypto_1 = __turbopack_require__("[externals]/node:crypto [external] (node:crypto, cjs)");
const node_util_1 = __turbopack_require__("[externals]/node:util [external] (node:util, cjs)");
const random_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/random.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
const generate = (0, node_util_1.promisify)(node_crypto_1.generateKeyPair);
async function generateSecret(alg, options) {
    let length;
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            length = parseInt(alg.slice(-3), 10);
            break;
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            length = parseInt(alg.slice(1, 4), 10);
            break;
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (0, node_crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length >> 3)));
}
async function generateKeyPair(alg, options) {
    switch(alg){
        case 'RS256':
        case 'RS384':
        case 'RS512':
        case 'PS256':
        case 'PS384':
        case 'PS512':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
        case 'RSA1_5':
            {
                const modulusLength = options?.modulusLength ?? 2048;
                if (typeof modulusLength !== 'number' || modulusLength < 2048) {
                    throw new errors_js_1.JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');
                }
                const keypair = await generate('rsa', {
                    modulusLength,
                    publicExponent: 0x10001
                });
                return keypair;
            }
        case 'ES256':
            return generate('ec', {
                namedCurve: 'P-256'
            });
        case 'ES256K':
            return generate('ec', {
                namedCurve: 'secp256k1'
            });
        case 'ES384':
            return generate('ec', {
                namedCurve: 'P-384'
            });
        case 'ES512':
            return generate('ec', {
                namedCurve: 'P-521'
            });
        case 'EdDSA':
            {
                switch(options?.crv){
                    case undefined:
                    case 'Ed25519':
                        return generate('ed25519');
                    case 'Ed448':
                        return generate('ed448');
                    default:
                        throw new errors_js_1.JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');
                }
            }
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                const crv = options?.crv ?? 'P-256';
                switch(crv){
                    case undefined:
                    case 'P-256':
                    case 'P-384':
                    case 'P-521':
                        return generate('ec', {
                            namedCurve: crv
                        });
                    case 'X25519':
                        return generate('x25519');
                    case 'X448':
                        return generate('x448');
                    default:
                        throw new errors_js_1.JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');
                }
            }
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
}
}}),
"[project]/node_modules/jose/dist/node/cjs/key/generate_key_pair.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateKeyPair = generateKeyPair;
const generate_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/generate.js [app-ssr] (ecmascript)");
async function generateKeyPair(alg, options) {
    return (0, generate_js_1.generateKeyPair)(alg, options);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/key/generate_secret.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateSecret = generateSecret;
const generate_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/generate.js [app-ssr] (ecmascript)");
async function generateSecret(alg, options) {
    return (0, generate_js_1.generateSecret)(alg, options);
}
}}),
"[project]/node_modules/jose/dist/node/cjs/runtime/runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = 'node:crypto';
}}),
"[project]/node_modules/jose/dist/node/cjs/util/runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const runtime_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/runtime/runtime.js [app-ssr] (ecmascript)");
exports.default = runtime_js_1.default;
}}),
"[project]/node_modules/jose/dist/node/cjs/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cryptoRuntime = exports.base64url = exports.generateSecret = exports.generateKeyPair = exports.errors = exports.decodeJwt = exports.decodeProtectedHeader = exports.importJWK = exports.importX509 = exports.importPKCS8 = exports.importSPKI = exports.exportJWK = exports.exportSPKI = exports.exportPKCS8 = exports.UnsecuredJWT = exports.experimental_jwksCache = exports.jwksCache = exports.createRemoteJWKSet = exports.createLocalJWKSet = exports.EmbeddedJWK = exports.calculateJwkThumbprintUri = exports.calculateJwkThumbprint = exports.EncryptJWT = exports.SignJWT = exports.GeneralSign = exports.FlattenedSign = exports.CompactSign = exports.FlattenedEncrypt = exports.CompactEncrypt = exports.jwtDecrypt = exports.jwtVerify = exports.generalVerify = exports.flattenedVerify = exports.compactVerify = exports.GeneralEncrypt = exports.generalDecrypt = exports.flattenedDecrypt = exports.compactDecrypt = void 0;
var decrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "compactDecrypt", {
    enumerable: true,
    get: function() {
        return decrypt_js_1.compactDecrypt;
    }
});
var decrypt_js_2 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "flattenedDecrypt", {
    enumerable: true,
    get: function() {
        return decrypt_js_2.flattenedDecrypt;
    }
});
var decrypt_js_3 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/general/decrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "generalDecrypt", {
    enumerable: true,
    get: function() {
        return decrypt_js_3.generalDecrypt;
    }
});
var encrypt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/general/encrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "GeneralEncrypt", {
    enumerable: true,
    get: function() {
        return encrypt_js_1.GeneralEncrypt;
    }
});
var verify_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/compact/verify.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "compactVerify", {
    enumerable: true,
    get: function() {
        return verify_js_1.compactVerify;
    }
});
var verify_js_2 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/flattened/verify.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "flattenedVerify", {
    enumerable: true,
    get: function() {
        return verify_js_2.flattenedVerify;
    }
});
var verify_js_3 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/general/verify.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "generalVerify", {
    enumerable: true,
    get: function() {
        return verify_js_3.generalVerify;
    }
});
var verify_js_4 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/verify.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "jwtVerify", {
    enumerable: true,
    get: function() {
        return verify_js_4.jwtVerify;
    }
});
var decrypt_js_4 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/decrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "jwtDecrypt", {
    enumerable: true,
    get: function() {
        return decrypt_js_4.jwtDecrypt;
    }
});
var encrypt_js_2 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "CompactEncrypt", {
    enumerable: true,
    get: function() {
        return encrypt_js_2.CompactEncrypt;
    }
});
var encrypt_js_3 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FlattenedEncrypt", {
    enumerable: true,
    get: function() {
        return encrypt_js_3.FlattenedEncrypt;
    }
});
var sign_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/compact/sign.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "CompactSign", {
    enumerable: true,
    get: function() {
        return sign_js_1.CompactSign;
    }
});
var sign_js_2 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/flattened/sign.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FlattenedSign", {
    enumerable: true,
    get: function() {
        return sign_js_2.FlattenedSign;
    }
});
var sign_js_3 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jws/general/sign.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "GeneralSign", {
    enumerable: true,
    get: function() {
        return sign_js_3.GeneralSign;
    }
});
var sign_js_4 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/sign.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "SignJWT", {
    enumerable: true,
    get: function() {
        return sign_js_4.SignJWT;
    }
});
var encrypt_js_4 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/encrypt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "EncryptJWT", {
    enumerable: true,
    get: function() {
        return encrypt_js_4.EncryptJWT;
    }
});
var thumbprint_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwk/thumbprint.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "calculateJwkThumbprint", {
    enumerable: true,
    get: function() {
        return thumbprint_js_1.calculateJwkThumbprint;
    }
});
Object.defineProperty(exports, "calculateJwkThumbprintUri", {
    enumerable: true,
    get: function() {
        return thumbprint_js_1.calculateJwkThumbprintUri;
    }
});
var embedded_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwk/embedded.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "EmbeddedJWK", {
    enumerable: true,
    get: function() {
        return embedded_js_1.EmbeddedJWK;
    }
});
var local_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwks/local.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "createLocalJWKSet", {
    enumerable: true,
    get: function() {
        return local_js_1.createLocalJWKSet;
    }
});
var remote_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwks/remote.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "createRemoteJWKSet", {
    enumerable: true,
    get: function() {
        return remote_js_1.createRemoteJWKSet;
    }
});
Object.defineProperty(exports, "jwksCache", {
    enumerable: true,
    get: function() {
        return remote_js_1.jwksCache;
    }
});
Object.defineProperty(exports, "experimental_jwksCache", {
    enumerable: true,
    get: function() {
        return remote_js_1.experimental_jwksCache;
    }
});
var unsecured_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/jwt/unsecured.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UnsecuredJWT", {
    enumerable: true,
    get: function() {
        return unsecured_js_1.UnsecuredJWT;
    }
});
var export_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/export.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "exportPKCS8", {
    enumerable: true,
    get: function() {
        return export_js_1.exportPKCS8;
    }
});
Object.defineProperty(exports, "exportSPKI", {
    enumerable: true,
    get: function() {
        return export_js_1.exportSPKI;
    }
});
Object.defineProperty(exports, "exportJWK", {
    enumerable: true,
    get: function() {
        return export_js_1.exportJWK;
    }
});
var import_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/import.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "importSPKI", {
    enumerable: true,
    get: function() {
        return import_js_1.importSPKI;
    }
});
Object.defineProperty(exports, "importPKCS8", {
    enumerable: true,
    get: function() {
        return import_js_1.importPKCS8;
    }
});
Object.defineProperty(exports, "importX509", {
    enumerable: true,
    get: function() {
        return import_js_1.importX509;
    }
});
Object.defineProperty(exports, "importJWK", {
    enumerable: true,
    get: function() {
        return import_js_1.importJWK;
    }
});
var decode_protected_header_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/decode_protected_header.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "decodeProtectedHeader", {
    enumerable: true,
    get: function() {
        return decode_protected_header_js_1.decodeProtectedHeader;
    }
});
var decode_jwt_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/decode_jwt.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "decodeJwt", {
    enumerable: true,
    get: function() {
        return decode_jwt_js_1.decodeJwt;
    }
});
exports.errors = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/errors.js [app-ssr] (ecmascript)");
var generate_key_pair_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/generate_key_pair.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "generateKeyPair", {
    enumerable: true,
    get: function() {
        return generate_key_pair_js_1.generateKeyPair;
    }
});
var generate_secret_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/key/generate_secret.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "generateSecret", {
    enumerable: true,
    get: function() {
        return generate_secret_js_1.generateSecret;
    }
});
exports.base64url = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/base64url.js [app-ssr] (ecmascript)");
var runtime_js_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/util/runtime.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "cryptoRuntime", {
    enumerable: true,
    get: function() {
        return runtime_js_1.default;
    }
});
}}),
"[project]/node_modules/@atproto/jwk-jose/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.either = either;
function either(a, b) {
    if (a != null && b != null && a !== b) {
        throw new TypeError(`Expected "${b}", got "${a}"`);
    }
    return a ?? b ?? undefined;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/jwk-jose/dist/jose-key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JoseKey = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const jose_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-jose/dist/util.js [app-ssr] (ecmascript)");
const { JOSEError } = jose_1.errors;
class JoseKey extends jwk_1.Key {
    /**
     * Some runtimes (e.g. Bun) require an `alg` second argument to be set when
     * invoking `importJWK`. In order to be compatible with these runtimes, we
     * provide the following method to ensure the `alg` is always set. We also
     * take the opportunity to ensure that the `alg` is compatible with this key.
     */ async getKeyObj(alg) {
        if (!this.algorithms.includes(alg)) {
            throw new jwk_1.JwkError(`Key cannot be used with algorithm "${alg}"`);
        }
        try {
            return await (0, jose_1.importJWK)(this.jwk, alg);
        } catch (cause) {
            throw new jwk_1.JwkError('Failed to import JWK', undefined, {
                cause
            });
        }
    }
    async createJwt(header, payload) {
        try {
            const { kid } = header;
            if (kid && kid !== this.kid) {
                throw new jwk_1.JwtCreateError(`Invalid "kid" (${kid}) used to sign with key "${this.kid}"`);
            }
            const { alg } = header;
            if (!alg) {
                throw new jwk_1.JwtCreateError('Missing "alg" in JWT header');
            }
            const keyObj = await this.getKeyObj(alg);
            const jwtBuilder = new jose_1.SignJWT(payload).setProtectedHeader({
                ...header,
                alg,
                kid: this.kid
            });
            const signedJwt = await jwtBuilder.sign(keyObj);
            return signedJwt;
        } catch (cause) {
            if (cause instanceof JOSEError) {
                throw new jwk_1.JwtCreateError(cause.message, cause.code, {
                    cause
                });
            } else {
                throw jwk_1.JwtCreateError.from(cause);
            }
        }
    }
    async verifyJwt(token, options) {
        try {
            const result = await (0, jose_1.jwtVerify)(token, async ({ alg })=>this.getKeyObj(alg), {
                ...options,
                algorithms: this.algorithms
            });
            // @NOTE if all tokens are signed exclusively through createJwt(), then
            // there should be no need to parse the payload and headers here. But
            // since the JWT could have been signed with the same key from somewhere
            // else, let's parse it to ensure the integrity (and type safety) of the
            // data.
            const headerParsed = jwk_1.jwtHeaderSchema.safeParse(result.protectedHeader);
            if (!headerParsed.success) {
                throw new jwk_1.JwtVerifyError('Invalid JWT header', undefined, {
                    cause: headerParsed.error
                });
            }
            const payloadParsed = jwk_1.jwtPayloadSchema.safeParse(result.payload);
            if (!payloadParsed.success) {
                throw new jwk_1.JwtVerifyError('Invalid JWT payload', undefined, {
                    cause: payloadParsed.error
                });
            }
            return {
                protectedHeader: headerParsed.data,
                // "requiredClaims" enforced by jwtVerify()
                payload: payloadParsed.data
            };
        } catch (cause) {
            if (cause instanceof JOSEError) {
                throw new jwk_1.JwtVerifyError(cause.message, cause.code, {
                    cause
                });
            } else {
                throw jwk_1.JwtVerifyError.from(cause);
            }
        }
    }
    static async generateKeyPair(allowedAlgos = [
        'ES256'
    ], options) {
        if (!allowedAlgos.length) {
            throw new jwk_1.JwkError('No algorithms provided for key generation');
        }
        const errors = [];
        for (const alg of allowedAlgos){
            try {
                return await (0, jose_1.generateKeyPair)(alg, options);
            } catch (err) {
                errors.push(err);
            }
        }
        throw new jwk_1.JwkError('Failed to generate key pair', undefined, {
            cause: new AggregateError(errors, 'None of the algorithms worked')
        });
    }
    static async generate(allowedAlgos = [
        'ES256'
    ], kid, options) {
        const kp = await this.generateKeyPair(allowedAlgos, {
            ...options,
            extractable: true
        });
        return this.fromImportable(kp.privateKey, kid);
    }
    static async fromImportable(input, kid) {
        if (typeof input === 'string') {
            // PKCS8
            if (input.startsWith('-----')) {
                // The "alg" is only needed in WebCrypto (NodeJS will be fine)
                return this.fromPKCS8(input, '', kid);
            }
            // Jwk (string)
            if (input.startsWith('{')) {
                return this.fromJWK(input, kid);
            }
            throw new jwk_1.JwkError('Invalid input');
        }
        if (typeof input === 'object') {
            // Jwk
            if ('kty' in input || 'alg' in input) {
                return this.fromJWK(input, kid);
            }
            // KeyLike
            return this.fromKeyLike(input, kid);
        }
        throw new jwk_1.JwkError('Invalid input');
    }
    /**
     * @see {@link exportJWK}
     */ static async fromKeyLike(keyLike, kid, alg) {
        const jwk = await (0, jose_1.exportJWK)(keyLike);
        if (alg) {
            if (!jwk.alg) jwk.alg = alg;
            else if (jwk.alg !== alg) throw new jwk_1.JwkError('Invalid "alg" in JWK');
        }
        return this.fromJWK(jwk, kid);
    }
    /**
     * @see {@link importPKCS8}
     */ static async fromPKCS8(pem, alg, kid) {
        const keyLike = await (0, jose_1.importPKCS8)(pem, alg, {
            extractable: true
        });
        return this.fromKeyLike(keyLike, kid);
    }
    static async fromJWK(input, inputKid) {
        const jwk = typeof input === 'string' ? JSON.parse(input) : input;
        if (!jwk || typeof jwk !== 'object') throw new jwk_1.JwkError('Invalid JWK');
        const kid = (0, util_1.either)(jwk.kid, inputKid);
        const use = jwk.use || 'sig';
        return new JoseKey(jwk_1.jwkValidator.parse({
            ...jwk,
            kid,
            use
        }));
    }
}
exports.JoseKey = JoseKey; //# sourceMappingURL=jose-key.js.map
}}),
"[project]/node_modules/@atproto/jwk-jose/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk-jose/dist/jose-key.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/jwk-webcrypto/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toSubtleAlgorithm = toSubtleAlgorithm;
exports.fromSubtleAlgorithm = fromSubtleAlgorithm;
exports.isCryptoKeyPair = isCryptoKeyPair;
function toSubtleAlgorithm(alg, crv, options) {
    switch(alg){
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                name: 'RSA-PSS',
                hash: `SHA-${alg.slice(-3)}`,
                modulusLength: options?.modulusLength ?? 2048,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ])
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.slice(-3)}`,
                modulusLength: options?.modulusLength ?? 2048,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ])
            };
        case 'ES256':
        case 'ES384':
            return {
                name: 'ECDSA',
                namedCurve: `P-${alg.slice(-3)}`
            };
        case 'ES512':
            return {
                name: 'ECDSA',
                namedCurve: 'P-521'
            };
        default:
            // https://github.com/w3c/webcrypto/issues/82#issuecomment-849856773
            throw new TypeError(`Unsupported alg "${alg}"`);
    }
}
function fromSubtleAlgorithm(algorithm) {
    switch(algorithm.name){
        case 'RSA-PSS':
        case 'RSASSA-PKCS1-v1_5':
            {
                const hash = algorithm.hash.name;
                switch(hash){
                    case 'SHA-256':
                    case 'SHA-384':
                    case 'SHA-512':
                        {
                            const prefix = algorithm.name === 'RSA-PSS' ? 'PS' : 'RS';
                            return `${prefix}${hash.slice(-3)}`;
                        }
                    default:
                        throw new TypeError('unsupported RsaHashedKeyAlgorithm hash');
                }
            }
        case 'ECDSA':
            {
                const namedCurve = algorithm.namedCurve;
                switch(namedCurve){
                    case 'P-256':
                    case 'P-384':
                    case 'P-512':
                        return `ES${namedCurve.slice(-3)}`;
                    case 'P-521':
                        return 'ES512';
                    default:
                        throw new TypeError('unsupported EcKeyAlgorithm namedCurve');
                }
            }
        case 'Ed448':
        case 'Ed25519':
            return 'EdDSA';
        default:
            // https://github.com/w3c/webcrypto/issues/82#issuecomment-849856773
            throw new TypeError(`Unexpected algorithm "${algorithm.name}"`);
    }
}
function isCryptoKeyPair(v, extractable) {
    return typeof v === 'object' && v !== null && 'privateKey' in v && v.privateKey instanceof CryptoKey && v.privateKey.type === 'private' && (extractable == null || v.privateKey.extractable === extractable) && v.privateKey.usages.includes('sign') && 'publicKey' in v && v.publicKey instanceof CryptoKey && v.publicKey.type === 'public' && v.publicKey.extractable === true && v.publicKey.usages.includes('verify');
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/jwk-webcrypto/dist/webcrypto-key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebcryptoKey = exports.jwkWithAlgSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const jwk_jose_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-jose/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __importDefault(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)"));
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/util.js [app-ssr] (ecmascript)");
// Webcrypto keys are bound to a single algorithm
exports.jwkWithAlgSchema = zod_1.default.intersection(jwk_1.jwkSchema, zod_1.default.object({
    alg: zod_1.default.string()
}));
class WebcryptoKey extends jwk_jose_1.JoseKey {
    // We need to override the static method generate from JoseKey because
    // the browser needs both the private and public keys
    static async generate(allowedAlgos = [
        'ES256'
    ], kid = crypto.randomUUID(), options) {
        const keyPair = await this.generateKeyPair(allowedAlgos, options);
        // Type safety only: in the browser, 'jose' always generates a CryptoKeyPair
        if (!(0, util_js_1.isCryptoKeyPair)(keyPair)) {
            throw new TypeError('Invalid CryptoKeyPair');
        }
        return this.fromKeypair(keyPair, kid);
    }
    static async fromKeypair(cryptoKeyPair, kid) {
        // https://datatracker.ietf.org/doc/html/rfc7517
        // > The "use" and "key_ops" JWK members SHOULD NOT be used together; [...]
        // > Applications should specify which of these members they use.
        const { key_ops, use, alg = (0, util_js_1.fromSubtleAlgorithm)(cryptoKeyPair.privateKey.algorithm), ...jwk } = await crypto.subtle.exportKey('jwk', cryptoKeyPair.privateKey.extractable ? cryptoKeyPair.privateKey : cryptoKeyPair.publicKey);
        if (use && use !== 'sig') {
            throw new TypeError(`Unsupported JWK use "${use}"`);
        }
        if (key_ops && !key_ops.some((o)=>o === 'sign' || o === 'verify')) {
            // Make sure that "key_ops", if present, is compatible with "use"
            throw new TypeError(`Invalid key_ops "${key_ops}" for "sig" use`);
        }
        return new WebcryptoKey(exports.jwkWithAlgSchema.parse({
            ...jwk,
            kid,
            alg,
            use: 'sig'
        }), cryptoKeyPair);
    }
    constructor(jwk, cryptoKeyPair){
        super(jwk);
        Object.defineProperty(this, "cryptoKeyPair", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cryptoKeyPair
        });
    }
    get isPrivate() {
        return true;
    }
    get privateJwk() {
        if (super.isPrivate) return this.jwk;
        throw new Error('Private Webcrypto Key not exportable');
    }
    async getKeyObj(alg) {
        if (this.jwk.alg !== alg) {
            throw new jwk_1.JwkError(`Key cannot be used with algorithm "${alg}"`);
        }
        return this.cryptoKeyPair.privateKey;
    }
}
exports.WebcryptoKey = WebcryptoKey; //# sourceMappingURL=webcrypto-key.js.map
}}),
"[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/webcrypto-key.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDidError = exports.DidError = void 0;
class DidError extends Error {
    constructor(did, message, code, status = 400, cause){
        super(message, {
            cause
        });
        Object.defineProperty(this, "did", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: did
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: status
        });
    }
    /**
     * For compatibility with error handlers in common HTTP frameworks.
     */ get statusCode() {
        return this.status;
    }
    toString() {
        return `${this.constructor.name} ${this.code} (${this.did}): ${this.message}`;
    }
    static from(cause, did) {
        if (cause instanceof DidError) {
            return cause;
        }
        const message = cause instanceof Error ? cause.message : typeof cause === 'string' ? cause : 'An unknown error occurred';
        const status = (typeof cause?.['statusCode'] === 'number' ? cause['statusCode'] : undefined) ?? (typeof cause?.['status'] === 'number' ? cause['status'] : undefined);
        return new DidError(did, message, 'did-unknown-error', status, cause);
    }
}
exports.DidError = DidError;
class InvalidDidError extends DidError {
    constructor(did, message, cause){
        super(did, message, 'did-invalid', 400, cause);
    }
}
exports.InvalidDidError = InvalidDidError; //# sourceMappingURL=did-error.js.map
}}),
"[project]/node_modules/@atproto/did/dist/methods/plc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DID_PLC_PREFIX = void 0;
exports.isDidPlc = isDidPlc;
exports.asDidPlc = asDidPlc;
exports.assertDidPlc = assertDidPlc;
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const DID_PLC_PREFIX = `did:plc:`;
exports.DID_PLC_PREFIX = DID_PLC_PREFIX;
const DID_PLC_PREFIX_LENGTH = DID_PLC_PREFIX.length;
const DID_PLC_LENGTH = 32;
function isDidPlc(input) {
    // Optimization: equivalent to try/catch around "assertDidPlc"
    if (typeof input !== 'string') return false;
    if (input.length !== DID_PLC_LENGTH) return false;
    if (!input.startsWith(DID_PLC_PREFIX)) return false;
    for(let i = DID_PLC_PREFIX_LENGTH; i < DID_PLC_LENGTH; i++){
        if (!isBase32Char(input.charCodeAt(i))) return false;
    }
    return true;
}
function asDidPlc(input) {
    assertDidPlc(input);
    return input;
}
function assertDidPlc(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    }
    if (input.length !== DID_PLC_LENGTH) {
        throw new did_error_js_1.InvalidDidError(input, `did:plc must be ${DID_PLC_LENGTH} characters long`);
    }
    if (!input.startsWith(DID_PLC_PREFIX)) {
        throw new did_error_js_1.InvalidDidError(input, `Invalid did:plc prefix`);
    }
    // The following check is not necessary, as the check below is more strict:
    // assertDidMsid(input, DID_PLC_PREFIX.length)
    for(let i = DID_PLC_PREFIX_LENGTH; i < DID_PLC_LENGTH; i++){
        if (!isBase32Char(input.charCodeAt(i))) {
            throw new did_error_js_1.InvalidDidError(input, `Invalid character at position ${i}`);
        }
    }
}
const isBase32Char = (c)=>c >= 0x61 && c <= 0x7a || c >= 0x32 && c <= 0x37; // [a-z2-7]
 //# sourceMappingURL=plc.js.map
}}),
"[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didSchema = exports.DID_PREFIX = void 0;
exports.assertDidMethod = assertDidMethod;
exports.extractDidMethod = extractDidMethod;
exports.assertDidMsid = assertDidMsid;
exports.assertDid = assertDid;
exports.isDid = isDid;
exports.asDid = asDid;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const DID_PREFIX = 'did:';
exports.DID_PREFIX = DID_PREFIX;
const DID_PREFIX_LENGTH = DID_PREFIX.length;
/**
 * DID Method-name check function.
 *
 * Check if the input is a valid DID method name, at the position between
 * `start` (inclusive) and `end` (exclusive).
 */ function assertDidMethod(input, start = 0, end = input.length) {
    if (!Number.isFinite(end) || !Number.isFinite(start) || end < start || end > input.length) {
        throw new TypeError('Invalid start or end position');
    }
    if (end === start) {
        throw new did_error_js_1.InvalidDidError(input, `Empty method name`);
    }
    let c;
    for(let i = start; i < end; i++){
        c = input.charCodeAt(i);
        if ((c < 0x61 || c > 0x7a) && // a-z
        (c < 0x30 || c > 0x39) // 0-9
        ) {
            throw new did_error_js_1.InvalidDidError(input, `Invalid character at position ${i} in DID method name`);
        }
    }
}
/**
 * This method assumes the input is a valid Did
 */ function extractDidMethod(did) {
    const msidSep = did.indexOf(':', DID_PREFIX_LENGTH);
    const method = did.slice(DID_PREFIX_LENGTH, msidSep);
    return method;
}
/**
 * DID Method-specific identifier check function.
 *
 * Check if the input is a valid DID method-specific identifier, at the position
 * between `start` (inclusive) and `end` (exclusive).
 */ function assertDidMsid(input, start = 0, end = input.length) {
    if (!Number.isFinite(end) || !Number.isFinite(start) || end < start || end > input.length) {
        throw new TypeError('Invalid start or end position');
    }
    if (end === start) {
        throw new did_error_js_1.InvalidDidError(input, `DID method-specific id must not be empty`);
    }
    let c;
    for(let i = start; i < end; i++){
        c = input.charCodeAt(i);
        // Check for frequent chars first
        if ((c < 0x61 || c > 0x7a) && // a-z
        (c < 0x41 || c > 0x5a) && // A-Z
        (c < 0x30 || c > 0x39) && // 0-9
        c !== 0x2e && // .
        c !== 0x2d && // -
        c !== 0x5f // _
        ) {
            // Less frequent chars are checked here
            // ":"
            if (c === 0x3a) {
                if (i === end - 1) {
                    throw new did_error_js_1.InvalidDidError(input, `DID cannot end with ":"`);
                }
                continue;
            }
            // pct-encoded
            if (c === 0x25) {
                c = input.charCodeAt(++i);
                if ((c < 0x30 || c > 0x39) && (c < 0x41 || c > 0x46)) {
                    throw new did_error_js_1.InvalidDidError(input, `Invalid pct-encoded character at position ${i}`);
                }
                c = input.charCodeAt(++i);
                if ((c < 0x30 || c > 0x39) && (c < 0x41 || c > 0x46)) {
                    throw new did_error_js_1.InvalidDidError(input, `Invalid pct-encoded character at position ${i}`);
                }
                // There must always be 2 HEXDIG after a "%"
                if (i >= end) {
                    throw new did_error_js_1.InvalidDidError(input, `Incomplete pct-encoded character at position ${i - 2}`);
                }
                continue;
            }
            throw new did_error_js_1.InvalidDidError(input, `Disallowed character in DID at position ${i}`);
        }
    }
}
function assertDid(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    }
    const { length } = input;
    if (length > 2048) {
        throw new did_error_js_1.InvalidDidError(input, `DID is too long (2048 chars max)`);
    }
    if (!input.startsWith(DID_PREFIX)) {
        throw new did_error_js_1.InvalidDidError(input, `DID requires "${DID_PREFIX}" prefix`);
    }
    const idSep = input.indexOf(':', DID_PREFIX_LENGTH);
    if (idSep === -1) {
        throw new did_error_js_1.InvalidDidError(input, `Missing colon after method name`);
    }
    assertDidMethod(input, DID_PREFIX_LENGTH, idSep);
    assertDidMsid(input, idSep + 1, length);
}
function isDid(input) {
    try {
        assertDid(input);
        return true;
    } catch (err) {
        if (err instanceof did_error_js_1.DidError) {
            return false;
        }
        // Unexpected TypeError (should never happen)
        throw err;
    }
}
function asDid(input) {
    assertDid(input);
    return input;
}
exports.didSchema = zod_1.z.string().superRefine((value, ctx)=>{
    try {
        assertDid(value);
        return true;
    } catch (err) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: err instanceof Error ? err.message : 'Unexpected error'
        });
        return false;
    }
}); //# sourceMappingURL=did.js.map
}}),
"[project]/node_modules/@atproto/did/dist/methods/web.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DID_WEB_PREFIX = void 0;
exports.isDidWeb = isDidWeb;
exports.asDidWeb = asDidWeb;
exports.assertDidWeb = assertDidWeb;
exports.didWebToUrl = didWebToUrl;
exports.urlToDidWeb = urlToDidWeb;
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const did_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)");
exports.DID_WEB_PREFIX = `did:web:`;
/**
 * This function checks if the input is a valid Web DID, as per DID spec.
 */ function isDidWeb(input) {
    // Optimization: make cheap checks first
    if (typeof input !== 'string') return false;
    try {
        assertDidWeb(input);
        return true;
    } catch  {
        return false;
    }
}
function asDidWeb(input) {
    assertDidWeb(input);
    return input;
}
function assertDidWeb(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    }
    void didWebToUrl(input);
}
function didWebToUrl(did) {
    if (!did.startsWith(exports.DID_WEB_PREFIX)) {
        throw new did_error_js_1.InvalidDidError(did, `did:web must start with ${exports.DID_WEB_PREFIX}`);
    }
    if (did.charAt(exports.DID_WEB_PREFIX.length) === ':') {
        throw new did_error_js_1.InvalidDidError(did, 'did:web MSID must not start with a colon');
    }
    // Make sure every char is valid (per DID spec)
    (0, did_js_1.assertDidMsid)(did, exports.DID_WEB_PREFIX.length);
    try {
        const msid = did.slice(exports.DID_WEB_PREFIX.length);
        const parts = msid.split(':').map(decodeURIComponent);
        const url = new URL(`https://${parts.join('/')}`);
        if (url.hostname === 'localhost') {
            url.protocol = 'http:';
        }
        return url;
    } catch (cause) {
        throw new did_error_js_1.InvalidDidError(did, 'Invalid Web DID', cause);
    }
}
function urlToDidWeb(url) {
    const path = url.pathname === '/' ? '' : url.pathname.slice(1).split('/').map(encodeURIComponent).join(':');
    return `did:web:${encodeURIComponent(url.host)}${path ? `:${path}` : ''}`;
} //# sourceMappingURL=web.js.map
}}),
"[project]/node_modules/@atproto/did/dist/methods.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/methods/plc.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/methods/web.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=methods.js.map
}}),
"[project]/node_modules/@atproto/did/dist/atproto.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atprotoDidSchema = void 0;
exports.isAtprotoDid = isAtprotoDid;
exports.asAtprotoDid = asAtprotoDid;
exports.assertAtprotoDid = assertAtprotoDid;
exports.assertAtprotoDidWeb = assertAtprotoDidWeb;
exports.isAtprotoDidWeb = isAtprotoDidWeb;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const methods_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/methods.js [app-ssr] (ecmascript)");
exports.atprotoDidSchema = zod_1.z.string().refine(isAtprotoDid, `Atproto only allows "plc" and "web" DID methods`);
function isAtprotoDid(input) {
    // Optimized equivalent of:
    // return isDidPlc(input) || isAtprotoDidWeb(input)
    if (typeof input !== 'string') {
        return false;
    } else if (input.startsWith(methods_js_1.DID_PLC_PREFIX)) {
        return (0, methods_js_1.isDidPlc)(input);
    } else if (input.startsWith(methods_js_1.DID_WEB_PREFIX)) {
        return isAtprotoDidWeb(input);
    } else {
        return false;
    }
}
function asAtprotoDid(input) {
    assertAtprotoDid(input);
    return input;
}
function assertAtprotoDid(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    } else if (input.startsWith(methods_js_1.DID_PLC_PREFIX)) {
        (0, methods_js_1.assertDidPlc)(input);
    } else if (input.startsWith(methods_js_1.DID_WEB_PREFIX)) {
        assertAtprotoDidWeb(input);
    } else {
        throw new did_error_js_1.InvalidDidError(input, `Atproto only allows "plc" and "web" DID methods`);
    }
}
function assertAtprotoDidWeb(input) {
    (0, methods_js_1.assertDidWeb)(input);
    if (input.includes(':', methods_js_1.DID_WEB_PREFIX.length)) {
        throw new did_error_js_1.InvalidDidError(input, `Atproto does not allow path components in Web DIDs`);
    }
    if (input.includes('%3A', methods_js_1.DID_WEB_PREFIX.length) && !input.startsWith('did:web:localhost%3A')) {
        throw new did_error_js_1.InvalidDidError(input, `Atproto does not allow port numbers in Web DIDs, except for localhost`);
    }
}
/**
 * @see {@link https://atproto.com/specs/did#blessed-did-methods}
 */ function isAtprotoDidWeb(input) {
    try {
        assertAtprotoDidWeb(input);
        return true;
    } catch  {
        return false;
    }
} //# sourceMappingURL=atproto.js.map
}}),
"[project]/node_modules/@atproto/did/dist/did-document.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didDocumentValidator = exports.didDocumentSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const did_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)");
/**
 * RFC3968 compliant URI
 *
 * @see {@link https://www.rfc-editor.org/rfc/rfc3986}
 */ const rfc3968UriSchema = zod_1.z.string().refine((data)=>{
    try {
        new URL(data);
        return true;
    } catch  {
        return false;
    }
}, 'RFC3968 compliant URI');
const didControllerSchema = zod_1.z.union([
    did_js_1.didSchema,
    zod_1.z.array(did_js_1.didSchema)
]);
/**
 * @note this schema might be too permissive
 */ const didRelativeUriSchema = zod_1.z.union([
    rfc3968UriSchema,
    zod_1.z.string().regex(/^#[^#]+$/)
]);
const didVerificationMethodSchema = zod_1.z.object({
    id: didRelativeUriSchema,
    type: zod_1.z.string().min(1),
    controller: didControllerSchema,
    publicKeyJwk: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
    publicKeyMultibase: zod_1.z.string().optional()
});
/**
 * The value of the id property MUST be a URI conforming to [RFC3986]. A
 * conforming producer MUST NOT produce multiple service entries with the same
 * id. A conforming consumer MUST produce an error if it detects multiple
 * service entries with the same id.
 *
 * @note Normally, only rfc3968UriSchema should be allowed here. However, the
 *   did:plc uses relative URI. For this reason, we also allow relative URIs
 *   here.
 */ const didServiceIdSchema = didRelativeUriSchema;
/**
 * The value of the type property MUST be a string or a set of strings. In order
 * to maximize interoperability, the service type and its associated properties
 * SHOULD be registered in the DID Specification Registries
 * [DID-SPEC-REGISTRIES].
 */ const didServiceTypeSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.array(zod_1.z.string())
]);
/**
 * The value of the serviceEndpoint property MUST be a string, a map, or a set
 * composed of one or more strings and/or maps. All string values MUST be valid
 * URIs conforming to [RFC3986] and normalized according to the Normalization
 * and Comparison rules in RFC3986 and to any normalization rules in its
 * applicable URI scheme specification.
 */ const didServiceEndpointSchema = zod_1.z.union([
    rfc3968UriSchema,
    zod_1.z.record(zod_1.z.string(), rfc3968UriSchema),
    zod_1.z.array(zod_1.z.union([
        rfc3968UriSchema,
        zod_1.z.record(zod_1.z.string(), rfc3968UriSchema)
    ])).nonempty()
]);
/**
 * Each service map MUST contain id, type, and serviceEndpoint properties.
 * @see {@link https://www.w3.org/TR/did-core/#services}
 */ const didServiceSchema = zod_1.z.object({
    id: didServiceIdSchema,
    type: didServiceTypeSchema,
    serviceEndpoint: didServiceEndpointSchema
});
const didAuthenticationSchema = zod_1.z.union([
    //
    didRelativeUriSchema,
    didVerificationMethodSchema
]);
/**
 * @note This schema is incomplete
 * @see {@link https://www.w3.org/TR/did-core/#production-0}
 */ exports.didDocumentSchema = zod_1.z.object({
    '@context': zod_1.z.union([
        zod_1.z.literal('https://www.w3.org/ns/did/v1'),
        zod_1.z.array(zod_1.z.string().url()).nonempty().refine((data)=>data[0] === 'https://www.w3.org/ns/did/v1', {
            message: 'First @context must be https://www.w3.org/ns/did/v1'
        })
    ]),
    id: did_js_1.didSchema,
    controller: didControllerSchema.optional(),
    alsoKnownAs: zod_1.z.array(rfc3968UriSchema).optional(),
    service: zod_1.z.array(didServiceSchema).optional(),
    authentication: zod_1.z.array(didAuthenticationSchema).optional(),
    verificationMethod: zod_1.z.array(zod_1.z.union([
        didVerificationMethodSchema,
        didRelativeUriSchema
    ])).optional()
});
// @TODO: add other refinements ?
exports.didDocumentValidator = exports.didDocumentSchema// Ensure that every service id is unique
.superRefine(({ id: did, service }, ctx)=>{
    if (service) {
        const visited = new Set();
        for(let i = 0; i < service.length; i++){
            const current = service[i];
            const serviceId = current.id.startsWith('#') ? `${did}${current.id}` : current.id;
            if (!visited.has(serviceId)) {
                visited.add(serviceId);
            } else {
                ctx.addIssue({
                    code: zod_1.z.ZodIssueCode.custom,
                    message: `Duplicate service id (${current.id}) found in the document`,
                    path: [
                        'service',
                        i,
                        'id'
                    ]
                });
            }
        }
    }
}); //# sourceMappingURL=did-document.js.map
}}),
"[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/atproto.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/did-document.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/methods.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/lru-cache/dist/commonjs/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
/**
 * @module LRUCache
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LRUCache = void 0;
const perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;
const warned = new Set();
/* c8 ignore start */ const PROCESS = typeof process === 'object' && !!process ? process : {};
/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{
    typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */ if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor(){
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted) return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort){
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = ()=>{
        if (!printACPolyfillWarning) return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */ // This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
/* c8 ignore stop */ class ZeroArray extends Array {
    constructor(size){
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls) return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls){
        /* c8 ignore start */ if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */ this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */ class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */ ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */ ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */ ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */ updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */ updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */ allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */ noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */ noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */ maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */ sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */ noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */ noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */ allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */ allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */ ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */ static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head () {
                return c.#head;
            },
            get tail () {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),
            moveToTail: (index)=>c.#moveToTail(index),
            indexes: (options)=>c.#indexes(options),
            rindexes: (options)=>c.#rindexes(options),
            isStale: (index)=>c.#isStale(index)
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */ get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */ get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */ get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */ get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */ get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */ get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */ get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options){
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined && typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        } else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */ getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now())=>{
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(()=>{
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
        };
        this.#updateItemAge = (index)=>{
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index)=>{
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */ if (!ttl || !start) return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = ()=>{
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
            return n;
        };
        this.getRemainingTTL = (key)=>{
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = (index)=>{
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = ()=>{};
    #statusTTL = ()=>{};
    #setItemTTL = ()=>{};
    /* c8 ignore stop */ #isStale = ()=>false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index)=>{
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation)=>{
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                } else {
                    throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status)=>{
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while(this.#calculatedSize > maxSize){
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = (_i)=>{};
    #addItemSize = (_i, _s, _st)=>{};
    #requireSize = (_k, _v, size, sizeCalculation)=>{
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for(let i = this.#tail; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                } else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for(let i = this.#head; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                } else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */ *entries() {
        for (const i of this.#indexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */ *rentries() {
        for (const i of this.#rindexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */ *keys() {
        for (const i of this.#indexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */ *rkeys() {
        for (const i of this.#rindexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */ *values() {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */ *rvalues() {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */ [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */ find(fn, getOptions = {}) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */ forEach(fn, thisp = this) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */ rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */ purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({
            allowStale: true
        })){
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */ info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined) return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined) return undefined;
        const entry = {
            value
        };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */ dump() {
        const arr = [];
        for (const i of this.#indexes({
            allowStale: true
        })){
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined || key === undefined) continue;
            const entry = {
                value
            };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([
                key,
                entry
            ]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */ load(arr) {
        this.clear();
        for (const [key, entry] of arr){
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */ set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status) status.set = 'add';
            noUpdateTTL = false;
        } else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                s,
                                k,
                                'set'
                            ]);
                        }
                    }
                } else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([
                            oldVal,
                            k,
                            'set'
                        ]);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== undefined) status.oldValue = oldValue;
                }
            } else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status) this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */ pop() {
        try {
            while(this.#size){
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                } else if (val !== undefined) {
                    return val;
                }
            }
        } finally{
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while(task = dt?.shift()){
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([
                    v,
                    k,
                    'evict'
                ]);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        } else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */ has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            } else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        } else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */ peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined || !allowStale && this.#isStale(index)) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', ()=>ac.abort(signal.reason), {
            signal: ac.signal
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context
        };
        const cb = (v, updateCache = false)=>{
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort) options.status.fetchAbortIgnored = true;
                } else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    } else {
                        this.#delete(k, 'fetch');
                    }
                } else {
                    if (options.status) options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er)=>{
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er)=>{
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                } else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            } else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej)=>{
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then((v)=>res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', ()=>{
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = (v)=>cb(v, true);
                    }
                }
            });
        };
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, {
                ...fetchOpts.options,
                status: undefined
            });
            index = this.#keyMap.get(k);
        } else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod) return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
        const { // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status) status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status) status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return p.__returned = p;
        } else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale) status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : v.__returned = v;
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status) status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status) this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined) throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined) return v;
        const vv = memoMethod(k, v, {
            options,
            context
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */ get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status) this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status) status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale) status.returnedStale = true;
                    return allowStale ? value : undefined;
                } else {
                    if (status && allowStale && value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            } else {
                if (status) status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        } else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            } else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */ delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                } else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    } else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                v,
                                k,
                                reason
                            ]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    } else if (index === this.#head) {
                        this.#head = this.#next[index];
                    } else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */ clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({
            allowStale: true
        })){
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            } else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([
                        v,
                        k,
                        reason
                    ]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
    }
}
exports.LRUCache = LRUCache; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store-memory/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.roughSizeOfObject = void 0;
const knownSizes = new WeakMap();
/**
 * @see {@link https://stackoverflow.com/a/11900218/356537}
 */ function roughSizeOfObject(value) {
    const objectList = new Set();
    const stack = [
        value
    ]; // This would be more efficient using a circular buffer
    let bytes = 0;
    while(stack.length){
        const value = stack.pop();
        // > All objects on the heap start with a shape descriptor, which takes one
        // > pointer size (usually 4 bytes these days, thanks to "pointer
        // > compression" on 64-bit platforms).
        switch(typeof value){
            // Types are ordered by frequency
            case 'string':
                // https://stackoverflow.com/a/68791382/356537
                bytes += 12 + 4 * Math.ceil(value.length / 4);
                break;
            case 'number':
                bytes += 12; // Shape descriptor + double
                break;
            case 'boolean':
                bytes += 4; // Shape descriptor
                break;
            case 'object':
                bytes += 4; // Shape descriptor
                if (value === null) {
                    break;
                }
                if (knownSizes.has(value)) {
                    bytes += knownSizes.get(value);
                    break;
                }
                if (objectList.has(value)) continue;
                objectList.add(value);
                if (Array.isArray(value)) {
                    bytes += 4;
                    stack.push(...value);
                } else {
                    bytes += 8;
                    const keys = Object.getOwnPropertyNames(value);
                    for(let i = 0; i < keys.length; i++){
                        bytes += 4;
                        const key = keys[i];
                        const val = value[key];
                        if (val !== undefined) stack.push(val);
                        stack.push(key);
                    }
                }
                break;
            case 'function':
                bytes += 8; // Shape descriptor + pointer (assuming functions are shared)
                break;
            case 'symbol':
                bytes += 8; // Shape descriptor + pointer
                break;
            case 'bigint':
                bytes += 16; // Shape descriptor + BigInt
                break;
        }
    }
    if (typeof value === 'object' && value !== null) {
        knownSizes.set(value, bytes);
    }
    return bytes;
}
exports.roughSizeOfObject = roughSizeOfObject; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SimpleStoreMemory_cache;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SimpleStoreMemory = void 0;
const lru_cache_1 = __turbopack_require__("[project]/node_modules/lru-cache/dist/commonjs/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/util.js [app-ssr] (ecmascript)");
// LRUCache does not allow storing "null", so we use a symbol to represent it.
const nullSymbol = Symbol('nullItem');
const toLruValue = (value)=>value === null ? nullSymbol : value;
const fromLruValue = (value)=>value === nullSymbol ? null : value;
class SimpleStoreMemory {
    constructor({ sizeCalculation, ...options }){
        _SimpleStoreMemory_cache.set(this, void 0);
        __classPrivateFieldSet(this, _SimpleStoreMemory_cache, new lru_cache_1.LRUCache({
            ...options,
            allowStale: false,
            updateAgeOnGet: false,
            updateAgeOnHas: false,
            sizeCalculation: sizeCalculation ? (value, key)=>sizeCalculation(fromLruValue(value), key) : options.maxEntrySize != null || options.maxSize != null ? util_js_1.roughSizeOfObject : undefined
        }), "f");
    }
    get(key) {
        const value = __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").get(key);
        if (value === undefined) return undefined;
        return fromLruValue(value);
    }
    set(key, value) {
        __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").set(key, toLruValue(value));
    }
    del(key) {
        __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").delete(key);
    }
    clear() {
        __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").clear();
    }
}
exports.SimpleStoreMemory = SimpleStoreMemory;
_SimpleStoreMemory_cache = new WeakMap(); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache-memory.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidCacheMemory = void 0;
const simple_store_memory_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)");
const DEFAULT_TTL = 3600 * 1000; // 1 hour
const DEFAULT_MAX_SIZE = 50 * 1024 * 1024; // ~50MB
class DidCacheMemory extends simple_store_memory_1.SimpleStoreMemory {
    constructor(options){
        super(options?.max == null ? {
            ttl: DEFAULT_TTL,
            maxSize: DEFAULT_MAX_SIZE,
            ...options
        } : {
            ttl: DEFAULT_TTL,
            ...options
        });
    }
}
exports.DidCacheMemory = DidCacheMemory; //# sourceMappingURL=did-cache-memory.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store/dist/cached-getter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CachedGetter = void 0;
const returnTrue = ()=>true;
const returnFalse = ()=>false;
/**
 * Wrapper utility that uses a store to speed up the retrieval of values from an
 * (expensive) getter function.
 */ class CachedGetter {
    constructor(getter, store, options){
        Object.defineProperty(this, "getter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: getter
        });
        Object.defineProperty(this, "store", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: store
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "pending", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    async get(key, options) {
        options?.signal?.throwIfAborted();
        const isStale = this.options?.isStale;
        const allowStored = options?.noCache ? returnFalse // Never allow stored values to be returned
         : options?.allowStale || isStale == null ? returnTrue // Always allow stored values to be returned
         : async (value)=>!await isStale(key, value);
        // As long as concurrent requests are made for the same key, only one
        // request will be made to the cache & getter function at a time. This works
        // because there is no async operation between the while() loop and the
        // pending.set() call. Because of the "single threaded" nature of
        // JavaScript, the pending item will be set before the next iteration of the
        // while loop.
        let previousExecutionFlow;
        while(previousExecutionFlow = this.pending.get(key)){
            try {
                const { isFresh, value } = await previousExecutionFlow;
                if (isFresh) return value;
                if (await allowStored(value)) return value;
            } catch  {
            // Ignore errors from previous execution flows (they will have been
            // propagated by that flow).
            }
            options?.signal?.throwIfAborted();
        }
        const currentExecutionFlow = Promise.resolve().then(async ()=>{
            const storedValue = await this.getStored(key, options);
            if (storedValue !== undefined && await allowStored(storedValue)) {
                // Use the stored value as return value for the current execution
                // flow. Notify other concurrent execution flows (that should be
                // "stuck" in the loop before until this promise resolves) that we got
                // a value, but that it came from the store (isFresh = false).
                return {
                    isFresh: false,
                    value: storedValue
                };
            }
            return Promise.resolve().then(async ()=>(0, this.getter)(key, options, storedValue)).catch(async (err)=>{
                if (storedValue !== undefined) {
                    try {
                        const deleteOnError = this.options?.deleteOnError;
                        if (await deleteOnError?.(err, key, storedValue)) {
                            await this.delStored(key, err);
                        }
                    } catch (error) {
                        throw new AggregateError([
                            err,
                            error
                        ], 'Error while deleting stored value');
                    }
                }
                throw err;
            }).then(async (value)=>{
                // The value should be stored even is the signal was aborted.
                await this.setStored(key, value);
                return {
                    isFresh: true,
                    value
                };
            });
        }).finally(()=>{
            this.pending.delete(key);
        });
        if (this.pending.has(key)) {
            // This should never happen. Indeed, there must not be any 'await'
            // statement between this and the loop iteration check meaning that
            // this.pending.get returned undefined. It is there to catch bugs that
            // would occur in future changes to the code.
            throw new Error('Concurrent request for the same key');
        }
        this.pending.set(key, currentExecutionFlow);
        const { value } = await currentExecutionFlow;
        return value;
    }
    bind(key) {
        return async (options)=>this.get(key, options);
    }
    async getStored(key, options) {
        try {
            return await this.store.get(key, options);
        } catch (err) {
            return undefined;
        }
    }
    async setStored(key, value) {
        try {
            await this.store.set(key, value);
        } catch (err) {
            const onStoreError = this.options?.onStoreError;
            await onStoreError?.(err, key, value);
        }
    }
    async delStored(key, _cause) {
        await this.store.del(key);
    }
}
exports.CachedGetter = CachedGetter; //# sourceMappingURL=cached-getter.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store/dist/simple-store.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=simple-store.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/cached-getter.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/simple-store.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidResolverCached = void 0;
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const did_cache_memory_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache-memory.js [app-ssr] (ecmascript)");
class DidResolverCached {
    constructor(resolver, cache = new did_cache_memory_js_1.DidCacheMemory()){
        Object.defineProperty(this, "getter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.getter = new simple_store_1.CachedGetter((did, options)=>resolver.resolve(did, options), cache);
    }
    async resolve(did, options) {
        return this.getter.get(did, options);
    }
}
exports.DidResolverCached = DidResolverCached; //# sourceMappingURL=did-cache.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-method.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=did-method.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchError = void 0;
class FetchError extends Error {
    constructor(statusCode, message, options){
        super(message, options);
        Object.defineProperty(this, "statusCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: statusCode
        });
    }
    get expose() {
        return true;
    }
}
exports.FetchError = FetchError; //# sourceMappingURL=fetch-error.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toRequestTransformer = toRequestTransformer;
exports.asRequest = asRequest;
function toRequestTransformer(requestTransformer) {
    return function(input, init) {
        return requestTransformer.call(this, asRequest(input, init));
    };
}
function asRequest(input, init) {
    if (!init && input instanceof Request) return input;
    return new Request(input, init);
} //# sourceMappingURL=fetch.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// @TODO: Move some of these to a shared package ?
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractUrl = exports.MaxBytesTransformStream = exports.ifString = exports.ifObject = void 0;
exports.isIp = isIp;
exports.padLines = padLines;
exports.cancelBody = cancelBody;
exports.logCancellationError = logCancellationError;
exports.stringifyMessage = stringifyMessage;
function isIp(hostname) {
    // IPv4
    if (hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) return true;
    // IPv6
    if (hostname.startsWith('[') && hostname.endsWith(']')) return true;
    return false;
}
const plainObjectProto = Object.prototype;
const ifObject = (v)=>{
    if (typeof v === 'object' && v != null && !Array.isArray(v)) {
        const proto = Object.getPrototypeOf(v);
        if (proto === null || proto === plainObjectProto) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            return v;
        }
    }
    return undefined;
};
exports.ifObject = ifObject;
const ifString = (v)=>typeof v === 'string' ? v : undefined;
exports.ifString = ifString;
class MaxBytesTransformStream extends TransformStream {
    constructor(maxBytes){
        // Note: negation accounts for invalid value types (NaN, non numbers)
        if (!(maxBytes >= 0)) {
            throw new TypeError('maxBytes must be a non-negative number');
        }
        let bytesRead = 0;
        super({
            transform: (chunk, ctrl)=>{
                if ((bytesRead += chunk.length) <= maxBytes) {
                    ctrl.enqueue(chunk);
                } else {
                    ctrl.error(new Error('Response too large'));
                }
            }
        });
    }
}
exports.MaxBytesTransformStream = MaxBytesTransformStream;
const LINE_BREAK = /\r?\n/g;
function padLines(input, pad) {
    if (!input) return input;
    return pad + input.replace(LINE_BREAK, `$&${pad}`);
}
/**
 * @param [onCancellationError] - Callback that will trigger to asynchronously
 * handle any error that occurs while cancelling the response body. Providing
 * this will speed up the process and avoid potential deadlocks. Defaults to
 * awaiting the cancellation operation. use `"log"` to log the error.
 * @see {@link https://undici.nodejs.org/#/?id=garbage-collection}
 * @note awaiting this function's result, when no `onCancellationError` is
 * provided, might result in a dead lock. Indeed, if the response was cloned(),
 * the response.body.cancel() method will not resolve until the other response's
 * body is consumed/cancelled.
 *
 * @example
 * ```ts
 * // Make sure response was not cloned, or that every cloned response was
 * // consumed/cancelled before awaiting this function's result.
 * await cancelBody(response)
 * ```
 * @example
 * ```ts
 * await cancelBody(response, (err) => {
 *   // No biggie, let's just log the error
 *   console.warn('Failed to cancel response body', err)
 * })
 * ```
 * @example
 * ```ts
 * // Will generate an "unhandledRejection" if an error occurs while cancelling
 * // the response body. This will likely crash the process.
 * await cancelBody(response, (err) => { throw err })
 * ```
 */ async function cancelBody(body, onCancellationError) {
    if (body.body && !body.bodyUsed && !body.body.locked && // Support for alternative fetch implementations
    typeof body.body.cancel === 'function') {
        if (typeof onCancellationError === 'function') {
            void body.body.cancel().catch(onCancellationError);
        } else if (onCancellationError === 'log') {
            void body.body.cancel().catch(logCancellationError);
        } else {
            await body.body.cancel();
        }
    }
}
function logCancellationError(err) {
    console.warn('Failed to cancel response body', err);
}
async function stringifyMessage(input) {
    try {
        const headers = stringifyHeaders(input.headers);
        const payload = await stringifyBody(input);
        return headers && payload ? `${headers}\n${payload}` : headers || payload;
    } finally{
        void cancelBody(input, 'log');
    }
}
function stringifyHeaders(headers) {
    return Array.from(headers).map(([name, value])=>`${name}: ${value}`).join('\n');
}
async function stringifyBody(body) {
    try {
        const blob = await body.blob();
        if (blob.type?.startsWith('text/')) {
            const text = await blob.text();
            return JSON.stringify(text);
        }
        if (/application\/(?:\w+\+)?json/.test(blob.type)) {
            const text = await blob.text();
            return text.includes('\n') ? JSON.stringify(JSON.parse(text)) : text;
        }
        return `[Body size: ${blob.size}, type: ${JSON.stringify(blob.type)} ]`;
    } catch  {
        return '[Body could not be read]';
    }
}
const extractUrl = (input)=>typeof input === 'string' ? new URL(input) : input instanceof URL ? input : new URL(input.url);
exports.extractUrl = extractUrl; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_FORBIDDEN_DOMAIN_NAMES = exports.FetchRequestError = void 0;
exports.protocolCheckRequestTransform = protocolCheckRequestTransform;
exports.redirectCheckRequestTransform = redirectCheckRequestTransform;
exports.requireHostHeaderTransform = requireHostHeaderTransform;
exports.forbiddenDomainNameRequestTransform = forbiddenDomainNameRequestTransform;
const fetch_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)");
const fetch_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)");
class FetchRequestError extends fetch_error_js_1.FetchError {
    constructor(request, statusCode, message, options){
        if (statusCode == null || !message) {
            const info = extractInfo(extractRootCause(options?.cause));
            statusCode ?? (statusCode = info[0]);
            message || (message = info[1]);
        }
        super(statusCode, message, options);
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: request
        });
    }
    get expose() {
        // A 500 request error means that the request was not made due to an infra,
        // programming or server side issue. The message should no be exposed to
        // downstream clients.
        return this.statusCode !== 500;
    }
    static from(request, cause) {
        if (cause instanceof FetchRequestError) return cause;
        return new FetchRequestError(request, undefined, undefined, {
            cause
        });
    }
}
exports.FetchRequestError = FetchRequestError;
function extractRootCause(err) {
    // Unwrap the Network error from undici (i.e. Node's internal fetch() implementation)
    // https://github.com/nodejs/undici/blob/3274c975947ce11a08508743df026f73598bfead/lib/web/fetch/index.js#L223-L228
    if (err instanceof TypeError && err.message === 'fetch failed' && err.cause !== undefined) {
        return err.cause;
    }
    return err;
}
function extractInfo(err) {
    if (typeof err === 'string' && err.length > 0) {
        return [
            500,
            err
        ];
    }
    if (!(err instanceof Error)) {
        return [
            500,
            'Failed to fetch'
        ];
    }
    // Undici fetch() "network" errors
    switch(err.message){
        case 'failed to fetch the data URL':
            return [
                400,
                err.message
            ];
        case 'unexpected redirect':
        case 'cors failure':
        case 'blocked':
        case 'proxy authentication required':
            // These cases could be represented either as a 4xx user error (invalid
            // URL provided), or as a 5xx server error (server didn't behave as
            // expected).
            return [
                502,
                err.message
            ];
    }
    // NodeJS errors
    const code = err['code'];
    if (typeof code === 'string') {
        switch(true){
            case code === 'ENOTFOUND':
                return [
                    400,
                    'Invalid hostname'
                ];
            case code === 'ECONNREFUSED':
                return [
                    502,
                    'Connection refused'
                ];
            case code === 'DEPTH_ZERO_SELF_SIGNED_CERT':
                return [
                    502,
                    'Self-signed certificate'
                ];
            case code.startsWith('ERR_TLS'):
                return [
                    502,
                    'TLS error'
                ];
            case code.startsWith('ECONN'):
                return [
                    502,
                    'Connection error'
                ];
            default:
                return [
                    500,
                    `${code} error`
                ];
        }
    }
    return [
        500,
        err.message
    ];
}
function protocolCheckRequestTransform(protocols) {
    return (input, init)=>{
        const { protocol, port } = (0, util_js_1.extractUrl)(input);
        const request = (0, fetch_js_1.asRequest)(input, init);
        const config = Object.hasOwn(protocols, protocol) ? protocols[protocol] : undefined;
        if (!config) {
            throw new FetchRequestError(request, 400, `Forbidden protocol "${protocol}"`);
        } else if (config === true) {
        // Safe to proceed
        } else if (!config['allowCustomPort'] && port !== '') {
            throw new FetchRequestError(request, 400, `Custom ${protocol} ports not allowed`);
        }
        return request;
    };
}
function redirectCheckRequestTransform() {
    return (input, init)=>{
        const request = (0, fetch_js_1.asRequest)(input, init);
        if (request.redirect === 'follow') {
            throw new FetchRequestError(request, 500, 'Request redirect must be "error" or "manual"');
        }
        return request;
    };
}
function requireHostHeaderTransform() {
    return (input, init)=>{
        // Note that fetch() will automatically add the Host header from the URL and
        // discard any Host header manually set in the request.
        const { protocol, hostname } = (0, util_js_1.extractUrl)(input);
        const request = (0, fetch_js_1.asRequest)(input, init);
        // "Host" header only makes sense in the context of an HTTP request
        if (protocol !== 'http:' && protocol !== 'https:') {
            throw new FetchRequestError(request, 400, `"${protocol}" requests are not allowed`);
        }
        if (!hostname || (0, util_js_1.isIp)(hostname)) {
            throw new FetchRequestError(request, 400, 'Invalid hostname');
        }
        return request;
    };
}
exports.DEFAULT_FORBIDDEN_DOMAIN_NAMES = [
    'example.com',
    '*.example.com',
    'example.org',
    '*.example.org',
    'example.net',
    '*.example.net',
    'googleusercontent.com',
    '*.googleusercontent.com'
];
function forbiddenDomainNameRequestTransform(denyList = exports.DEFAULT_FORBIDDEN_DOMAIN_NAMES) {
    const denySet = new Set(denyList);
    // Optimization: if no forbidden domain names are provided, we can skip the
    // check entirely.
    if (denySet.size === 0) {
        return fetch_js_1.asRequest;
    }
    return async (input, init)=>{
        const { hostname } = (0, util_js_1.extractUrl)(input);
        const request = (0, fetch_js_1.asRequest)(input, init);
        // Full domain name check
        if (denySet.has(hostname)) {
            throw new FetchRequestError(request, 403, 'Forbidden hostname');
        }
        // Sub domain name check
        let curDot = hostname.indexOf('.');
        while(curDot !== -1){
            const subdomain = hostname.slice(curDot + 1);
            if (denySet.has(`*.${subdomain}`)) {
                throw new FetchRequestError(request, 403, 'Forbidden hostname');
            }
            curDot = hostname.indexOf('.', curDot + 1);
        }
        return request;
    };
} //# sourceMappingURL=fetch-request.js.map
}}),
"[project]/node_modules/@atproto-labs/pipe/dist/pipe.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pipeTwo = exports.pipe = void 0;
function pipe(...pipeline) {
    return pipeline.reduce(pipeTwo);
}
exports.pipe = pipe;
function pipeTwo(first, second) {
    return async (input)=>second(await first(input));
}
exports.pipeTwo = pipeTwo; //# sourceMappingURL=pipe.js.map
}}),
"[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pipeTwo = exports.pipe = void 0;
var pipe_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/pipe.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "pipe", {
    enumerable: true,
    get: function() {
        return pipe_js_1.pipe;
    }
});
Object.defineProperty(exports, "pipeTwo", {
    enumerable: true,
    get: function() {
        return pipe_js_1.pipeTwo;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/transformed-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TransformedResponse_response;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransformedResponse = void 0;
class TransformedResponse extends Response {
    constructor(response, transform){
        if (!response.body) {
            throw new TypeError('Response body is not available');
        }
        if (response.bodyUsed) {
            throw new TypeError('Response body is already used');
        }
        super(response.body.pipeThrough(transform), {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers
        });
        _TransformedResponse_response.set(this, void 0);
        __classPrivateFieldSet(this, _TransformedResponse_response, response, "f");
    }
    /**
     * Some props can't be set through ResponseInit, so we need to proxy them
     */ get url() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").url;
    }
    get redirected() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").redirected;
    }
    get type() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").type;
    }
    get statusText() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").statusText;
    }
}
exports.TransformedResponse = TransformedResponse;
_TransformedResponse_response = new WeakMap(); //# sourceMappingURL=transformed-response.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchResponseError = void 0;
exports.peekJson = peekJson;
exports.checkLength = checkLength;
exports.extractLength = extractLength;
exports.extractMime = extractMime;
exports.cancelBodyOnError = cancelBodyOnError;
exports.fetchOkProcessor = fetchOkProcessor;
exports.fetchOkTransformer = fetchOkTransformer;
exports.fetchMaxSizeProcessor = fetchMaxSizeProcessor;
exports.fetchResponseMaxSizeChecker = fetchResponseMaxSizeChecker;
exports.fetchTypeProcessor = fetchTypeProcessor;
exports.fetchResponseTypeChecker = fetchResponseTypeChecker;
exports.fetchResponseJsonTransformer = fetchResponseJsonTransformer;
exports.fetchJsonProcessor = fetchJsonProcessor;
exports.fetchJsonZodProcessor = fetchJsonZodProcessor;
const pipe_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)");
const fetch_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)");
const transformed_response_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/transformed-response.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)");
/**
 * media-type     = type "/" subtype *( ";" parameter )
 * type           = token
 * subtype        = token
 * token          = 1*<any CHAR except CTLs or separators>
 * separators     = "(" | ")" | "<" | ">" | "@"
 *                | "," | ";" | ":" | "\" | <">
 *                | "/" | "[" | "]" | "?" | "="
 *                | "{" | "}" | SP | HT
 * CTL            = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * SP             = <US-ASCII SP, space (32)>
 * HT             = <US-ASCII HT, horizontal-tab (9)>
 * @note The type, subtype, and parameter attribute names are case-insensitive.
 * @see {@link https://datatracker.ietf.org/doc/html/rfc2616#autoid-23}
 */ const JSON_MIME = /^application\/(?:[^()<>@,;:/[\]\\?={} \t]+\+)?json$/i;
class FetchResponseError extends fetch_error_js_1.FetchError {
    constructor(response, statusCode = response.status, message = response.statusText, options){
        super(statusCode, message, options);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: response
        });
    }
    static async from(response, customMessage = extractResponseMessage, statusCode = response.status, options) {
        const message = typeof customMessage === 'string' ? customMessage : typeof customMessage === 'function' ? await customMessage(response) : undefined;
        return new FetchResponseError(response, statusCode, message, options);
    }
}
exports.FetchResponseError = FetchResponseError;
const extractResponseMessage = async (response)=>{
    const mimeType = extractMime(response);
    if (!mimeType) return undefined;
    try {
        if (mimeType === 'text/plain') {
            return await response.text();
        } else if (JSON_MIME.test(mimeType)) {
            const json = await response.json();
            if (typeof json === 'string') return json;
            const errorDescription = (0, util_js_1.ifString)((0, util_js_1.ifObject)(json)?.['error_description']);
            if (errorDescription) return errorDescription;
            const error = (0, util_js_1.ifString)((0, util_js_1.ifObject)(json)?.['error']);
            if (error) return error;
            const message = (0, util_js_1.ifString)((0, util_js_1.ifObject)(json)?.['message']);
            if (message) return message;
        }
    } catch  {
    // noop
    }
    return undefined;
};
async function peekJson(response, maxSize = Infinity) {
    const type = extractMime(response);
    if (type !== 'application/json') return undefined;
    checkLength(response, maxSize);
    // 1) Clone the request so we can consume the body
    const clonedResponse = response.clone();
    // 2) Make sure the request's body is not too large
    const limitedResponse = response.body && maxSize < Infinity ? new transformed_response_js_1.TransformedResponse(clonedResponse, new util_js_1.MaxBytesTransformStream(maxSize)) : clonedResponse;
    // 3) Parse the JSON
    return limitedResponse.json();
}
function checkLength(response, maxBytes) {
    // Note: negation accounts for invalid value types (NaN, non numbers)
    if (!(maxBytes >= 0)) {
        throw new TypeError('maxBytes must be a non-negative number');
    }
    const length = extractLength(response);
    if (length != null && length > maxBytes) {
        throw new FetchResponseError(response, 502, 'Response too large');
    }
    return length;
}
function extractLength(response) {
    const contentLength = response.headers.get('Content-Length');
    if (contentLength == null) return undefined;
    if (!/^\d+$/.test(contentLength)) {
        throw new FetchResponseError(response, 502, 'Invalid Content-Length');
    }
    const length = Number(contentLength);
    if (!Number.isSafeInteger(length)) {
        throw new FetchResponseError(response, 502, 'Content-Length too large');
    }
    return length;
}
function extractMime(response) {
    const contentType = response.headers.get('Content-Type');
    if (contentType == null) return undefined;
    return contentType.split(';', 1)[0].trim();
}
/**
 * If the transformer results in an error, ensure that the response body is
 * consumed as, in some environments (Node ðŸ‘€), the response will not
 * automatically be GC'd.
 *
 * @see {@link https://undici.nodejs.org/#/?id=garbage-collection}
 * @param [onCancellationError] - Callback to handle any async body cancelling
 * error. Defaults to logging the error. Do not use `null` if the request is
 * cloned.
 */ function cancelBodyOnError(transformer, onCancellationError = util_js_1.logCancellationError) {
    return async (response)=>{
        try {
            return await transformer(response);
        } catch (err) {
            await (0, util_js_1.cancelBody)(response, onCancellationError ?? undefined);
            throw err;
        }
    };
}
function fetchOkProcessor(customMessage) {
    return cancelBodyOnError((response)=>{
        return fetchOkTransformer(response, customMessage);
    });
}
async function fetchOkTransformer(response, customMessage) {
    if (response.ok) return response;
    throw await FetchResponseError.from(response, customMessage);
}
function fetchMaxSizeProcessor(maxBytes) {
    if (maxBytes === Infinity) return (response)=>response;
    if (!Number.isFinite(maxBytes) || maxBytes < 0) {
        throw new TypeError('maxBytes must be a 0, Infinity or a positive number');
    }
    return cancelBodyOnError((response)=>{
        return fetchResponseMaxSizeChecker(response, maxBytes);
    });
}
function fetchResponseMaxSizeChecker(response, maxBytes) {
    if (maxBytes === Infinity) return response;
    checkLength(response, maxBytes);
    // Some engines (react-native ðŸ‘€) don't expose a body property. In that case,
    // we will only rely on the Content-Length header.
    if (!response.body) return response;
    const transform = new util_js_1.MaxBytesTransformStream(maxBytes);
    return new transformed_response_js_1.TransformedResponse(response, transform);
}
function fetchTypeProcessor(expectedMime, contentTypeRequired = true) {
    const isExpected = typeof expectedMime === 'string' ? (mimeType)=>mimeType === expectedMime : expectedMime instanceof RegExp ? (mimeType)=>expectedMime.test(mimeType) : expectedMime;
    return cancelBodyOnError((response)=>{
        return fetchResponseTypeChecker(response, isExpected, contentTypeRequired);
    });
}
async function fetchResponseTypeChecker(response, isExpectedMime, contentTypeRequired = true) {
    const mimeType = extractMime(response);
    if (mimeType) {
        if (!isExpectedMime(mimeType.toLowerCase())) {
            throw await FetchResponseError.from(response, `Unexpected response Content-Type (${mimeType})`, 502);
        }
    } else if (contentTypeRequired) {
        throw await FetchResponseError.from(response, 'Missing response Content-Type header', 502);
    }
    return response;
}
async function fetchResponseJsonTransformer(response) {
    try {
        const json = await response.json();
        return {
            response,
            json
        };
    } catch (cause) {
        throw new FetchResponseError(response, 502, 'Unable to parse response as JSON', {
            cause
        });
    }
}
function fetchJsonProcessor(expectedMime = JSON_MIME, contentTypeRequired = true) {
    return (0, pipe_1.pipe)(fetchTypeProcessor(expectedMime, contentTypeRequired), cancelBodyOnError(fetchResponseJsonTransformer));
}
function fetchJsonZodProcessor(schema, params) {
    return async (jsonResponse)=>schema.parseAsync(jsonResponse.json, params);
} //# sourceMappingURL=fetch-response.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-wrap.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.timedFetch = void 0;
exports.loggedFetch = loggedFetch;
exports.bindFetch = bindFetch;
const fetch_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-request.js [app-ssr] (ecmascript)");
const fetch_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)");
const transformed_response_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/transformed-response.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)");
function loggedFetch({ fetch = globalThis.fetch, logRequest = true, logResponse = true, logError = true }) {
    const onRequest = logRequest === true ? async (request)=>{
        const requestMessage = await (0, util_js_1.stringifyMessage)(request);
        console.info(`> ${request.method} ${request.url}\n${(0, util_js_1.padLines)(requestMessage, '  ')}`);
    } : logRequest || undefined;
    const onResponse = logResponse === true ? async (response)=>{
        const responseMessage = await (0, util_js_1.stringifyMessage)(response.clone());
        console.info(`< HTTP/1.1 ${response.status} ${response.statusText}\n${(0, util_js_1.padLines)(responseMessage, '  ')}`);
    } : logResponse || undefined;
    const onError = logError === true ? async (error)=>{
        console.error(`< Error:`, error);
    } : logError || undefined;
    if (!onRequest && !onResponse && !onError) return fetch;
    return (0, fetch_js_1.toRequestTransformer)(async function(request) {
        if (onRequest) await onRequest(request);
        try {
            const response = await fetch.call(this, request);
            if (onResponse) await onResponse(response, request);
            return response;
        } catch (error) {
            if (onError) await onError(error, request);
            throw error;
        }
    });
}
const timedFetch = (timeout = 60e3, fetch = globalThis.fetch)=>{
    if (timeout === Infinity) return fetch;
    if (!Number.isFinite(timeout) || timeout <= 0) {
        throw new TypeError('Timeout must be positive');
    }
    return (0, fetch_js_1.toRequestTransformer)(async function(request) {
        const controller = new AbortController();
        const signal = controller.signal;
        const abort = ()=>{
            controller.abort();
        };
        const cleanup = ()=>{
            clearTimeout(timer);
            request.signal?.removeEventListener('abort', abort);
        };
        const timer = setTimeout(abort, timeout);
        if (typeof timer === 'object') timer.unref?.(); // only on node
        request.signal?.addEventListener('abort', abort);
        signal.addEventListener('abort', cleanup);
        const response = await fetch.call(this, request, {
            signal
        });
        if (!response.body) {
            cleanup();
            return response;
        } else {
            // Cleanup the timer & event listeners when the body stream is closed
            const transform = new TransformStream({
                flush: cleanup
            });
            return new transformed_response_js_1.TransformedResponse(response, transform);
        }
    });
};
exports.timedFetch = timedFetch;
/**
 * Wraps a fetch function to bind it to a specific context, and wrap any thrown
 * errors into a FetchRequestError.
 *
 * @example
 *
 * ```ts
 * class MyClient {
 *   constructor(private fetch = globalThis.fetch) {}
 *
 *   async get(url: string) {
 *     // This will generate an error, because the context used is not a
 *     // FetchContext (it's a MyClient instance).
 *     return this.fetch(url)
 *   }
 * }
 * ```
 *
 * @example
 *
 * ```ts
 * class MyClient {
 *   private fetch: Fetch<unknown>
 *
 *   constructor(fetch = globalThis.fetch) {
 *     this.fetch = bindFetch(fetch)
 *   }
 *
 *   async get(url: string) {
 *     return this.fetch(url) // no more error
 *   }
 * }
 * ```
 */ function bindFetch(fetch = globalThis.fetch, context = globalThis) {
    return (0, fetch_js_1.toRequestTransformer)(async (request)=>{
        try {
            return await fetch.call(context, request);
        } catch (err) {
            throw fetch_request_js_1.FetchRequestError.from(request, err);
        }
    });
} //# sourceMappingURL=fetch-wrap.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-wrap.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidResolverBase = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
class DidResolverBase {
    constructor(methods){
        Object.defineProperty(this, "methods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.methods = new Map(Object.entries(methods));
    }
    async resolve(did, options) {
        options?.signal?.throwIfAborted();
        const method = (0, did_1.extractDidMethod)(did);
        const resolver = this.methods.get(method);
        if (!resolver) {
            throw new did_1.DidError(did, `Unsupported DID method`, 'did-method-invalid', 400);
        }
        try {
            const document = await resolver.resolve(did, options);
            if (document.id !== did) {
                throw new did_1.DidError(did, `DID document id (${document.id}) does not match DID`, 'did-document-id-mismatch', 400);
            }
            return document;
        } catch (err) {
            if (err instanceof fetch_1.FetchRequestError) {
                throw new did_1.DidError(did, err.message, 'did-fetch-error', 400, err);
            }
            if (err instanceof zod_1.ZodError) {
                throw new did_1.DidError(did, err.message, 'did-document-format-error', 503, err);
            }
            throw did_1.DidError.from(err, did);
        }
    }
}
exports.DidResolverBase = DidResolverBase; //# sourceMappingURL=did-resolver-base.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/methods/plc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidPlcMethod = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const pipe_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const fetchSuccessHandler = (0, pipe_1.pipe)((0, fetch_1.fetchOkProcessor)(), (0, fetch_1.fetchJsonProcessor)(/^application\/(did\+ld\+)?json$/), (0, fetch_1.fetchJsonZodProcessor)(did_1.didDocumentValidator));
class DidPlcMethod {
    constructor(options){
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "plcDirectoryUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.plcDirectoryUrl = new URL(options?.plcDirectoryUrl || 'https://plc.directory/');
        this.fetch = (0, fetch_1.bindFetch)(options?.fetch);
    }
    async resolve(did, options) {
        // Although the did should start with `did:plc:` (thanks to typings), we
        // should still check if the msid is valid.
        (0, did_1.assertDidPlc)(did);
        const url = new URL(`/${encodeURIComponent(did)}`, this.plcDirectoryUrl);
        return this.fetch(url, {
            redirect: 'error',
            headers: {
                accept: 'application/did+ld+json,application/json'
            },
            signal: options?.signal
        }).then(fetchSuccessHandler);
    }
}
exports.DidPlcMethod = DidPlcMethod; //# sourceMappingURL=plc.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/methods/web.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidWebMethod = void 0;
exports.buildDidWebDocumentUrl = buildDidWebDocumentUrl;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const pipe_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const fetchSuccessHandler = (0, pipe_1.pipe)((0, fetch_1.fetchOkProcessor)(), (0, fetch_1.fetchJsonProcessor)(/^application\/(did\+ld\+)?json$/), (0, fetch_1.fetchJsonZodProcessor)(did_1.didDocumentValidator));
class DidWebMethod {
    constructor({ fetch = globalThis.fetch, allowHttp = true } = {}){
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttp = allowHttp;
    }
    async resolve(did, options) {
        const didDocumentUrl = buildDidWebDocumentUrl(did);
        if (!this.allowHttp && didDocumentUrl.protocol === 'http:') {
            throw new Error(`Cannot resolve DID document for localhost: ${didDocumentUrl}`);
        }
        // Note we do not explicitly check for "localhost" here. Instead, we rely on
        // the injected 'fetch' function to handle the URL. If the URL is
        // "localhost", or resolves to a private IP address, the fetch function is
        // responsible for handling it.
        return this.fetch(didDocumentUrl, {
            redirect: 'error',
            headers: {
                accept: 'application/did+ld+json,application/json'
            },
            signal: options?.signal
        }).then(fetchSuccessHandler);
    }
}
exports.DidWebMethod = DidWebMethod;
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8615}
 * @see {@link https://w3c-ccg.github.io/did-method-web/#create-register}
 */ function buildDidWebDocumentUrl(did) {
    const url = (0, did_1.didWebToUrl)(did); // Will throw if the DID is invalid
    // Note: DID cannot end with an `:`, so they cannot end with a `/`. This is
    // true unless when there is no path at all, in which case the URL constructor
    // will set the pathname to `/`.
    // https://w3c-ccg.github.io/did-method-web/#read-resolve
    if (url.pathname === '/') {
        return new URL(`/.well-known/did.json`, url);
    } else {
        return new URL(`${url.pathname}/did.json`, url);
    }
} //# sourceMappingURL=web.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-common.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidResolverCommon = void 0;
const did_resolver_base_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-base.js [app-ssr] (ecmascript)");
const plc_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/plc.js [app-ssr] (ecmascript)");
const web_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/web.js [app-ssr] (ecmascript)");
class DidResolverCommon extends did_resolver_base_js_1.DidResolverBase {
    constructor(options){
        super({
            plc: new plc_js_1.DidPlcMethod(options),
            web: new web_js_1.DidWebMethod(options)
        });
    }
}
exports.DidResolverCommon = DidResolverCommon; //# sourceMappingURL=did-resolver-common.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=did-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/methods.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/plc.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/web.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=methods.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache-memory.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-method.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-common.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/util.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isResolvedHandle = isResolvedHandle;
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://atproto.com/specs/did#blessed-did-methods}
 */ function isResolvedHandle(value) {
    return value === null || (0, did_1.isAtprotoDid)(value);
} //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/app-view-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppViewHandleResolver = exports.xrpcErrorSchema = void 0;
const zod_1 = __importDefault(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)"));
const types_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)");
exports.xrpcErrorSchema = zod_1.default.object({
    error: zod_1.default.string(),
    message: zod_1.default.string().optional()
});
class AppViewHandleResolver {
    static from(service, options) {
        if (typeof service === 'string' || service instanceof URL) {
            return new AppViewHandleResolver(service, options);
        }
        return service;
    }
    constructor(service, options){
        /**
         * URL of the atproto lexicon server. This is the base URL where the
         * `com.atproto.identity.resolveHandle` XRPC method is located.
         */ Object.defineProperty(this, "serviceUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serviceUrl = new URL(service);
        this.fetch = options?.fetch ?? globalThis.fetch;
    }
    async resolve(handle, options) {
        const url = new URL('/xrpc/com.atproto.identity.resolveHandle', this.serviceUrl);
        url.searchParams.set('handle', handle);
        const response = await this.fetch.call(null, url, {
            cache: options?.noCache ? 'no-cache' : undefined,
            signal: options?.signal,
            redirect: 'error'
        });
        const payload = await response.json();
        // The response should either be
        // - 400 Bad Request with { error: 'InvalidRequest', message: 'Unable to resolve handle' }
        // - 200 OK with { did: NonNullable<ResolvedHandle> }
        // Any other response is considered unexpected behavior an should throw an error.
        if (response.status === 400) {
            const data = exports.xrpcErrorSchema.parse(payload);
            if (data.error === 'InvalidRequest' && data.message === 'Unable to resolve handle') {
                return null;
            }
        }
        if (!response.ok) {
            throw new TypeError('Invalid response from resolveHandle method');
        }
        const value = payload?.did;
        if (!(0, types_js_1.isResolvedHandle)(value)) {
            throw new TypeError('Invalid DID returned from resolveHandle method');
        }
        return value;
    }
}
exports.AppViewHandleResolver = AppViewHandleResolver; //# sourceMappingURL=app-view-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/dns-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DnsHandleResolver = void 0;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)");
const SUBDOMAIN = '_atproto';
const PREFIX = 'did=';
class DnsHandleResolver {
    constructor(resolveTxt){
        Object.defineProperty(this, "resolveTxt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolveTxt
        });
    }
    async resolve(handle) {
        const results = await this.resolveTxt.call(null, `${SUBDOMAIN}.${handle}`);
        if (!results) return null;
        for(let i = 0; i < results.length; i++){
            // If the line does not start with "did=", skip it
            if (!results[i].startsWith(PREFIX)) continue;
            // Ensure no other entry starting with "did=" follows
            for(let j = i + 1; j < results.length; j++){
                if (results[j].startsWith(PREFIX)) return null;
            }
            // Note: No trimming (to be consistent with spec)
            const did = results[i].slice(PREFIX.length);
            // Invalid DBS record
            return (0, types_1.isResolvedHandle)(did) ? did : null;
        }
        return null;
    }
}
exports.DnsHandleResolver = DnsHandleResolver; //# sourceMappingURL=dns-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/well-known-handler-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WellKnownHandleResolver = void 0;
const types_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)");
class WellKnownHandleResolver {
    constructor(options){
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = options?.fetch ?? globalThis.fetch;
    }
    async resolve(handle, options) {
        const url = new URL('/.well-known/atproto-did', `https://${handle}`);
        try {
            const response = await this.fetch.call(null, url, {
                cache: options?.noCache ? 'no-cache' : undefined,
                signal: options?.signal,
                redirect: 'error'
            });
            const text = await response.text();
            const firstLine = text.split('\n')[0].trim();
            if ((0, types_js_1.isResolvedHandle)(firstLine)) return firstLine;
            return null;
        } catch (err) {
            // The the request failed, assume the handle does not resolve to a DID,
            // unless the failure was due to the signal being aborted.
            options?.signal?.throwIfAborted();
            return null;
        }
    }
}
exports.WellKnownHandleResolver = WellKnownHandleResolver; //# sourceMappingURL=well-known-handler-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtprotoHandleResolver = void 0;
const dns_handle_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/dns-handle-resolver.js [app-ssr] (ecmascript)");
const well_known_handler_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/well-known-handler-resolver.js [app-ssr] (ecmascript)");
const noop = ()=>{};
/**
 * Implementation of the official ATPROTO handle resolution strategy.
 * This implementation relies on two primitives:
 * - HTTP Well-Known URI resolution (requires a `fetch()` implementation)
 * - DNS TXT record resolution (requires a `resolveTxt()` function)
 */ class AtprotoHandleResolver {
    constructor(options){
        Object.defineProperty(this, "httpResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dnsResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dnsResolverFallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.httpResolver = new well_known_handler_resolver_js_1.WellKnownHandleResolver(options);
        this.dnsResolver = new dns_handle_resolver_js_1.DnsHandleResolver(options.resolveTxt);
        this.dnsResolverFallback = options.resolveTxtFallback ? new dns_handle_resolver_js_1.DnsHandleResolver(options.resolveTxtFallback) : undefined;
    }
    async resolve(handle, options) {
        options?.signal?.throwIfAborted();
        const abortController = new AbortController();
        const { signal } = abortController;
        options?.signal?.addEventListener('abort', ()=>abortController.abort(), {
            signal
        });
        const wrappedOptions = {
            ...options,
            signal
        };
        try {
            const dnsPromise = this.dnsResolver.resolve(handle, wrappedOptions);
            const httpPromise = this.httpResolver.resolve(handle, wrappedOptions);
            // Prevent uncaught promise rejection
            httpPromise.catch(noop);
            const dnsRes = await dnsPromise;
            if (dnsRes) return dnsRes;
            signal.throwIfAborted();
            const res = await httpPromise;
            if (res) return res;
            signal.throwIfAborted();
            return this.dnsResolverFallback?.resolve(handle, wrappedOptions) ?? null;
        } finally{
            // Cancel pending requests, and remove "abort" listener on incoming signal
            abortController.abort();
        }
    }
}
exports.AtprotoHandleResolver = AtprotoHandleResolver; //# sourceMappingURL=atproto-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-doh-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtprotoDohHandleResolver = void 0;
const atproto_handle_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-handle-resolver.js [app-ssr] (ecmascript)");
class AtprotoDohHandleResolver extends atproto_handle_resolver_js_1.AtprotoHandleResolver {
    constructor(options){
        super({
            ...options,
            resolveTxt: dohResolveTxtFactory(options),
            resolveTxtFallback: undefined
        });
    }
}
exports.AtprotoDohHandleResolver = AtprotoDohHandleResolver;
/**
 * Resolver for DNS-over-HTTPS (DoH) handles. Only works with servers supporting
 * Google Flavoured "application/dns-json" queries.
 *
 * @see {@link https://developers.google.com/speed/public-dns/docs/doh/json}
 * @see {@link https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/}
 * @todo Add support for DoH using application/dns-message (?)
 */ function dohResolveTxtFactory({ dohEndpoint, fetch = globalThis.fetch }) {
    return async (hostname)=>{
        const url = new URL(dohEndpoint);
        url.searchParams.set('type', 'TXT');
        url.searchParams.set('name', hostname);
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                accept: 'application/dns-json'
            },
            redirect: 'follow'
        });
        try {
            const contentType = response.headers.get('content-type')?.trim();
            if (!response.ok) {
                const message = contentType?.startsWith('text/plain') ? await response.text() : `Failed to resolve ${hostname}`;
                throw new TypeError(message);
            } else if (contentType?.match(/application\/(dns-)?json/i) == null) {
                throw new TypeError('Unexpected response from DoH server');
            }
            const result = asResult(await response.json());
            return result.Answer?.filter(isAnswerTxt).map(extractTxtData) ?? null;
        } finally{
            // Make sure to always cancel the response body as some engines (Node ðŸ‘€)
            // do not do this automatically.
            // https://undici.nodejs.org/#/?id=garbage-collection
            if (response.bodyUsed === false) {
                // Handle rejection asynchronously
                void response.body?.cancel().catch(onCancelError);
            }
        }
    };
}
function onCancelError(err) {
    if (!(err instanceof DOMException) || err.name !== 'AbortError') {
        console.error('An error occurred while cancelling the response body:', err);
    }
}
function isResult(result) {
    if (typeof result !== 'object' || result === null) return false;
    if (!('Status' in result) || typeof result.Status !== 'number') return false;
    if ('Answer' in result && !isArrayOf(result.Answer, isAnswer)) return false;
    return true;
}
function asResult(result) {
    if (isResult(result)) return result;
    throw new TypeError('Invalid DoH response');
}
function isArrayOf(value, predicate) {
    return Array.isArray(value) && value.every(predicate);
}
function isAnswer(answer) {
    return typeof answer === 'object' && answer !== null && 'name' in answer && typeof answer.name === 'string' && 'type' in answer && typeof answer.type === 'number' && 'data' in answer && typeof answer.data === 'string' && 'TTL' in answer && typeof answer.TTL === 'number';
}
function isAnswerTxt(answer) {
    return answer.type === 16;
}
function extractTxtData(answer) {
    return answer.data.replace(/^"|"$/g, '').replace(/\\"/g, '"');
} //# sourceMappingURL=atproto-doh-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/cached-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CachedHandleResolver = void 0;
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const simple_store_memory_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)");
class CachedHandleResolver {
    constructor(/**
     * The resolver that will be used to resolve handles.
     */ resolver, cache = new simple_store_memory_1.SimpleStoreMemory({
        max: 1000,
        ttl: 10 * 60e3
    })){
        Object.defineProperty(this, "getter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.getter = new simple_store_1.CachedGetter((handle, options)=>resolver.resolve(handle, options), cache);
    }
    async resolve(handle, options) {
        return this.getter.get(handle, options);
    }
}
exports.CachedHandleResolver = CachedHandleResolver; //# sourceMappingURL=cached-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)"), exports);
// Main Handle Resolvers strategies
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/app-view-handle-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-doh-handle-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-handle-resolver.js [app-ssr] (ecmascript)"), exports);
// Handle Resolver Caching utility
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/cached-handle-resolver.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CLIENT_ASSERTION_TYPE_JWT_BEARER = void 0;
exports.CLIENT_ASSERTION_TYPE_JWT_BEARER = 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isHostnameIP = isHostnameIP;
exports.isLoopbackHost = isLoopbackHost;
exports.isLoopbackUrl = isLoopbackUrl;
exports.safeUrl = safeUrl;
exports.extractUrlPath = extractUrlPath;
function isHostnameIP(hostname) {
    // IPv4
    if (hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) return true;
    // IPv6
    if (hostname.startsWith('[') && hostname.endsWith(']')) return true;
    return false;
}
function isLoopbackHost(host) {
    return host === 'localhost' || host === '127.0.0.1' || host === '[::1]';
}
function isLoopbackUrl(input) {
    const url = typeof input === 'string' ? new URL(input) : input;
    return isLoopbackHost(url.hostname);
}
function safeUrl(input) {
    try {
        return new URL(input);
    } catch  {
        return null;
    }
}
function extractUrlPath(url) {
    // Extracts the path from a URL, without relying on the URL constructor
    // (because it normalizes the URL)
    const endOfProtocol = url.startsWith('https://') ? 8 : url.startsWith('http://') ? 7 : -1;
    if (endOfProtocol === -1) {
        throw new TypeError('URL must use the "https:" or "http:" protocol');
    }
    const hashIdx = url.indexOf('#', endOfProtocol);
    const questionIdx = url.indexOf('?', endOfProtocol);
    const queryStrIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx) ? questionIdx : -1;
    const pathEnd = hashIdx === -1 ? queryStrIdx === -1 ? url.length : queryStrIdx : queryStrIdx === -1 ? hashIdx : Math.min(hashIdx, queryStrIdx);
    const slashIdx = url.indexOf('/', endOfProtocol);
    const pathStart = slashIdx === -1 || slashIdx > pathEnd ? pathEnd : slashIdx;
    if (endOfProtocol === pathStart) {
        throw new TypeError('URL must contain a host');
    }
    return url.substring(pathStart, pathEnd);
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.privateUseUriSchema = exports.webUriSchema = exports.httpsUriSchema = exports.loopbackUriSchema = exports.dangerousUriSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)");
/**
 * Valid, but potentially dangerous URL (`data:`, `file:`, `javascript:`, etc.).
 *
 * Any value that matches this schema is safe to parse using `new URL()`.
 */ exports.dangerousUriSchema = zod_1.z.string().refine((data)=>data.includes(':') && URL.canParse(data), {
    message: 'Invalid URL'
});
exports.loopbackUriSchema = exports.dangerousUriSchema.superRefine((value, ctx)=>{
    // Loopback url must use the "http:" protocol
    if (!value.startsWith('http://')) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'URL must use the "http:" protocol'
        });
        return false;
    }
    const url = new URL(value);
    if (!(0, util_js_1.isLoopbackHost)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'URL must use "localhost", "127.0.0.1" or "[::1]" as hostname'
        });
        return false;
    }
    return true;
});
exports.httpsUriSchema = exports.dangerousUriSchema.superRefine((value, ctx)=>{
    if (!value.startsWith('https://')) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'URL must use the "https:" protocol'
        });
        return false;
    }
    const url = new URL(value);
    // Disallow loopback URLs with the `https:` protocol
    if ((0, util_js_1.isLoopbackHost)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'https: URL must not use a loopback host'
        });
        return false;
    }
    if ((0, util_js_1.isHostnameIP)(url.hostname)) {
    // Hostname is an IP address
    } else {
        // Hostname is a domain name
        if (!url.hostname.includes('.')) {
            // we don't depend on PSL here, so we only check for a dot
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: 'Domain name must contain at least two segments'
            });
            return false;
        }
        if (url.hostname.endsWith('.local')) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: 'Domain name must not end with ".local"'
            });
            return false;
        }
    }
    return true;
});
exports.webUriSchema = zod_1.z.string().superRefine((value, ctx)=>{
    // discriminated union of `loopbackUriSchema` and `httpsUriSchema`
    if (value.startsWith('http://')) {
        const result = exports.loopbackUriSchema.safeParse(value);
        if (!result.success) result.error.issues.forEach(ctx.addIssue, ctx);
        return result.success;
    }
    if (value.startsWith('https://')) {
        const result = exports.httpsUriSchema.safeParse(value);
        if (!result.success) result.error.issues.forEach(ctx.addIssue, ctx);
        return result.success;
    }
    ctx.addIssue({
        code: zod_1.ZodIssueCode.custom,
        message: 'URL must use the "http:" or "https:" protocol'
    });
    return false;
});
exports.privateUseUriSchema = exports.dangerousUriSchema.superRefine((value, ctx)=>{
    const dotIdx = value.indexOf('.');
    const colonIdx = value.indexOf(':');
    // Optimization: avoid parsing the URL if the protocol does not contain a "."
    if (dotIdx === -1 || colonIdx === -1 || dotIdx > colonIdx) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Private-use URI scheme requires a "." as part of the protocol'
        });
        return false;
    }
    const url = new URL(value);
    // Should be covered by the check before, but let's be extra sure
    if (!url.protocol.includes('.')) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Invalid private-use URI scheme'
        });
        return false;
    }
    if (url.hostname) {
        // https://datatracker.ietf.org/doc/html/rfc8252#section-7.1
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Private-use URI schemes must not include a hostname (only one "/" is allowed after the protocol, as per RFC 8252)'
        });
        return false;
    }
    return true;
}); //# sourceMappingURL=uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientIdSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthClientIdSchema = zod_1.z.string().min(1); //# sourceMappingURL=oauth-client-id.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRedirectUriSchema = exports.oauthPrivateUseRedirectURISchema = exports.oauthHttpsRedirectURISchema = exports.oauthLoopbackRedirectURISchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
exports.oauthLoopbackRedirectURISchema = uri_js_1.loopbackUriSchema.superRefine((value, ctx)=>{
    if (value.startsWith('http://localhost')) {
        // https://datatracker.ietf.org/doc/html/rfc8252#section-8.3
        //
        // > While redirect URIs using localhost (i.e.,
        // > "http://localhost:{port}/{path}") function similarly to loopback IP
        // > redirects described in Section 7.3, the use of localhost is NOT
        // > RECOMMENDED.  Specifying a redirect URI with the loopback IP literal
        // > rather than localhost avoids inadvertently listening on network
        // > interfaces other than the loopback interface.  It is also less
        // > susceptible to client-side firewalls and misconfigured host name
        // > resolution on the user's device.
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Use of "localhost" hostname is not allowed (RFC 8252), use a loopback IP such as "127.0.0.1" instead'
        });
        return false;
    }
    return true;
});
exports.oauthHttpsRedirectURISchema = uri_js_1.httpsUriSchema;
exports.oauthPrivateUseRedirectURISchema = uri_js_1.privateUseUriSchema;
exports.oauthRedirectUriSchema = zod_1.z.union([
    exports.oauthLoopbackRedirectURISchema,
    exports.oauthHttpsRedirectURISchema,
    exports.oauthPrivateUseRedirectURISchema
], {
    message: `URL must use the "https:" or "http:" protocol, or a private-use URI scheme (RFC 8252)`
}); //# sourceMappingURL=oauth-redirect-uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthScopeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
/**
 * A space separated list of most non-control ASCII characters except backslash
 * and double quote.
 *
 * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-1.4.1}
 */ exports.oauthScopeSchema = zod_1.z.string()// scope       = scope-token *( SP scope-token )
// scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
.regex(/^[\x21\x23-\x5B\x5D-\x7E]+(?: [\x21\x23-\x5B\x5D-\x7E]+)*$/); //# sourceMappingURL=oauth-scope.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-loopback.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientIdLoopbackSchema = void 0;
exports.isOAuthClientIdLoopback = isOAuthClientIdLoopback;
exports.assertOAuthLoopbackClientId = assertOAuthLoopbackClientId;
exports.parseOAuthLoopbackClientId = parseOAuthLoopbackClientId;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
const oauth_scope_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)");
const PREFIX = 'http://localhost';
exports.oauthClientIdLoopbackSchema = oauth_client_id_js_1.oauthClientIdSchema.superRefine((value, ctx)=>{
    try {
        assertOAuthLoopbackClientId(value);
        return true;
    } catch (error) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: error instanceof TypeError ? error.message : 'Invalid loopback client ID'
        });
        return false;
    }
});
function isOAuthClientIdLoopback(clientId) {
    try {
        parseOAuthLoopbackClientId(clientId);
        return true;
    } catch  {
        return false;
    }
}
function assertOAuthLoopbackClientId(clientId) {
    void parseOAuthLoopbackClientId(clientId);
}
// @TODO: should we turn this into a zod schema? (more coherent error with other
// validation functions)
function parseOAuthLoopbackClientId(clientId) {
    if (!clientId.startsWith(PREFIX)) {
        throw new TypeError(`Loopback ClientID must start with "${PREFIX}"`);
    } else if (clientId.includes('#', PREFIX.length)) {
        throw new TypeError('Loopback ClientID must not contain a hash component');
    }
    const queryStringIdx = clientId.length > PREFIX.length && clientId[PREFIX.length] === '/' ? PREFIX.length + 1 : PREFIX.length;
    if (clientId.length === queryStringIdx) {
        return {}; // no query string to parse
    }
    if (clientId[queryStringIdx] !== '?') {
        throw new TypeError('Loopback ClientID must not contain a path component');
    }
    const searchParams = new URLSearchParams(clientId.slice(queryStringIdx + 1));
    for (const name of searchParams.keys()){
        if (name !== 'redirect_uri' && name !== 'scope') {
            throw new TypeError(`Invalid query parameter "${name}" in client ID`);
        }
    }
    const scope = searchParams.get('scope') ?? undefined;
    if (scope != null) {
        if (searchParams.getAll('scope').length > 1) {
            throw new TypeError('Loopback ClientID must contain at most one scope query parameter');
        } else if (!oauth_scope_js_1.oauthScopeSchema.safeParse(scope).success) {
            throw new TypeError('Invalid scope query parameter in client ID');
        }
    }
    const redirect_uris = searchParams.has('redirect_uri') ? searchParams.getAll('redirect_uri').map((value)=>oauth_redirect_uri_js_1.oauthLoopbackRedirectURISchema.parse(value)) : undefined;
    return {
        scope,
        redirect_uris
    };
} //# sourceMappingURL=oauth-client-id-loopback.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/atproto-loopback-client-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atprotoLoopbackClientMetadata = atprotoLoopbackClientMetadata;
const oauth_client_id_loopback_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-loopback.js [app-ssr] (ecmascript)");
function atprotoLoopbackClientMetadata(clientId) {
    const { scope = 'atproto', redirect_uris = [
        `http://127.0.0.1/`,
        `http://[::1]/`
    ] } = (0, oauth_client_id_loopback_js_1.parseOAuthLoopbackClientId)(clientId);
    return {
        client_id: clientId,
        scope,
        redirect_uris,
        client_name: 'Loopback client',
        response_types: [
            'code'
        ],
        grant_types: [
            'authorization_code',
            'refresh_token'
        ],
        token_endpoint_auth_method: 'none',
        application_type: 'native',
        dpop_bound_access_tokens: true
    };
} //# sourceMappingURL=atproto-loopback-client-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-access-token.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAccessTokenSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthAccessTokenSchema = zod_1.z.string().min(1); //# sourceMappingURL=oauth-access-token.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-code-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationCodeGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationCodeGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('authorization_code'),
    code: zod_1.z.string().min(1),
    redirect_uri: oauth_redirect_uri_js_1.oauthRedirectUriSchema,
    /** @see {@link https://datatracker.ietf.org/doc/html/rfc7636#section-4.1} */ code_verifier: zod_1.z.string().min(43).max(128).regex(/^[a-zA-Z0-9-._~]+$/).optional()
}); //# sourceMappingURL=oauth-authorization-code-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationDetailsSchema = exports.oauthAuthorizationDetailSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9396#section-2 | RFC 9396, Section 2}
 */ exports.oauthAuthorizationDetailSchema = zod_1.z.object({
    type: zod_1.z.string(),
    /**
     * An array of strings representing the location of the resource or RS. These
     * strings are typically URIs identifying the location of the RS.
     */ locations: zod_1.z.array(uri_js_1.dangerousUriSchema).optional(),
    /**
     * An array of strings representing the kinds of actions to be taken at the
     * resource.
     */ actions: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * An array of strings representing the kinds of data being requested from the
     * resource.
     */ datatypes: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * A string identifier indicating a specific resource available at the API.
     */ identifier: zod_1.z.string().optional(),
    /**
     * An array of strings representing the types or levels of privilege being
     * requested at the resource.
     */ privileges: zod_1.z.array(zod_1.z.string()).optional()
});
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9396#section-2 | RFC 9396, Section 2}
 */ exports.oauthAuthorizationDetailsSchema = zod_1.z.array(exports.oauthAuthorizationDetailSchema); //# sourceMappingURL=oauth-authorization-details.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestJarSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestJarSchema = zod_1.z.object({
    /**
     * AuthorizationRequest inside a JWT:
     * - "iat" is required and **MUST** be less than one minute
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc9101}
     */ request: zod_1.z.union([
        jwk_1.signedJwtSchema,
        jwk_1.unsignedJwtSchema
    ])
}); //# sourceMappingURL=oauth-authorization-request-jar.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-code-challenge-method.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthCodeChallengeMethodSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthCodeChallengeMethodSchema = zod_1.z.enum([
    'S256',
    'plain'
]); //# sourceMappingURL=oauth-code-challenge-method.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthResponseTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthResponseTypeSchema = zod_1.z.enum([
    // OAuth2 (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#section-4.1.1)
    'code',
    'token',
    // OIDC (https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html)
    'none',
    'code id_token token',
    'code id_token',
    'code token',
    'id_token token',
    'id_token'
]); //# sourceMappingURL=oauth-response-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-parameter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oidcClaimsParameterSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oidcClaimsParameterSchema = zod_1.z.enum([
    // https://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html#rfc.section.5.2
    // if client metadata "require_auth_time" is true, this *must* be provided
    'auth_time',
    // OIDC
    'nonce',
    'acr',
    // OpenID: "profile" scope
    'name',
    'family_name',
    'given_name',
    'middle_name',
    'nickname',
    'preferred_username',
    'gender',
    'picture',
    'profile',
    'website',
    'birthdate',
    'zoneinfo',
    'locale',
    'updated_at',
    // OpenID: "email" scope
    'email',
    'email_verified',
    // OpenID: "phone" scope
    'phone_number',
    'phone_number_verified',
    // OpenID: "address" scope
    'address'
]); //# sourceMappingURL=oidc-claims-parameter.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-properties.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oidcClaimsPropertiesSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oidcClaimsValueSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number(),
    zod_1.z.boolean()
]);
exports.oidcClaimsPropertiesSchema = zod_1.z.object({
    essential: zod_1.z.boolean().optional(),
    value: oidcClaimsValueSchema.optional(),
    values: zod_1.z.array(oidcClaimsValueSchema).optional()
}); //# sourceMappingURL=oidc-claims-properties.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oidc-entity-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oidcEntityTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oidcEntityTypeSchema = zod_1.z.enum([
    'userinfo',
    'id_token'
]); //# sourceMappingURL=oidc-entity-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestParametersSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_details_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const oauth_code_challenge_method_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-code-challenge-method.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
const oauth_response_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)");
const oauth_scope_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)");
const oidc_claims_parameter_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-parameter.js [app-ssr] (ecmascript)");
const oidc_claims_properties_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-properties.js [app-ssr] (ecmascript)");
const oidc_entity_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-entity-type.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest | OIDC}
 */ exports.oauthAuthorizationRequestParametersSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema,
    state: zod_1.z.string().optional(),
    redirect_uri: oauth_redirect_uri_js_1.oauthRedirectUriSchema.optional(),
    scope: oauth_scope_js_1.oauthScopeSchema.optional(),
    response_type: oauth_response_type_js_1.oauthResponseTypeSchema,
    // PKCE
    code_challenge: zod_1.z.string().optional(),
    code_challenge_method: oauth_code_challenge_method_js_1.oauthCodeChallengeMethodSchema.default('S256').optional(),
    // DPOP
    // https://datatracker.ietf.org/doc/html/rfc9449#section-12.3
    dpop_jkt: zod_1.z.string().optional(),
    // OIDC
    // Default depend on response_type
    response_mode: zod_1.z.enum([
        'query',
        'fragment',
        'form_post'
    ]).optional(),
    nonce: zod_1.z.string().optional(),
    // Specifies the allowable elapsed time in seconds since the last time the
    // End-User was actively authenticated by the OP. If the elapsed time is
    // greater than this value, the OP MUST attempt to actively re-authenticate
    // the End-User. (The max_age request parameter corresponds to the OpenID 2.0
    // PAPE [OpenID.PAPE] max_auth_age request parameter.) When max_age is used,
    // the ID Token returned MUST include an auth_time Claim Value. Note that
    // max_age=0 is equivalent to prompt=login.
    max_age: zod_1.z.number().int().min(0).optional(),
    claims: zod_1.z.record(oidc_entity_type_js_1.oidcEntityTypeSchema, zod_1.z.record(oidc_claims_parameter_js_1.oidcClaimsParameterSchema, zod_1.z.union([
        zod_1.z.literal(null),
        oidc_claims_properties_js_1.oidcClaimsPropertiesSchema
    ]))).optional(),
    // https://openid.net/specs/openid-connect-core-1_0.html#RegistrationParameter
    // Not supported by this library (yet?)
    // registration: clientMetadataSchema.optional(),
    login_hint: zod_1.z.string().min(1).optional(),
    ui_locales: zod_1.z.string().regex(/^[a-z]{2}(-[A-Z]{2})?( [a-z]{2}(-[A-Z]{2})?)*$/) // fr-CA fr en
    .optional(),
    // Previous ID Token, should be provided when prompt=none is used
    id_token_hint: jwk_1.signedJwtSchema.optional(),
    // Type of UI the AS is displayed on
    display: zod_1.z.enum([
        'page',
        'popup',
        'touch',
        'wap'
    ]).optional(),
    /**
     * - "none" will only be allowed if the user already allowed the client on the same device
     * - "login" will force the user to login again, unless he very recently logged in
     * - "consent" will force the user to consent again
     * - "select_account" will force the user to select an account
     */ prompt: zod_1.z.enum([
        'none',
        'login',
        'consent',
        'select_account'
    ]).optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396
    authorization_details: oauth_authorization_details_js_1.oauthAuthorizationDetailsSchema.optional()
}); //# sourceMappingURL=oauth-authorization-request-parameters.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-par.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestParSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_request_jar_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)");
const oauth_authorization_request_parameters_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestParSchema = zod_1.z.union([
    oauth_authorization_request_parameters_js_1.oauthAuthorizationRequestParametersSchema,
    oauth_authorization_request_jar_js_1.oauthAuthorizationRequestJarSchema
]); //# sourceMappingURL=oauth-authorization-request-par.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-request-uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRequestUriSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthRequestUriSchema = zod_1.z.string(); //# sourceMappingURL=oauth-request-uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestUriSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_request_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-request-uri.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestUriSchema = zod_1.z.object({
    request_uri: oauth_request_uri_js_1.oauthRequestUriSchema
}); //# sourceMappingURL=oauth-authorization-request-uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-query.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestQuerySchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_request_jar_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)");
const oauth_authorization_request_parameters_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)");
const oauth_authorization_request_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-uri.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestQuerySchema = zod_1.z.union([
    oauth_authorization_request_parameters_js_1.oauthAuthorizationRequestParametersSchema,
    oauth_authorization_request_jar_js_1.oauthAuthorizationRequestJarSchema,
    oauth_authorization_request_uri_js_1.oauthAuthorizationRequestUriSchema
]); //# sourceMappingURL=oauth-authorization-request-query.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthIssuerIdentifierSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
exports.oauthIssuerIdentifierSchema = uri_js_1.webUriSchema.superRefine((value, ctx)=>{
    // Validate the issuer (MIX-UP attacks)
    if (value.endsWith('/')) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must not end with a slash'
        });
        return false;
    }
    const url = new URL(value);
    if (url.username || url.password) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must not contain a username or password'
        });
        return false;
    }
    if (url.hash || url.search) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must not contain a query or fragment'
        });
        return false;
    }
    const canonicalValue = url.pathname === '/' ? url.origin : url.href;
    if (value !== canonicalValue) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must be in the canonical form'
        });
        return false;
    }
    return true;
}); //# sourceMappingURL=oauth-issuer-identifier.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-server-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationServerMetadataValidator = exports.oauthAuthorizationServerMetadataSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_code_challenge_method_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-code-challenge-method.js [app-ssr] (ecmascript)");
const oauth_issuer_identifier_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8414}
 * @note we do not enforce https: scheme in URIs to support development
 * environments. Make sure to validate the URIs before using it in a production
 * environment.
 */ exports.oauthAuthorizationServerMetadataSchema = zod_1.z.object({
    issuer: oauth_issuer_identifier_js_1.oauthIssuerIdentifierSchema,
    claims_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_parameter_supported: zod_1.z.boolean().optional(),
    request_parameter_supported: zod_1.z.boolean().optional(),
    request_uri_parameter_supported: zod_1.z.boolean().optional(),
    require_request_uri_registration: zod_1.z.boolean().optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    subject_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    code_challenge_methods_supported: zod_1.z.array(oauth_code_challenge_method_js_1.oauthCodeChallengeMethodSchema).min(1).optional(),
    ui_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    id_token_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    display_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    authorization_response_iss_parameter_supported: zod_1.z.boolean().optional(),
    authorization_details_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    jwks_uri: uri_js_1.webUriSchema.optional(),
    authorization_endpoint: uri_js_1.webUriSchema,
    token_endpoint: uri_js_1.webUriSchema,
    token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    revocation_endpoint: uri_js_1.webUriSchema.optional(),
    introspection_endpoint: uri_js_1.webUriSchema.optional(),
    pushed_authorization_request_endpoint: uri_js_1.webUriSchema.optional(),
    require_pushed_authorization_requests: zod_1.z.boolean().optional(),
    userinfo_endpoint: uri_js_1.webUriSchema.optional(),
    end_session_endpoint: uri_js_1.webUriSchema.optional(),
    registration_endpoint: uri_js_1.webUriSchema.optional(),
    // https://datatracker.ietf.org/doc/html/rfc9449#section-5.1
    dpop_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-4
    protected_resources: zod_1.z.array(uri_js_1.webUriSchema).optional(),
    // https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html
    client_id_metadata_document_supported: zod_1.z.boolean().optional()
});
exports.oauthAuthorizationServerMetadataValidator = exports.oauthAuthorizationServerMetadataSchema.superRefine((data, ctx)=>{
    if (data.require_pushed_authorization_requests && !data.pushed_authorization_request_endpoint) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: '"pushed_authorization_request_endpoint" required when "require_pushed_authorization_requests" is true'
        });
    }
}).superRefine((data, ctx)=>{
    if (data.response_types_supported) {
        if (!data.response_types_supported.includes('code')) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: 'Response type "code" is required'
            });
        }
    }
}); //# sourceMappingURL=oauth-authorization-server-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientCredentialsGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthClientCredentialsGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('client_credentials')
}); //# sourceMappingURL=oauth-client-credentials-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientCredentialsSchema = exports.oauthClientCredentialsNoneSchema = exports.oauthClientCredentialsSecretPostSchema = exports.oauthClientCredentialsJwtBearerSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const constants_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/constants.js [app-ssr] (ecmascript)");
exports.oauthClientCredentialsJwtBearerSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema,
    client_assertion_type: zod_1.z.literal(constants_js_1.CLIENT_ASSERTION_TYPE_JWT_BEARER),
    /**
     * - "sub" the subject MUST be the "client_id" of the OAuth client
     * - "iat" is required and MUST be less than one minute
     * - "aud" must containing a value that identifies the authorization server
     * - The JWT MAY contain a "jti" (JWT ID) claim that provides a unique identifier for the token.
     * - Note that the authorization server may reject JWTs with an "exp" claim value that is unreasonably far in the future.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7523#section-3}
     */ client_assertion: jwk_1.signedJwtSchema
});
exports.oauthClientCredentialsSecretPostSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema,
    client_secret: zod_1.z.string()
});
exports.oauthClientCredentialsNoneSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema
});
//
exports.oauthClientCredentialsSchema = zod_1.z.union([
    exports.oauthClientCredentialsJwtBearerSchema,
    exports.oauthClientCredentialsSecretPostSchema,
    // Must be last since it is less specific
    exports.oauthClientCredentialsNoneSchema
]); //# sourceMappingURL=oauth-client-credentials.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-discoverable.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientIdDiscoverableSchema = void 0;
exports.isOAuthClientIdDiscoverable = isOAuthClientIdDiscoverable;
exports.assertOAuthDiscoverableClientId = assertOAuthDiscoverableClientId;
exports.parseOAuthDiscoverableClientId = parseOAuthDiscoverableClientId;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html}
 */ exports.oauthClientIdDiscoverableSchema = zod_1.z.intersection(oauth_client_id_js_1.oauthClientIdSchema, uri_js_1.httpsUriSchema).superRefine((value, ctx)=>{
    const url = new URL(value);
    if (url.username || url.password) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must not contain credentials'
        });
        return false;
    }
    if (url.hash) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must not contain a fragment'
        });
        return false;
    }
    if (url.pathname === '/') {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must contain a path component (e.g. "/client-metadata.json")'
        });
        return false;
    }
    if (url.pathname.endsWith('/')) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID path must not end with a trailing slash'
        });
        return false;
    }
    if ((0, util_js_1.isHostnameIP)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID hostname must not be an IP address'
        });
        return false;
    }
    // URL constructor normalizes the URL, so we extract the path manually to
    // avoid normalization, then compare it to the normalized path to ensure
    // that the URL does not contain path traversal or other unexpected characters
    if ((0, util_js_1.extractUrlPath)(value) !== url.pathname) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `ClientID must be in canonical form ("${url.href}", got "${value}")`
        });
        return false;
    }
    return true;
});
function isOAuthClientIdDiscoverable(clientId) {
    return exports.oauthClientIdDiscoverableSchema.safeParse(clientId).success;
}
function assertOAuthDiscoverableClientId(value) {
    void exports.oauthClientIdDiscoverableSchema.parse(value);
}
function parseOAuthDiscoverableClientId(clientId) {
    return new URL(exports.oauthClientIdDiscoverableSchema.parse(clientId));
} //# sourceMappingURL=oauth-client-id-discoverable.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-auth-method.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthEndpointAuthMethod = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthEndpointAuthMethod = zod_1.z.enum([
    'client_secret_basic',
    'client_secret_jwt',
    'client_secret_post',
    'none',
    'private_key_jwt',
    'self_signed_tls_client_auth',
    'tls_client_auth'
]); //# sourceMappingURL=oauth-endpoint-auth-method.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-grant-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthGrantTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthGrantTypeSchema = zod_1.z.enum([
    'authorization_code',
    'implicit',
    'refresh_token',
    'password',
    'client_credentials',
    'urn:ietf:params:oauth:grant-type:jwt-bearer',
    'urn:ietf:params:oauth:grant-type:saml2-bearer'
]); //# sourceMappingURL=oauth-grant-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientMetadataSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const oauth_endpoint_auth_method_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-auth-method.js [app-ssr] (ecmascript)");
const oauth_grant_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-grant-type.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
const oauth_response_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)");
const oauth_scope_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://openid.net/specs/openid-connect-registration-1_0.html}
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7591}
 * @note we do not enforce https: scheme in URIs to support development
 * environments. Make sure to validate the URIs before using it in a production
 * environment.
 */ exports.oauthClientMetadataSchema = zod_1.z.object({
    /**
     * @note redirect_uris require additional validation
     */ redirect_uris: zod_1.z.array(oauth_redirect_uri_js_1.oauthRedirectUriSchema).nonempty(),
    response_types: zod_1.z.array(oauth_response_type_js_1.oauthResponseTypeSchema).nonempty()// > If omitted, the default is that the client will use only the "code"
    // > response type.
    .default([
        'code'
    ]),
    grant_types: zod_1.z.array(oauth_grant_type_js_1.oauthGrantTypeSchema).nonempty()// > If omitted, the default behavior is that the client will use only the
    // > "authorization_code" Grant Type.
    .default([
        'authorization_code'
    ]),
    scope: oauth_scope_js_1.oauthScopeSchema.optional(),
    token_endpoint_auth_method: oauth_endpoint_auth_method_js_1.oauthEndpointAuthMethod.default('none').optional(),
    token_endpoint_auth_signing_alg: zod_1.z.string().optional(),
    userinfo_signed_response_alg: zod_1.z.string().optional(),
    userinfo_encrypted_response_alg: zod_1.z.string().optional(),
    jwks_uri: uri_js_1.webUriSchema.optional(),
    jwks: jwk_1.jwksPubSchema.optional(),
    application_type: zod_1.z.enum([
        'web',
        'native'
    ]).default('web').optional(),
    subject_type: zod_1.z.enum([
        'public',
        'pairwise'
    ]).default('public').optional(),
    request_object_signing_alg: zod_1.z.string().optional(),
    id_token_signed_response_alg: zod_1.z.string().optional(),
    authorization_signed_response_alg: zod_1.z.string().default('RS256').optional(),
    authorization_encrypted_response_enc: zod_1.z.enum([
        'A128CBC-HS256'
    ]).optional(),
    authorization_encrypted_response_alg: zod_1.z.string().optional(),
    client_id: oauth_client_id_js_1.oauthClientIdSchema.optional(),
    client_name: zod_1.z.string().optional(),
    client_uri: uri_js_1.webUriSchema.optional(),
    policy_uri: uri_js_1.webUriSchema.optional(),
    tos_uri: uri_js_1.webUriSchema.optional(),
    logo_uri: uri_js_1.webUriSchema.optional(),
    /**
     * Default Maximum Authentication Age. Specifies that the End-User MUST be
     * actively authenticated if the End-User was authenticated longer ago than
     * the specified number of seconds. The max_age request parameter overrides
     * this default value. If omitted, no default Maximum Authentication Age is
     * specified.
     */ default_max_age: zod_1.z.number().optional(),
    require_auth_time: zod_1.z.boolean().optional(),
    contacts: zod_1.z.array(zod_1.z.string().email()).optional(),
    tls_client_certificate_bound_access_tokens: zod_1.z.boolean().optional(),
    // https://datatracker.ietf.org/doc/html/rfc9449#section-5.2
    dpop_bound_access_tokens: zod_1.z.boolean().optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396#section-14.5
    authorization_details_types: zod_1.z.array(zod_1.z.string()).optional()
}); //# sourceMappingURL=oauth-client-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-name.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAUTH_ENDPOINT_NAMES = void 0;
exports.OAUTH_ENDPOINT_NAMES = [
    'token',
    'revocation',
    'introspection',
    'pushed_authorization_request'
]; //# sourceMappingURL=oauth-endpoint-name.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-introspection-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=oauth-introspection-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-par-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthParResponseSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthParResponseSchema = zod_1.z.object({
    request_uri: zod_1.z.string(),
    expires_in: zod_1.z.number().int().positive()
}); //# sourceMappingURL=oauth-par-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-password-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthPasswordGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthPasswordGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('password'),
    username: zod_1.z.string(),
    password: zod_1.z.string()
}); //# sourceMappingURL=oauth-password-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-protected-resource-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthProtectedResourceMetadataSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_issuer_identifier_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#name-protected-resource-metadata-r}
 */ exports.oauthProtectedResourceMetadataSchema = zod_1.z.object({
    /**
     * REQUIRED. The protected resource's resource identifier, which is a URL that
     * uses the https scheme and has no query or fragment components. Using these
     * well-known resources is described in Section 3.
     *
     * @note This schema allows non https URLs for testing & development purposes.
     * Make sure to validate the URL before using it in a production environment.
     */ resource: uri_js_1.webUriSchema.refine((url)=>!url.includes('?'), {
        message: 'Resource URL must not contain query parameters'
    }).refine((url)=>!url.includes('#'), {
        message: 'Resource URL must not contain a fragment'
    }),
    /**
     * OPTIONAL. JSON array containing a list of OAuth authorization server issuer
     * identifiers, as defined in [RFC8414], for authorization servers that can be
     * used with this protected resource. Protected resources MAY choose not to
     * advertise some supported authorization servers even when this parameter is
     * used. In some use cases, the set of authorization servers will not be
     * enumerable, in which case this metadata parameter would not be used.
     */ authorization_servers: zod_1.z.array(oauth_issuer_identifier_js_1.oauthIssuerIdentifierSchema).optional(),
    /**
     * OPTIONAL. URL of the protected resource's JWK Set [JWK] document. This
     * contains public keys belonging to the protected resource, such as signing
     * key(s) that the resource server uses to sign resource responses. This URL
     * MUST use the https scheme. When both signing and encryption keys are made
     * available, a use (public key use) parameter value is REQUIRED for all keys
     * in the referenced JWK Set to indicate each key's intended usage.
     */ jwks_uri: uri_js_1.webUriSchema.optional(),
    /**
     * RECOMMENDED. JSON array containing a list of the OAuth 2.0 [RFC6749] scope
     * values that are used in authorization requests to request access to this
     * protected resource. Protected resources MAY choose not to advertise some
     * scope values supported even when this parameter is used.
     */ scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * OPTIONAL. JSON array containing a list of the supported methods of sending
     * an OAuth 2.0 Bearer Token [RFC6750] to the protected resource. Defined
     * values are ["header", "body", "query"], corresponding to Sections 2.1, 2.2,
     * and 2.3 of RFC 6750.
     */ bearer_methods_supported: zod_1.z.array(zod_1.z.enum([
        'header',
        'body',
        'query'
    ])).optional(),
    /**
     * OPTIONAL. JSON array containing a list of the JWS [JWS] signing algorithms
     * (alg values) [JWA] supported by the protected resource for signing resource
     * responses, for instance, as described in [FAPI.MessageSigning]. No default
     * algorithms are implied if this entry is omitted. The value none MUST NOT be
     * used.
     */ resource_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * OPTIONAL. URL of a page containing human-readable information that
     * developers might want or need to know when using the protected resource
     */ resource_documentation: uri_js_1.webUriSchema.optional(),
    /**
     * OPTIONAL. URL that the protected resource provides to read about the
     * protected resource's requirements on how the client can use the data
     * provided by the protected resource
     */ resource_policy_uri: uri_js_1.webUriSchema.optional(),
    /**
     * OPTIONAL. URL that the protected resource provides to read about the
     * protected resource's terms of service
     */ resource_tos_uri: uri_js_1.webUriSchema.optional()
}); //# sourceMappingURL=oauth-protected-resource-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRefreshTokenSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthRefreshTokenSchema = zod_1.z.string().min(1); //# sourceMappingURL=oauth-refresh-token.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRefreshTokenGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_refresh_token_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)");
exports.oauthRefreshTokenGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('refresh_token'),
    refresh_token: oauth_refresh_token_js_1.oauthRefreshTokenSchema
}); //# sourceMappingURL=oauth-refresh-token-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-response-mode.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthResponseModeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthResponseModeSchema = zod_1.z.enum([
    'query',
    'fragment',
    'form_post'
]); //# sourceMappingURL=oauth-response-mode.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-identification.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenIdentificationSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_access_token_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-access-token.js [app-ssr] (ecmascript)");
const oauth_refresh_token_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)");
exports.oauthTokenIdentificationSchema = zod_1.z.object({
    token: zod_1.z.union([
        oauth_access_token_js_1.oauthAccessTokenSchema,
        oauth_refresh_token_js_1.oauthRefreshTokenSchema
    ]),
    token_type_hint: zod_1.z.enum([
        'access_token',
        'refresh_token'
    ]).optional()
}); //# sourceMappingURL=oauth-token-identification.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_code_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-code-grant-token-request.js [app-ssr] (ecmascript)");
const oauth_client_credentials_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials-grant-token-request.js [app-ssr] (ecmascript)");
const oauth_password_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-password-grant-token-request.js [app-ssr] (ecmascript)");
const oauth_refresh_token_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token-grant-token-request.js [app-ssr] (ecmascript)");
exports.oauthTokenRequestSchema = zod_1.z.discriminatedUnion('grant_type', [
    oauth_authorization_code_grant_token_request_js_1.oauthAuthorizationCodeGrantTokenRequestSchema,
    oauth_refresh_token_grant_token_request_js_1.oauthRefreshTokenGrantTokenRequestSchema,
    oauth_password_grant_token_request_js_1.oauthPasswordGrantTokenRequestSchema,
    oauth_client_credentials_grant_token_request_js_1.oauthClientCredentialsGrantTokenRequestSchema
]); //# sourceMappingURL=oauth-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
// Case insensitive input, normalized output
exports.oauthTokenTypeSchema = zod_1.z.union([
    zod_1.z.string().regex(/^DPoP$/i).transform(()=>'DPoP'),
    zod_1.z.string().regex(/^Bearer$/i).transform(()=>'Bearer')
]); //# sourceMappingURL=oauth-token-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenResponseSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_details_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)");
const oauth_token_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-type.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://www.rfc-editor.org/rfc/rfc6749.html#section-5.1 | RFC 6749 (OAuth2), Section 5.1}
 */ exports.oauthTokenResponseSchema = zod_1.z.object({
    // https://www.rfc-editor.org/rfc/rfc6749.html#section-5.1
    access_token: zod_1.z.string(),
    token_type: oauth_token_type_js_1.oauthTokenTypeSchema,
    scope: zod_1.z.string().optional(),
    refresh_token: zod_1.z.string().optional(),
    expires_in: zod_1.z.number().optional(),
    // https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse
    id_token: jwk_1.signedJwtSchema.optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396#name-enriched-authorization-deta
    authorization_details: oauth_authorization_details_js_1.oauthAuthorizationDetailsSchema.optional()
})// https://www.rfc-editor.org/rfc/rfc6749.html#section-5.1
// > The client MUST ignore unrecognized value names in the response.
.passthrough(); //# sourceMappingURL=oauth-token-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/constants.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/atproto-loopback-client-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-access-token.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-code-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-par.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-query.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-server-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-discoverable.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-loopback.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-auth-method.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-name.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-grant-type.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-introspection-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-par-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-password-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-protected-resource-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-request-uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-mode.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-identification.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-type.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-parameter.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-properties.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-entity-type.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.includesSpaceSeparatedValue = exports.CustomEventTarget = exports.CustomEvent = exports.timeoutSignal = void 0;
exports.contentMime = contentMime;
exports.combineSignals = combineSignals;
// @ts-expect-error
Symbol.dispose ?? (Symbol.dispose = Symbol('@@dispose'));
/**
 * @todo (?) move to common package
 */ const timeoutSignal = (timeout, options)=>{
    if (!Number.isInteger(timeout) || timeout < 0) {
        throw new TypeError('Expected a positive integer');
    }
    options?.signal?.throwIfAborted();
    const controller = new AbortController();
    const { signal } = controller;
    options?.signal?.addEventListener('abort', (reason)=>controller.abort(reason), {
        once: true,
        signal
    });
    const timeoutId = setTimeout((err)=>controller.abort(err), timeout, // create Error here to keep original stack trace
    new Error('Timeout'));
    timeoutId?.unref?.(); // NodeJS only
    signal.addEventListener('abort', ()=>clearTimeout(timeoutId), {
        once: true,
        signal
    });
    Object.defineProperty(signal, Symbol.dispose, {
        value: ()=>controller.abort()
    });
    return signal;
};
exports.timeoutSignal = timeoutSignal;
function contentMime(headers) {
    return headers.get('content-type')?.split(';')[0].trim();
}
/**
 * Ponyfill for `CustomEvent` constructor.
 */ exports.CustomEvent = globalThis.CustomEvent ?? (()=>{
    var _CustomEvent_detail;
    class CustomEvent extends Event {
        constructor(type, options){
            if (!arguments.length) throw new TypeError('type argument is required');
            super(type, options);
            _CustomEvent_detail.set(this, void 0);
            __classPrivateFieldSet(this, _CustomEvent_detail, options?.detail ?? null, "f");
        }
        get detail() {
            return __classPrivateFieldGet(this, _CustomEvent_detail, "f");
        }
    }
    _CustomEvent_detail = new WeakMap();
    Object.defineProperties(CustomEvent.prototype, {
        [Symbol.toStringTag]: {
            writable: false,
            enumerable: false,
            configurable: true,
            value: 'CustomEvent'
        },
        detail: {
            enumerable: true
        }
    });
    return CustomEvent;
})();
class CustomEventTarget {
    constructor(){
        Object.defineProperty(this, "eventTarget", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventTarget()
        });
    }
    addEventListener(type, callback, options) {
        this.eventTarget.addEventListener(type, callback, options);
    }
    removeEventListener(type, callback, options) {
        this.eventTarget.removeEventListener(type, callback, options);
    }
    dispatchCustomEvent(type, detail, init) {
        return this.eventTarget.dispatchEvent(new exports.CustomEvent(type, {
            ...init,
            detail
        }));
    }
}
exports.CustomEventTarget = CustomEventTarget;
const includesSpaceSeparatedValue = (input, value)=>{
    if (value.length === 0) throw new TypeError('Value cannot be empty');
    if (value.includes(' ')) throw new TypeError('Value cannot contain spaces');
    // Optimized version of:
    // return input.split(' ').includes(value)
    const inputLength = input.length;
    const valueLength = value.length;
    if (inputLength < valueLength) return false;
    let idx = input.indexOf(value);
    let idxEnd;
    while(idx !== -1){
        idxEnd = idx + valueLength;
        if (// at beginning or preceded by space
        (idx === 0 || input[idx - 1] === ' ') && // at end or followed by space
        (idxEnd === inputLength || input[idxEnd] === ' ')) {
            return true;
        }
        idx = input.indexOf(value, idxEnd + 1);
    }
    return false;
};
exports.includesSpaceSeparatedValue = includesSpaceSeparatedValue;
function combineSignals(signals) {
    const controller = new AbortController();
    const onAbort = function(_event) {
        const reason = new Error('This operation was aborted', {
            cause: this.reason
        });
        controller.abort(reason);
    };
    for (const sig of signals){
        if (!sig) continue;
        if (sig.aborted) {
            // Remove "abort" listener that was added to sig in previous iterations
            controller.abort();
            throw new Error('One of the signals is already aborted', {
                cause: sig.reason
            });
        }
        sig.addEventListener('abort', onAbort, {
            signal: controller.signal
        });
    }
    controller[Symbol.dispose] = ()=>{
        const reason = new Error('AbortController was disposed');
        controller.abort(reason);
    };
    return controller;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-authorization-server-metadata-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthAuthorizationServerMetadataResolver = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8414}
 */ class OAuthAuthorizationServerMetadataResolver extends simple_store_1.CachedGetter {
    constructor(cache, fetch, config){
        super(async (issuer, options)=>this.fetchMetadata(issuer, options), cache);
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttpIssuer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttpIssuer = config?.allowHttpIssuer === true;
    }
    async get(input, options) {
        const issuer = oauth_types_1.oauthIssuerIdentifierSchema.parse(input);
        if (!this.allowHttpIssuer && issuer.startsWith('http:')) {
            throw new TypeError('Unsecure issuer URL protocol only allowed in development and test environments');
        }
        return super.get(issuer, options);
    }
    async fetchMetadata(issuer, options) {
        const url = new URL(`/.well-known/oauth-authorization-server`, issuer);
        const request = new Request(url, {
            headers: {
                accept: 'application/json'
            },
            cache: options?.noCache ? 'no-cache' : undefined,
            signal: options?.signal,
            redirect: 'manual'
        });
        const response = await this.fetch(request);
        // https://datatracker.ietf.org/doc/html/rfc8414#section-3.2
        if (response.status !== 200) {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected status code ${response.status} for "${url}"`, undefined, {
                cause: request
            });
        }
        if ((0, util_js_1.contentMime)(response.headers) !== 'application/json') {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected content type for "${url}"`, undefined, {
                cause: request
            });
        }
        const metadata = oauth_types_1.oauthAuthorizationServerMetadataValidator.parse(await response.json());
        // Validate the issuer (MIX-UP attacks)
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-mix-up-attacks
        // https://datatracker.ietf.org/doc/html/rfc8414#section-2
        if (metadata.issuer !== issuer) {
            throw new TypeError(`Invalid issuer ${metadata.issuer}`);
        }
        // ATPROTO requires client_id_metadata_document
        // http://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html
        if (metadata.client_id_metadata_document_supported !== true) {
            throw new TypeError(`Authorization server "${issuer}" does not support client_id_metadata_document`);
        }
        return metadata;
    }
}
exports.OAuthAuthorizationServerMetadataResolver = OAuthAuthorizationServerMetadataResolver; //# sourceMappingURL=oauth-authorization-server-metadata-resolver.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-callback-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthCallbackError = void 0;
class OAuthCallbackError extends Error {
    static from(err, params, state) {
        if (err instanceof OAuthCallbackError) return err;
        const message = err instanceof Error ? err.message : undefined;
        return new OAuthCallbackError(params, message, state, err);
    }
    constructor(params, message = params.get('error_description') || 'OAuth callback error', state, cause){
        super(message, {
            cause
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: params
        });
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: state
        });
    }
}
exports.OAuthCallbackError = OAuthCallbackError; //# sourceMappingURL=oauth-callback-error.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/handle.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DisallowedDomainError = exports.UnsupportedDomainError = exports.ReservedHandleError = exports.InvalidHandleError = exports.isValidTld = exports.isValidHandle = exports.normalizeAndEnsureValidHandle = exports.normalizeHandle = exports.ensureValidHandleRegex = exports.ensureValidHandle = exports.DISALLOWED_TLDS = exports.INVALID_HANDLE = void 0;
exports.INVALID_HANDLE = 'handle.invalid';
// Currently these are registration-time restrictions, not protocol-level
// restrictions. We have a couple accounts in the wild that we need to clean up
// before hard-disallow.
// See also: https://en.wikipedia.org/wiki/Top-level_domain#Reserved_domains
exports.DISALLOWED_TLDS = [
    '.local',
    '.arpa',
    '.invalid',
    '.localhost',
    '.internal',
    '.example',
    '.alt',
    // policy could concievably change on ".onion" some day
    '.onion'
];
// Handle constraints, in English:
//  - must be a possible domain name
//    - RFC-1035 is commonly referenced, but has been updated. eg, RFC-3696,
//      section 2. and RFC-3986, section 3. can now have leading numbers (eg,
//      4chan.org)
//    - "labels" (sub-names) are made of ASCII letters, digits, hyphens
//    - can not start or end with a hyphen
//    - TLD (last component) should not start with a digit
//    - can't end with a hyphen (can end with digit)
//    - each segment must be between 1 and 63 characters (not including any periods)
//    - overall length can't be more than 253 characters
//    - separated by (ASCII) periods; does not start or end with period
//    - case insensitive
//    - domains (handles) are equal if they are the same lower-case
//    - punycode allowed for internationalization
//  - no whitespace, null bytes, joining chars, etc
//  - does not validate whether domain or TLD exists, or is a reserved or
//    special TLD (eg, .onion or .local)
//  - does not validate punycode
const ensureValidHandle = (handle)=>{
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9.-]*$/.test(handle)) {
        throw new InvalidHandleError('Disallowed characters in handle (ASCII letters, digits, dashes, periods only)');
    }
    if (handle.length > 253) {
        throw new InvalidHandleError('Handle is too long (253 chars max)');
    }
    const labels = handle.split('.');
    if (labels.length < 2) {
        throw new InvalidHandleError('Handle domain needs at least two parts');
    }
    for(let i = 0; i < labels.length; i++){
        const l = labels[i];
        if (l.length < 1) {
            throw new InvalidHandleError('Handle parts can not be empty');
        }
        if (l.length > 63) {
            throw new InvalidHandleError('Handle part too long (max 63 chars)');
        }
        if (l.endsWith('-') || l.startsWith('-')) {
            throw new InvalidHandleError('Handle parts can not start or end with hyphens');
        }
        if (i + 1 === labels.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError('Handle final component (TLD) must start with ASCII letter');
        }
    }
};
exports.ensureValidHandle = ensureValidHandle;
// simple regex translation of above constraints
const ensureValidHandleRegex = (handle)=>{
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(handle)) {
        throw new InvalidHandleError("Handle didn't validate via regex");
    }
    if (handle.length > 253) {
        throw new InvalidHandleError('Handle is too long (253 chars max)');
    }
};
exports.ensureValidHandleRegex = ensureValidHandleRegex;
const normalizeHandle = (handle)=>{
    return handle.toLowerCase();
};
exports.normalizeHandle = normalizeHandle;
const normalizeAndEnsureValidHandle = (handle)=>{
    const normalized = (0, exports.normalizeHandle)(handle);
    (0, exports.ensureValidHandle)(normalized);
    return normalized;
};
exports.normalizeAndEnsureValidHandle = normalizeAndEnsureValidHandle;
const isValidHandle = (handle)=>{
    try {
        (0, exports.ensureValidHandle)(handle);
    } catch (err) {
        if (err instanceof InvalidHandleError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidHandle = isValidHandle;
const isValidTld = (handle)=>{
    return !exports.DISALLOWED_TLDS.some((domain)=>handle.endsWith(domain));
};
exports.isValidTld = isValidTld;
class InvalidHandleError extends Error {
}
exports.InvalidHandleError = InvalidHandleError;
class ReservedHandleError extends Error {
}
exports.ReservedHandleError = ReservedHandleError;
class UnsupportedDomainError extends Error {
}
exports.UnsupportedDomainError = UnsupportedDomainError;
class DisallowedDomainError extends Error {
}
exports.DisallowedDomainError = DisallowedDomainError; //# sourceMappingURL=handle.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/did.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDidError = exports.ensureValidDidRegex = exports.ensureValidDid = void 0;
// Human-readable constraints:
//   - valid W3C DID (https://www.w3.org/TR/did-core/#did-syntax)
//      - entire URI is ASCII: [a-zA-Z0-9._:%-]
//      - always starts "did:" (lower-case)
//      - method name is one or more lower-case letters, followed by ":"
//      - remaining identifier can have any of the above chars, but can not end in ":"
//      - it seems that a bunch of ":" can be included, and don't need spaces between
//      - "%" is used only for "percent encoding" and must be followed by two hex characters (and thus can't end in "%")
//      - query ("?") and fragment ("#") stuff is defined for "DID URIs", but not as part of identifier itself
//      - "The current specification does not take a position on the maximum length of a DID"
//   - in current atproto, only allowing did:plc and did:web. But not *forcing* this at lexicon layer
//   - hard length limit of 8KBytes
//   - not going to validate "percent encoding" here
const ensureValidDid = (did)=>{
    if (!did.startsWith('did:')) {
        throw new InvalidDidError('DID requires "did:" prefix');
    }
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9._:%-]*$/.test(did)) {
        throw new InvalidDidError('Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)');
    }
    const { length, 1: method } = did.split(':');
    if (length < 3) {
        throw new InvalidDidError('DID requires prefix, method, and method-specific content');
    }
    if (!/^[a-z]+$/.test(method)) {
        throw new InvalidDidError('DID method must be lower-case letters');
    }
    if (did.endsWith(':') || did.endsWith('%')) {
        throw new InvalidDidError('DID can not end with ":" or "%"');
    }
    if (did.length > 2 * 1024) {
        throw new InvalidDidError('DID is too long (2048 chars max)');
    }
};
exports.ensureValidDid = ensureValidDid;
const ensureValidDidRegex = (did)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints
    if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(did)) {
        throw new InvalidDidError("DID didn't validate via regex");
    }
    if (did.length > 2 * 1024) {
        throw new InvalidDidError('DID is too long (2048 chars max)');
    }
};
exports.ensureValidDidRegex = ensureValidDidRegex;
class InvalidDidError extends Error {
}
exports.InvalidDidError = InvalidDidError; //# sourceMappingURL=did.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/nsid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
/*
Grammar:

alpha     = "a" / "b" / "c" / "d" / "e" / "f" / "g" / "h" / "i" / "j" / "k" / "l" / "m" / "n" / "o" / "p" / "q" / "r" / "s" / "t" / "u" / "v" / "w" / "x" / "y" / "z" / "A" / "B" / "C" / "D" / "E" / "F" / "G" / "H" / "I" / "J" / "K" / "L" / "M" / "N" / "O" / "P" / "Q" / "R" / "S" / "T" / "U" / "V" / "W" / "X" / "Y" / "Z"
number    = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" / "0"
delim     = "."
segment   = alpha *( alpha / number / "-" )
authority = segment *( delim segment )
name      = alpha *( alpha )
nsid      = authority delim name

*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidNsidError = exports.ensureValidNsidRegex = exports.ensureValidNsid = exports.NSID = void 0;
class NSID {
    static parse(nsid) {
        return new NSID(nsid);
    }
    static create(authority, name) {
        const segments = [
            ...authority.split('.').reverse(),
            name
        ].join('.');
        return new NSID(segments);
    }
    static isValid(nsid) {
        try {
            NSID.parse(nsid);
            return true;
        } catch (e) {
            return false;
        }
    }
    constructor(nsid){
        Object.defineProperty(this, "segments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        (0, exports.ensureValidNsid)(nsid);
        this.segments = nsid.split('.');
    }
    get authority() {
        return this.segments.slice(0, this.segments.length - 1).reverse().join('.');
    }
    get name() {
        return this.segments.at(this.segments.length - 1);
    }
    toString() {
        return this.segments.join('.');
    }
}
exports.NSID = NSID;
// Human readable constraints on NSID:
// - a valid domain in reversed notation
// - followed by an additional period-separated name, which is camel-case letters
const ensureValidNsid = (nsid)=>{
    const toCheck = nsid;
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
        throw new InvalidNsidError('Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)');
    }
    if (toCheck.length > 253 + 1 + 63) {
        throw new InvalidNsidError('NSID is too long (317 chars max)');
    }
    const labels = toCheck.split('.');
    if (labels.length < 3) {
        throw new InvalidNsidError('NSID needs at least three parts');
    }
    for(let i = 0; i < labels.length; i++){
        const l = labels[i];
        if (l.length < 1) {
            throw new InvalidNsidError('NSID parts can not be empty');
        }
        if (l.length > 63) {
            throw new InvalidNsidError('NSID part too long (max 63 chars)');
        }
        if (l.endsWith('-') || l.startsWith('-')) {
            throw new InvalidNsidError('NSID parts can not start or end with hyphen');
        }
        if (/^[0-9]/.test(l) && i === 0) {
            throw new InvalidNsidError('NSID first part may not start with a digit');
        }
        if (!/^[a-zA-Z]+$/.test(l) && i + 1 === labels.length) {
            throw new InvalidNsidError('NSID name part must be only letters');
        }
    }
};
exports.ensureValidNsid = ensureValidNsid;
const ensureValidNsidRegex = (nsid)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(nsid)) {
        throw new InvalidNsidError("NSID didn't validate via regex");
    }
    if (nsid.length > 253 + 1 + 63) {
        throw new InvalidNsidError('NSID is too long (317 chars max)');
    }
};
exports.ensureValidNsidRegex = ensureValidNsidRegex;
class InvalidNsidError extends Error {
}
exports.InvalidNsidError = InvalidNsidError; //# sourceMappingURL=nsid.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/aturi_validation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ensureValidAtUriRegex = exports.ensureValidAtUri = void 0;
const handle_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/handle.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/did.js [app-ssr] (ecmascript)");
const nsid_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/nsid.js [app-ssr] (ecmascript)");
// Human-readable constraints on ATURI:
//   - following regular URLs, a 8KByte hard total length limit
//   - follows ATURI docs on website
//      - all ASCII characters, no whitespace. non-ASCII could be URL-encoded
//      - starts "at://"
//      - "authority" is a valid DID or a valid handle
//      - optionally, follow "authority" with "/" and valid NSID as start of path
//      - optionally, if NSID given, follow that with "/" and rkey
//      - rkey path component can include URL-encoded ("percent encoded"), or:
//          ALPHA / DIGIT / "-" / "." / "_" / "~" / ":" / "@" / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//          [a-zA-Z0-9._~:@!$&'\(\)*+,;=-]
//      - rkey must have at least one char
//      - regardless of path component, a fragment can follow  as "#" and then a JSON pointer (RFC-6901)
const ensureValidAtUri = (uri)=>{
    // JSON pointer is pretty different from rest of URI, so split that out first
    const uriParts = uri.split('#');
    if (uriParts.length > 2) {
        throw new Error('ATURI can have at most one "#", separating fragment out');
    }
    const fragmentPart = uriParts[1] || null;
    uri = uriParts[0];
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {
        throw new Error('Disallowed characters in ATURI (ASCII)');
    }
    const parts = uri.split('/');
    if (parts.length >= 3 && (parts[0] !== 'at:' || parts[1].length !== 0)) {
        throw new Error('ATURI must start with "at://"');
    }
    if (parts.length < 3) {
        throw new Error('ATURI requires at least method and authority sections');
    }
    try {
        if (parts[2].startsWith('did:')) {
            (0, did_1.ensureValidDid)(parts[2]);
        } else {
            (0, handle_1.ensureValidHandle)(parts[2]);
        }
    } catch  {
        throw new Error('ATURI authority must be a valid handle or DID');
    }
    if (parts.length >= 4) {
        if (parts[3].length === 0) {
            throw new Error('ATURI can not have a slash after authority without a path segment');
        }
        try {
            (0, nsid_1.ensureValidNsid)(parts[3]);
        } catch  {
            throw new Error('ATURI requires first path segment (if supplied) to be valid NSID');
        }
    }
    if (parts.length >= 5) {
        if (parts[4].length === 0) {
            throw new Error('ATURI can not have a slash after collection, unless record key is provided');
        }
    // would validate rkey here, but there are basically no constraints!
    }
    if (parts.length >= 6) {
        throw new Error('ATURI path can have at most two parts, and no trailing slash');
    }
    if (uriParts.length >= 2 && fragmentPart == null) {
        throw new Error('ATURI fragment must be non-empty and start with slash');
    }
    if (fragmentPart != null) {
        if (fragmentPart.length === 0 || fragmentPart[0] !== '/') {
            throw new Error('ATURI fragment must be non-empty and start with slash');
        }
        // NOTE: enforcing *some* checks here for sanity. Eg, at least no whitespace
        if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
            throw new Error('Disallowed characters in ATURI fragment (ASCII)');
        }
    }
    if (uri.length > 8 * 1024) {
        throw new Error('ATURI is far too long');
    }
};
exports.ensureValidAtUri = ensureValidAtUri;
const ensureValidAtUriRegex = (uri)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints. whew!
    const aturiRegex = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/;
    const rm = uri.match(aturiRegex);
    if (!rm || !rm.groups) {
        throw new Error("ATURI didn't validate via regex");
    }
    const groups = rm.groups;
    try {
        (0, handle_1.ensureValidHandleRegex)(groups.authority);
    } catch  {
        try {
            (0, did_1.ensureValidDidRegex)(groups.authority);
        } catch  {
            throw new Error('ATURI authority must be a valid handle or DID');
        }
    }
    if (groups.collection) {
        try {
            (0, nsid_1.ensureValidNsidRegex)(groups.collection);
        } catch  {
            throw new Error('ATURI collection path segment must be a valid NSID');
        }
    }
    if (uri.length > 8 * 1024) {
        throw new Error('ATURI is far too long');
    }
};
exports.ensureValidAtUriRegex = ensureValidAtUriRegex; //# sourceMappingURL=aturi_validation.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/aturi.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtUri = exports.ATP_URI_REGEX = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/aturi_validation.js [app-ssr] (ecmascript)"), exports);
exports.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
/^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
//                       --path-----   --query--  --hash--
const RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
class AtUri {
    constructor(uri, base){
        Object.defineProperty(this, "hash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "host", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pathname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let parsed;
        if (base) {
            parsed = parse(base);
            if (!parsed) {
                throw new Error(`Invalid at uri: ${base}`);
            }
            const relativep = parseRelative(uri);
            if (!relativep) {
                throw new Error(`Invalid path: ${uri}`);
            }
            Object.assign(parsed, relativep);
        } else {
            parsed = parse(uri);
            if (!parsed) {
                throw new Error(`Invalid at uri: ${uri}`);
            }
        }
        this.hash = parsed.hash;
        this.host = parsed.host;
        this.pathname = parsed.pathname;
        this.searchParams = parsed.searchParams;
    }
    static make(handleOrDid, collection, rkey) {
        let str = handleOrDid;
        if (collection) str += '/' + collection;
        if (rkey) str += '/' + rkey;
        return new AtUri(str);
    }
    get protocol() {
        return 'at:';
    }
    get origin() {
        return `at://${this.host}`;
    }
    get hostname() {
        return this.host;
    }
    set hostname(v) {
        this.host = v;
    }
    get search() {
        return this.searchParams.toString();
    }
    set search(v) {
        this.searchParams = new URLSearchParams(v);
    }
    get collection() {
        return this.pathname.split('/').filter(Boolean)[0] || '';
    }
    set collection(v) {
        const parts = this.pathname.split('/').filter(Boolean);
        parts[0] = v;
        this.pathname = parts.join('/');
    }
    get rkey() {
        return this.pathname.split('/').filter(Boolean)[1] || '';
    }
    set rkey(v) {
        const parts = this.pathname.split('/').filter(Boolean);
        if (!parts[0]) parts[0] = 'undefined';
        parts[1] = v;
        this.pathname = parts.join('/');
    }
    get href() {
        return this.toString();
    }
    toString() {
        let path = this.pathname || '/';
        if (!path.startsWith('/')) {
            path = `/${path}`;
        }
        let qs = this.searchParams.toString();
        if (qs && !qs.startsWith('?')) {
            qs = `?${qs}`;
        }
        let hash = this.hash;
        if (hash && !hash.startsWith('#')) {
            hash = `#${hash}`;
        }
        return `at://${this.host}${path}${qs}${hash}`;
    }
}
exports.AtUri = AtUri;
function parse(str) {
    const match = exports.ATP_URI_REGEX.exec(str);
    if (match) {
        return {
            hash: match[5] || '',
            host: match[2] || '',
            pathname: match[3] || '',
            searchParams: new URLSearchParams(match[4] || '')
        };
    }
    return undefined;
}
function parseRelative(str) {
    const match = RELATIVE_REGEX.exec(str);
    if (match) {
        return {
            hash: match[3] || '',
            pathname: match[1] || '',
            searchParams: new URLSearchParams(match[2] || '')
        };
    }
    return undefined;
} //# sourceMappingURL=aturi.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/tid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidTidError = exports.isValidTid = exports.ensureValidTid = void 0;
const ensureValidTid = (tid)=>{
    if (tid.length !== 13) {
        throw new InvalidTidError('TID must be 13 characters');
    }
    // simple regex to enforce most constraints via just regex and length.
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(tid)) {
        throw new InvalidTidError('TID syntax not valid (regex)');
    }
};
exports.ensureValidTid = ensureValidTid;
const isValidTid = (tid)=>{
    try {
        (0, exports.ensureValidTid)(tid);
    } catch (err) {
        if (err instanceof InvalidTidError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidTid = isValidTid;
class InvalidTidError extends Error {
}
exports.InvalidTidError = InvalidTidError; //# sourceMappingURL=tid.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/recordkey.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidRecordKeyError = exports.isValidRecordKey = exports.ensureValidRecordKey = void 0;
const ensureValidRecordKey = (rkey)=>{
    if (rkey.length > 512 || rkey.length < 1) {
        throw new InvalidRecordKeyError('record key must be 1 to 512 characters');
    }
    // simple regex to enforce most constraints via just regex and length.
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(rkey)) {
        throw new InvalidRecordKeyError('record key syntax not valid (regex)');
    }
    if (rkey === '.' || rkey === '..') throw new InvalidRecordKeyError('record key can not be "." or ".."');
};
exports.ensureValidRecordKey = ensureValidRecordKey;
const isValidRecordKey = (rkey)=>{
    try {
        (0, exports.ensureValidRecordKey)(rkey);
    } catch (err) {
        if (err instanceof InvalidRecordKeyError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidRecordKey = isValidRecordKey;
class InvalidRecordKeyError extends Error {
}
exports.InvalidRecordKeyError = InvalidRecordKeyError; //# sourceMappingURL=recordkey.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/datetime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDatetimeError = exports.normalizeDatetimeAlways = exports.normalizeDatetime = exports.isValidDatetime = exports.ensureValidDatetime = void 0;
/* Validates datetime string against atproto Lexicon 'datetime' format.
 * Syntax is described at: https://atproto.com/specs/lexicon#datetime
 */ const ensureValidDatetime = (dtStr)=>{
    const date = new Date(dtStr);
    // must parse as ISO 8601; this also verifies semantics like month is not 13 or 00
    if (isNaN(date.getTime())) {
        throw new InvalidDatetimeError('datetime did not parse as ISO 8601');
    }
    if (date.toISOString().startsWith('-')) {
        throw new InvalidDatetimeError('datetime normalized to a negative time');
    }
    // regex and other checks for RFC-3339
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(dtStr)) {
        throw new InvalidDatetimeError("datetime didn't validate via regex");
    }
    if (dtStr.length > 64) {
        throw new InvalidDatetimeError('datetime is too long (64 chars max)');
    }
    if (dtStr.endsWith('-00:00')) {
        throw new InvalidDatetimeError('datetime can not use "-00:00" for UTC timezone');
    }
    if (dtStr.startsWith('000')) {
        throw new InvalidDatetimeError('datetime so close to year zero not allowed');
    }
};
exports.ensureValidDatetime = ensureValidDatetime;
/* Same logic as ensureValidDatetime(), but returns a boolean instead of throwing an exception.
 */ const isValidDatetime = (dtStr)=>{
    try {
        (0, exports.ensureValidDatetime)(dtStr);
    } catch (err) {
        if (err instanceof InvalidDatetimeError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidDatetime = isValidDatetime;
/* Takes a flexible datetime string and normalizes representation.
 *
 * This function will work with any valid atproto datetime (eg, anything which isValidDatetime() is true for). It *additionally* is more flexible about accepting datetimes that don't comply to RFC 3339, or are missing timezone information, and normalizing them to a valid datetime.
 *
 * One use-case is a consistent, sortable string. Another is to work with older invalid createdAt datetimes.
 *
 * Successful output will be a valid atproto datetime with millisecond precision (3 sub-second digits) and UTC timezone with trailing 'Z' syntax. Throws `InvalidDatetimeError` if the input string could not be parsed as a datetime, even with permissive parsing.
 *
 * Expected output format: YYYY-MM-DDTHH:mm:ss.sssZ
 */ const normalizeDatetime = (dtStr)=>{
    if ((0, exports.isValidDatetime)(dtStr)) {
        const outStr = new Date(dtStr).toISOString();
        if ((0, exports.isValidDatetime)(outStr)) {
            return outStr;
        }
    }
    // check if this permissive datetime is missing a timezone
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(dtStr)) {
        const date = new Date(dtStr + 'Z');
        if (!isNaN(date.getTime())) {
            const tzStr = date.toISOString();
            if ((0, exports.isValidDatetime)(tzStr)) {
                return tzStr;
            }
        }
    }
    // finally try parsing as simple datetime
    const date = new Date(dtStr);
    if (isNaN(date.getTime())) {
        throw new InvalidDatetimeError('datetime did not parse as any timestamp format');
    }
    const isoStr = date.toISOString();
    if ((0, exports.isValidDatetime)(isoStr)) {
        return isoStr;
    } else {
        throw new InvalidDatetimeError('datetime normalized to invalid timestamp string');
    }
};
exports.normalizeDatetime = normalizeDatetime;
/* Variant of normalizeDatetime() which always returns a valid datetime strings.
 *
 * If a InvalidDatetimeError is encountered, returns the UNIX epoch time as a UTC datetime (1970-01-01T00:00:00.000Z).
 */ const normalizeDatetimeAlways = (dtStr)=>{
    try {
        return (0, exports.normalizeDatetime)(dtStr);
    } catch (err) {
        if (err instanceof InvalidDatetimeError) {
            return new Date(0).toISOString();
        }
        throw err;
    }
};
exports.normalizeDatetimeAlways = normalizeDatetimeAlways;
/* Indicates a datetime string did not pass full atproto Lexicon datetime string format checks.
 */ class InvalidDatetimeError extends Error {
}
exports.InvalidDatetimeError = InvalidDatetimeError; //# sourceMappingURL=datetime.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/handle.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/did.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/nsid.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/aturi.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/tid.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/recordkey.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/datetime.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/identity-resolver/dist/identity-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IdentityResolver = void 0;
const handle_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)");
const syntax_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/index.js [app-ssr] (ecmascript)");
class IdentityResolver {
    constructor(didResolver, handleResolver){
        Object.defineProperty(this, "didResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: didResolver
        });
        Object.defineProperty(this, "handleResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: handleResolver
        });
    }
    async resolve(input, options) {
        const document = (0, handle_resolver_1.isResolvedHandle)(input) ? await this.getDocumentFromDid(input, options) : await this.getDocumentFromHandle(input, options);
        const service = document.service?.find(isAtprotoPersonalDataServerService, document);
        if (!service) {
            throw new TypeError(`No valid "AtprotoPersonalDataServer" service found in "${document.id}" DID document`);
        }
        return {
            did: document.id,
            pds: new URL(service.serviceEndpoint)
        };
    }
    async getDocumentFromDid(did, options) {
        return this.didResolver.resolve(did, options);
    }
    async getDocumentFromHandle(input, options) {
        const handle = (0, syntax_1.normalizeAndEnsureValidHandle)(input);
        const did = await this.handleResolver.resolve(handle, options);
        if (!did) {
            throw new TypeError(`Handle "${handle}" does not resolve to a DID`);
        }
        options?.signal?.throwIfAborted();
        // Note: Not using "return this.resolveDid(did, options)" to make the extra
        // check for the handle in the DID document:
        const document = await this.didResolver.resolve(did, options);
        // Ensure that the handle is included in the document
        if (!document.alsoKnownAs?.includes(`at://${handle}`)) {
            throw new TypeError(`Did document for "${did}" does not include the handle "${handle}"`);
        }
        return document;
    }
}
exports.IdentityResolver = IdentityResolver;
function isAtprotoPersonalDataServerService(s) {
    return typeof s.serviceEndpoint === 'string' && s.type === 'AtprotoPersonalDataServer' && (s.id.startsWith('#') ? s.id === '#atproto_pds' : s.id === `${this.id}#atproto_pds`);
} //# sourceMappingURL=identity-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/identity-resolver/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/identity-resolver/dist/identity-resolver.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FALLBACK_ALG = void 0;
/**
 * Per ATProto spec (OpenID uses RS256)
 */ exports.FALLBACK_ALG = 'ES256'; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenRevokedError = void 0;
class TokenRevokedError extends Error {
    constructor(sub, message = `The session for "${sub}" was successfully revoked`, options){
        super(message, options);
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
    }
}
exports.TokenRevokedError = TokenRevokedError; //# sourceMappingURL=token-revoked-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-protected-resource-metadata-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthProtectedResourceMetadataResolver = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05}
 */ class OAuthProtectedResourceMetadataResolver extends simple_store_1.CachedGetter {
    constructor(cache, fetch = globalThis.fetch, config){
        super(async (origin, options)=>this.fetchMetadata(origin, options), cache);
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttpResource", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttpResource = config?.allowHttpResource === true;
    }
    async get(resource, options) {
        const { protocol, origin } = new URL(resource);
        if (protocol !== 'https:' && protocol !== 'http:') {
            throw new TypeError(`Invalid protected resource metadata URL protocol: ${protocol}`);
        }
        if (protocol === 'http:' && !this.allowHttpResource) {
            throw new TypeError(`Unsecure resource metadata URL (${protocol}) only allowed in development and test environments`);
        }
        return super.get(origin, options);
    }
    async fetchMetadata(origin, options) {
        const url = new URL(`/.well-known/oauth-protected-resource`, origin);
        const request = new Request(url, {
            signal: options?.signal,
            headers: {
                accept: 'application/json'
            },
            cache: options?.noCache ? 'no-cache' : undefined,
            redirect: 'manual'
        });
        const response = await this.fetch(request);
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-3.2
        if (response.status !== 200) {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected status code ${response.status} for "${url}"`, undefined, {
                cause: request
            });
        }
        if ((0, util_js_1.contentMime)(response.headers) !== 'application/json') {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected content type for "${url}"`, undefined, {
                cause: request
            });
        }
        const metadata = oauth_types_1.oauthProtectedResourceMetadataSchema.parse(await response.json());
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-3.3
        if (metadata.resource !== origin) {
            throw new TypeError(`Invalid issuer ${metadata.resource}`);
        }
        return metadata;
    }
}
exports.OAuthProtectedResourceMetadataResolver = OAuthProtectedResourceMetadataResolver; //# sourceMappingURL=oauth-protected-resource-metadata-resolver.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthResolverError = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
class OAuthResolverError extends Error {
    constructor(message, options){
        super(message, options);
    }
    static from(cause, message) {
        if (cause instanceof OAuthResolverError) return cause;
        const validationReason = cause instanceof zod_1.ZodError ? `${cause.errors[0].path} ${cause.errors[0].message}` : null;
        const fullMessage = (message ?? `Unable to resolve identity`) + (validationReason ? ` (${validationReason})` : '');
        return new OAuthResolverError(fullMessage, {
            cause
        });
    }
}
exports.OAuthResolverError = OAuthResolverError; //# sourceMappingURL=oauth-resolver-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthResolver = void 0;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const oauth_resolver_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver-error.js [app-ssr] (ecmascript)");
class OAuthResolver {
    constructor(identityResolver, protectedResourceMetadataResolver, authorizationServerMetadataResolver){
        Object.defineProperty(this, "identityResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityResolver
        });
        Object.defineProperty(this, "protectedResourceMetadataResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: protectedResourceMetadataResolver
        });
        Object.defineProperty(this, "authorizationServerMetadataResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: authorizationServerMetadataResolver
        });
    }
    /**
     * @param input - A handle, DID, PDS URL or Entryway URL
     */ async resolve(input, options) {
        // Allow using an entryway, or PDS url, directly as login input (e.g.
        // when the user forgot their handle, or when the handle does not
        // resolve to a DID)
        return /^https?:\/\//.test(input) ? this.resolveFromService(input, options) : this.resolveFromIdentity(input, options);
    }
    /**
     * @note this method can be used to verify if a particular uri supports OAuth
     * based sign-in (for compatibility with legacy implementation).
     */ async resolveFromService(input, options) {
        try {
            // Assume first that input is a PDS URL (as required by ATPROTO)
            const metadata = await this.getResourceServerMetadata(input, options);
            return {
                metadata
            };
        } catch (err) {
            if (!options?.signal?.aborted && err instanceof oauth_resolver_error_js_1.OAuthResolverError) {
                try {
                    // Fallback to trying to fetch as an issuer (Entryway)
                    const result = oauth_types_1.oauthIssuerIdentifierSchema.safeParse(input);
                    if (result.success) {
                        const metadata = await this.getAuthorizationServerMetadata(result.data, options);
                        return {
                            metadata
                        };
                    }
                } catch  {
                // Fallback failed, throw original error
                }
            }
            throw err;
        }
    }
    async resolveFromIdentity(input, options) {
        const identity = await this.resolveIdentity(input, options);
        options?.signal?.throwIfAborted();
        const metadata = await this.getResourceServerMetadata(identity.pds, options);
        return {
            identity,
            metadata
        };
    }
    async resolveIdentity(input, options) {
        try {
            return await this.identityResolver.resolve(input, options);
        } catch (cause) {
            throw oauth_resolver_error_js_1.OAuthResolverError.from(cause, `Failed to resolve identity: ${input}`);
        }
    }
    async getAuthorizationServerMetadata(issuer, options) {
        try {
            return await this.authorizationServerMetadataResolver.get(issuer, options);
        } catch (cause) {
            throw oauth_resolver_error_js_1.OAuthResolverError.from(cause, `Failed to resolve OAuth server metadata for issuer: ${issuer}`);
        }
    }
    async getResourceServerMetadata(pdsUrl, options) {
        try {
            const rsMetadata = await this.protectedResourceMetadataResolver.get(pdsUrl, options);
            // ATPROTO requires one, and only one, authorization server entry
            if (rsMetadata.authorization_servers?.length !== 1) {
                throw new oauth_resolver_error_js_1.OAuthResolverError(rsMetadata.authorization_servers?.length ? `Unable to determine authorization server for PDS: ${pdsUrl}` : `No authorization servers found for PDS: ${pdsUrl}`);
            }
            const issuer = rsMetadata.authorization_servers[0];
            options?.signal?.throwIfAborted();
            const asMetadata = await this.getAuthorizationServerMetadata(issuer, options);
            // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-4
            if (asMetadata.protected_resources) {
                if (!asMetadata.protected_resources.includes(rsMetadata.resource)) {
                    throw new oauth_resolver_error_js_1.OAuthResolverError(`PDS "${pdsUrl}" not protected by issuer "${issuer}"`);
                }
            }
            return asMetadata;
        } catch (cause) {
            throw oauth_resolver_error_js_1.OAuthResolverError.from(cause, `Failed to resolve OAuth server metadata for resource: ${pdsUrl}`);
        }
    }
}
exports.OAuthResolver = OAuthResolver; //# sourceMappingURL=oauth-resolver.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/atproto-token-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atprotoTokenResponseSchema = exports.atprotoScopeSchema = exports.isAtprotoScope = void 0;
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
const isAtprotoScope = (input)=>(0, util_1.includesSpaceSeparatedValue)(input, 'atproto');
exports.isAtprotoScope = isAtprotoScope;
exports.atprotoScopeSchema = zod_1.z.string().refine(exports.isAtprotoScope, 'The "atproto" scope is required');
exports.atprotoTokenResponseSchema = oauth_types_1.oauthTokenResponseSchema.extend({
    token_type: zod_1.z.literal('DPoP'),
    sub: did_1.atprotoDidSchema,
    scope: exports.atprotoScopeSchema,
    // OpenID is not compatible with atproto identities
    id_token: zod_1.z.never().optional()
}); //# sourceMappingURL=atproto-token-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenRefreshError = void 0;
class TokenRefreshError extends Error {
    constructor(sub, message, options){
        super(message, options);
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
    }
}
exports.TokenRefreshError = TokenRefreshError; //# sourceMappingURL=token-refresh-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/fetch-dpop.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dpopFetchWrapper = dpopFetchWrapper;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const base64_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
// "undefined" in non https environments or environments without crypto
const subtle = globalThis.crypto?.subtle;
const ReadableStream = globalThis.ReadableStream;
function dpopFetchWrapper({ key, iss, supportedAlgs, nonces, sha256 = typeof subtle !== 'undefined' ? subtleSha256 : undefined, isAuthServer, fetch = globalThis.fetch }) {
    if (!sha256) {
        throw new TypeError(`crypto.subtle is not available in this environment. Please provide a sha256 function.`);
    }
    const alg = negotiateAlg(key, supportedAlgs);
    return async function(input, init) {
        if (!key.algorithms.includes(alg)) {
            throw new TypeError(`Key does not support the algorithm ${alg}`);
        }
        const request = init == null && input instanceof Request ? input : new Request(input, init);
        const authorizationHeader = request.headers.get('Authorization');
        const ath = authorizationHeader?.startsWith('DPoP ') ? await sha256(authorizationHeader.slice(5)) : undefined;
        const { method, url } = request;
        const { origin } = new URL(url);
        let initNonce;
        try {
            initNonce = await nonces.get(origin);
        } catch  {
        // Ignore get errors, we will just not send a nonce
        }
        const initProof = await buildProof(key, alg, iss, method, url, initNonce, ath);
        request.headers.set('DPoP', initProof);
        const initResponse = await fetch.call(this, request);
        // Make sure the response body is consumed. Either by the caller (when the
        // response is returned), of if an error is thrown (catch block).
        const nextNonce = initResponse.headers.get('DPoP-Nonce');
        if (!nextNonce || nextNonce === initNonce) {
            // No nonce was returned or it is the same as the one we sent. No need to
            // update the nonce store, or retry the request.
            return initResponse;
        }
        // Store the fresh nonce for future requests
        try {
            await nonces.set(origin, nextNonce);
        } catch  {
        // Ignore set errors
        }
        const shouldRetry = await isUseDpopNonceError(initResponse, isAuthServer);
        if (!shouldRetry) {
            // Not a "use_dpop_nonce" error, so there is no need to retry
            return initResponse;
        }
        // If the input stream was already consumed, we cannot retry the request. A
        // solution would be to clone() the request but that would bufferize the
        // entire stream in memory which can lead to memory starvation. Instead, we
        // will return the original response and let the calling code handle retries.
        if (input === request) {
            // The input request body was consumed. We cannot retry the request.
            return initResponse;
        }
        if (ReadableStream && init?.body instanceof ReadableStream) {
            // The init body was consumed. We cannot retry the request.
            return initResponse;
        }
        // We will now retry the request with the fresh nonce.
        // The initial response body must be consumed (see cancelBody's doc).
        await (0, fetch_1.cancelBody)(initResponse, 'log');
        const nextProof = await buildProof(key, alg, iss, method, url, nextNonce, ath);
        const nextRequest = new Request(input, init);
        nextRequest.headers.set('DPoP', nextProof);
        return fetch.call(this, nextRequest);
    };
}
async function buildProof(key, alg, iss, htm, htu, nonce, ath) {
    if (!key.bareJwk) {
        throw new Error('Only asymmetric keys can be used as DPoP proofs');
    }
    const now = Math.floor(Date.now() / 1e3);
    return key.createJwt(// https://datatracker.ietf.org/doc/html/rfc9449#section-4.2
    {
        alg,
        typ: 'dpop+jwt',
        jwk: key.bareJwk
    }, {
        iss,
        iat: now,
        // Any collision will cause the request to be rejected by the server. no biggie.
        jti: Math.random().toString(36).slice(2),
        htm,
        htu,
        nonce,
        ath
    });
}
async function isUseDpopNonceError(response, isAuthServer) {
    // https://datatracker.ietf.org/doc/html/rfc6750#section-3
    // https://datatracker.ietf.org/doc/html/rfc9449#name-resource-server-provided-no
    if (isAuthServer === undefined || isAuthServer === false) {
        if (response.status === 401) {
            const wwwAuth = response.headers.get('WWW-Authenticate');
            if (wwwAuth?.startsWith('DPoP')) {
                return wwwAuth.includes('error="use_dpop_nonce"');
            }
        }
    }
    // https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid
    if (isAuthServer === undefined || isAuthServer === true) {
        if (response.status === 400) {
            try {
                const json = await (0, fetch_1.peekJson)(response, 10 * 1024);
                return typeof json === 'object' && json?.['error'] === 'use_dpop_nonce';
            } catch  {
                // Response too big (to be "use_dpop_nonce" error) or invalid JSON
                return false;
            }
        }
    }
    return false;
}
function negotiateAlg(key, supportedAlgs) {
    if (supportedAlgs) {
        // Use order of supportedAlgs as preference
        const alg = supportedAlgs.find((a)=>key.algorithms.includes(a));
        if (alg) return alg;
    } else {
        const [alg] = key.algorithms;
        if (alg) return alg;
    }
    throw new Error('Key does not match any alg supported by the server');
}
async function subtleSha256(input) {
    if (subtle == null) {
        throw new Error(`crypto.subtle is not available in this environment. Please provide a sha256 function.`);
    }
    const bytes = new TextEncoder().encode(input);
    const digest = await subtle.digest('SHA-256', bytes);
    const digestBytes = new Uint8Array(digest);
    return base64_1.base64url.baseEncode(digestBytes);
} //# sourceMappingURL=fetch-dpop.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthResponseError = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
class OAuthResponseError extends Error {
    constructor(response, payload){
        const error = (0, fetch_1.ifString)((0, fetch_1.ifObject)(payload)?.['error']);
        const errorDescription = (0, fetch_1.ifString)((0, fetch_1.ifObject)(payload)?.['error_description']);
        const messageError = error ? `"${error}"` : 'unknown';
        const messageDesc = errorDescription ? `: ${errorDescription}` : '';
        const message = `OAuth ${messageError} error${messageDesc}`;
        super(message);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: response
        });
        Object.defineProperty(this, "payload", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: payload
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "errorDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.error = error;
        this.errorDescription = errorDescription;
    }
    get status() {
        return this.response.status;
    }
    get headers() {
        return this.response.headers;
    }
}
exports.OAuthResponseError = OAuthResponseError; //# sourceMappingURL=oauth-response-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-server-agent.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __addDisposableResource = this && this.__addDisposableResource || function(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
};
var __disposeResources = this && this.__disposeResources || function(SuppressedError1) {
    return function(env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError1(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthServerAgent = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const atproto_token_response_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/atproto-token-response.js [app-ssr] (ecmascript)");
const constants_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/constants.js [app-ssr] (ecmascript)");
const token_refresh_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)");
const fetch_dpop_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/fetch-dpop.js [app-ssr] (ecmascript)");
const oauth_response_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
class OAuthServerAgent {
    constructor(dpopKey, serverMetadata, clientMetadata, dpopNonces, oauthResolver, runtime, keyset, fetch){
        Object.defineProperty(this, "dpopKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dpopKey
        });
        Object.defineProperty(this, "serverMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: serverMetadata
        });
        Object.defineProperty(this, "clientMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clientMetadata
        });
        Object.defineProperty(this, "dpopNonces", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dpopNonces
        });
        Object.defineProperty(this, "oauthResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: oauthResolver
        });
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: runtime
        });
        Object.defineProperty(this, "keyset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyset
        });
        Object.defineProperty(this, "dpopFetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dpopFetch = (0, fetch_dpop_js_1.dpopFetchWrapper)({
            fetch: (0, fetch_1.bindFetch)(fetch),
            iss: clientMetadata.client_id,
            key: dpopKey,
            supportedAlgs: serverMetadata.dpop_signing_alg_values_supported,
            sha256: async (v)=>runtime.sha256(v),
            nonces: dpopNonces,
            isAuthServer: true
        });
    }
    get issuer() {
        return this.serverMetadata.issuer;
    }
    async revoke(token) {
        try {
            await this.request('revocation', {
                token
            });
        } catch  {
        // Don't care
        }
    }
    async exchangeCode(code, codeVerifier) {
        const now = Date.now();
        const tokenResponse = await this.request('token', {
            grant_type: 'authorization_code',
            redirect_uri: this.clientMetadata.redirect_uris[0],
            code,
            code_verifier: codeVerifier
        });
        try {
            // /!\ IMPORTANT /!\
            //
            // The tokenResponse MUST always be valid before the "sub" it contains
            // can be trusted (see Atproto's OAuth spec for details).
            const aud = await this.verifyIssuer(tokenResponse.sub);
            return {
                aud,
                sub: tokenResponse.sub,
                iss: this.issuer,
                scope: tokenResponse.scope,
                refresh_token: tokenResponse.refresh_token,
                access_token: tokenResponse.access_token,
                token_type: tokenResponse.token_type,
                expires_at: typeof tokenResponse.expires_in === 'number' ? new Date(now + tokenResponse.expires_in * 1000).toISOString() : undefined
            };
        } catch (err) {
            await this.revoke(tokenResponse.access_token);
            throw err;
        }
    }
    async refresh(tokenSet) {
        if (!tokenSet.refresh_token) {
            throw new token_refresh_error_js_1.TokenRefreshError(tokenSet.sub, 'No refresh token available');
        }
        // /!\ IMPORTANT /!\
        //
        // The "sub" MUST be a DID, whose issuer authority is indeed the server we
        // are trying to obtain credentials from. Note that we are doing this
        // *before* we actually try to refresh the token:
        // 1) To avoid unnecessary refresh
        // 2) So that the refresh is the last async operation, ensuring as few
        //    async operations happen before the result gets a chance to be stored.
        const aud = await this.verifyIssuer(tokenSet.sub);
        const now = Date.now();
        const tokenResponse = await this.request('token', {
            grant_type: 'refresh_token',
            refresh_token: tokenSet.refresh_token
        });
        return {
            aud,
            sub: tokenSet.sub,
            iss: this.issuer,
            scope: tokenResponse.scope,
            refresh_token: tokenResponse.refresh_token,
            access_token: tokenResponse.access_token,
            token_type: tokenResponse.token_type,
            expires_at: typeof tokenResponse.expires_in === 'number' ? new Date(now + tokenResponse.expires_in * 1000).toISOString() : undefined
        };
    }
    /**
     * VERY IMPORTANT ! Always call this to process token responses.
     *
     * Whenever an OAuth token response is received, we **MUST** verify that the
     * "sub" is a DID, whose issuer authority is indeed the server we just
     * obtained credentials from. This check is a critical step to actually be
     * able to use the "sub" (DID) as being the actual user's identifier.
     *
     * @returns The user's PDS URL (the resource server for the user)
     */ async verifyIssuer(sub) {
        const env_1 = {
            stack: [],
            error: void 0,
            hasError: false
        };
        try {
            const signal = __addDisposableResource(env_1, (0, util_js_1.timeoutSignal)(10e3), false);
            const resolved = await this.oauthResolver.resolveFromIdentity(sub, {
                noCache: true,
                allowStale: false,
                signal
            });
            if (this.issuer !== resolved.metadata.issuer) {
                // Best case scenario; the user switched PDS. Worst case scenario; a bad
                // actor is trying to impersonate a user. In any case, we must not allow
                // this token to be used.
                throw new TypeError('Issuer mismatch');
            }
            return resolved.identity.pds.href;
        } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        } finally{
            __disposeResources(env_1);
        }
    }
    async request(endpoint, payload) {
        const url = this.serverMetadata[`${endpoint}_endpoint`];
        if (!url) throw new Error(`No ${endpoint} endpoint available`);
        const auth = await this.buildClientAuth(endpoint);
        const { response, json } = await this.dpopFetch(url, {
            method: 'POST',
            headers: {
                ...auth.headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ...payload,
                ...auth.payload
            })
        }).then((0, fetch_1.fetchJsonProcessor)());
        if (response.ok) {
            switch(endpoint){
                case 'token':
                    return atproto_token_response_js_1.atprotoTokenResponseSchema.parse(json);
                case 'pushed_authorization_request':
                    return oauth_types_1.oauthParResponseSchema.parse(json);
                default:
                    return json;
            }
        } else {
            throw new oauth_response_error_js_1.OAuthResponseError(response, json);
        }
    }
    async buildClientAuth(endpoint) {
        const methodSupported = this.serverMetadata[`token_endpoint_auth_methods_supported`];
        const method = this.clientMetadata[`token_endpoint_auth_method`];
        if (method === 'private_key_jwt' || this.keyset && !method && (methodSupported?.includes('private_key_jwt') ?? false)) {
            if (!this.keyset) throw new Error('No keyset available');
            try {
                const alg = this.serverMetadata[`token_endpoint_auth_signing_alg_values_supported`] ?? constants_js_1.FALLBACK_ALG;
                // If jwks is defined, make sure to only sign using a key that exists in
                // the jwks. If jwks_uri is defined, we can't be sure that the key we're
                // looking for is in there so we will just assume it is.
                const kid = this.clientMetadata.jwks?.keys.map(({ kid })=>kid).filter((v)=>typeof v === 'string');
                return {
                    payload: {
                        client_id: this.clientMetadata.client_id,
                        client_assertion_type: oauth_types_1.CLIENT_ASSERTION_TYPE_JWT_BEARER,
                        client_assertion: await this.keyset.createJwt({
                            alg,
                            kid
                        }, {
                            iss: this.clientMetadata.client_id,
                            sub: this.clientMetadata.client_id,
                            aud: this.serverMetadata.issuer,
                            jti: await this.runtime.generateNonce(),
                            iat: Math.floor(Date.now() / 1000)
                        })
                    }
                };
            } catch (err) {
                if (method === 'private_key_jwt') throw err;
            // Else try next method
            }
        }
        if (method === 'none' || !method && (methodSupported?.includes('none') ?? true)) {
            return {
                payload: {
                    client_id: this.clientMetadata.client_id
                }
            };
        }
        throw new Error(`Unsupported ${endpoint} authentication method`);
    }
}
exports.OAuthServerAgent = OAuthServerAgent; //# sourceMappingURL=oauth-server-agent.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-server-factory.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthServerFactory = void 0;
const oauth_server_agent_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-agent.js [app-ssr] (ecmascript)");
class OAuthServerFactory {
    constructor(clientMetadata, runtime, resolver, fetch, keyset, dpopNonceCache){
        Object.defineProperty(this, "clientMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clientMetadata
        });
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: runtime
        });
        Object.defineProperty(this, "resolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolver
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fetch
        });
        Object.defineProperty(this, "keyset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyset
        });
        Object.defineProperty(this, "dpopNonceCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dpopNonceCache
        });
    }
    async fromIssuer(issuer, dpopKey, options) {
        const serverMetadata = await this.resolver.getAuthorizationServerMetadata(issuer, options);
        return this.fromMetadata(serverMetadata, dpopKey);
    }
    async fromMetadata(serverMetadata, dpopKey) {
        return new oauth_server_agent_js_1.OAuthServerAgent(dpopKey, serverMetadata, this.clientMetadata, this.dpopNonceCache, this.resolver, this.runtime, this.keyset, this.fetch);
    }
}
exports.OAuthServerFactory = OAuthServerFactory; //# sourceMappingURL=oauth-server-factory.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenInvalidError = void 0;
class TokenInvalidError extends Error {
    constructor(sub, message = `The session for "${sub}" is invalid`, options){
        super(message, options);
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
    }
}
exports.TokenInvalidError = TokenInvalidError; //# sourceMappingURL=token-invalid-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-session.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthSession = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const token_invalid_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)");
const token_revoked_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)");
const fetch_dpop_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/fetch-dpop.js [app-ssr] (ecmascript)");
const ReadableStream = globalThis.ReadableStream;
class OAuthSession {
    constructor(server, sub, sessionGetter, fetch = globalThis.fetch){
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: server
        });
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
        Object.defineProperty(this, "sessionGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sessionGetter
        });
        Object.defineProperty(this, "dpopFetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dpopFetch = (0, fetch_dpop_js_1.dpopFetchWrapper)({
            fetch: (0, fetch_1.bindFetch)(fetch),
            iss: server.clientMetadata.client_id,
            key: server.dpopKey,
            supportedAlgs: server.serverMetadata.dpop_signing_alg_values_supported,
            sha256: async (v)=>server.runtime.sha256(v),
            nonces: server.dpopNonces,
            isAuthServer: false
        });
    }
    get did() {
        return this.sub;
    }
    get serverMetadata() {
        return this.server.serverMetadata;
    }
    /**
     * @param refresh When `true`, the credentials will be refreshed even if they
     * are not expired. When `false`, the credentials will not be refreshed even
     * if they are expired. When `undefined`, the credentials will be refreshed
     * if, and only if, they are (about to be) expired. Defaults to `undefined`.
     */ async getTokenSet(refresh) {
        const { tokenSet } = await this.sessionGetter.get(this.sub, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
        return tokenSet;
    }
    async getTokenInfo(refresh = 'auto') {
        const tokenSet = await this.getTokenSet(refresh);
        const expiresAt = tokenSet.expires_at == null ? undefined : new Date(tokenSet.expires_at);
        return {
            expiresAt,
            get expired () {
                return expiresAt == null ? undefined : expiresAt.getTime() < Date.now() - 5e3;
            },
            scope: tokenSet.scope,
            iss: tokenSet.iss,
            aud: tokenSet.aud,
            sub: tokenSet.sub
        };
    }
    async signOut() {
        try {
            const tokenSet = await this.getTokenSet(false);
            await this.server.revoke(tokenSet.access_token);
        } finally{
            await this.sessionGetter.delStored(this.sub, new token_revoked_error_js_1.TokenRevokedError(this.sub));
        }
    }
    async fetchHandler(pathname, init) {
        // This will try and refresh the token if it is known to be expired
        const tokenSet = await this.getTokenSet('auto');
        const initialUrl = new URL(pathname, tokenSet.aud);
        const initialAuth = `${tokenSet.token_type} ${tokenSet.access_token}`;
        const headers = new Headers(init?.headers);
        headers.set('Authorization', initialAuth);
        const initialResponse = await this.dpopFetch(initialUrl, {
            ...init,
            headers
        });
        // If the token is not expired, we don't need to refresh it
        if (!isInvalidTokenResponse(initialResponse)) {
            return initialResponse;
        }
        let tokenSetFresh;
        try {
            // Force a refresh
            tokenSetFresh = await this.getTokenSet(true);
        } catch (err) {
            return initialResponse;
        }
        // The stream was already consumed. We cannot retry the request. A solution
        // would be to tee() the input stream but that would bufferize the entire
        // stream in memory which can lead to memory starvation. Instead, we will
        // return the original response and let the calling code handle retries.
        if (ReadableStream && init?.body instanceof ReadableStream) {
            return initialResponse;
        }
        const finalAuth = `${tokenSetFresh.token_type} ${tokenSetFresh.access_token}`;
        const finalUrl = new URL(pathname, tokenSetFresh.aud);
        headers.set('Authorization', finalAuth);
        const finalResponse = await this.dpopFetch(finalUrl, {
            ...init,
            headers
        });
        // The token was successfully refreshed, but is still not accepted by the
        // resource server. This might be due to the resource server not accepting
        // credentials from the authorization server (e.g. because some migration
        // occurred). Any ways, there is no point in keeping the session.
        if (isInvalidTokenResponse(finalResponse)) {
            // TODO: Is there a "softer" way to handle this, e.g. by marking the
            // session as "expired" in the session store, allowing the user to trigger
            // a new login (using login_hint)?
            await this.sessionGetter.delStored(this.sub, new token_invalid_error_js_1.TokenInvalidError(this.sub));
        }
        return finalResponse;
    }
}
exports.OAuthSession = OAuthSession;
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc6750#section-3}
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9449#name-resource-server-provided-no}
 */ function isInvalidTokenResponse(response) {
    if (response.status !== 401) return false;
    const wwwAuth = response.headers.get('WWW-Authenticate');
    return wwwAuth != null && (wwwAuth.startsWith('Bearer ') || wwwAuth.startsWith('DPoP ')) && wwwAuth.includes('error="invalid_token"');
} //# sourceMappingURL=oauth-session.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/lock.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.requestLocalLock = void 0;
const locks = new Map();
function acquireLocalLock(name) {
    return new Promise((resolveAcquire)=>{
        const prev = locks.get(name) ?? Promise.resolve();
        const next = prev.then(()=>{
            return new Promise((resolveRelease)=>{
                const release = ()=>{
                    // Only delete the lock if it is still the current one
                    if (locks.get(name) === next) locks.delete(name);
                    resolveRelease();
                };
                resolveAcquire(release);
            });
        });
        locks.set(name, next);
    });
}
const requestLocalLock = (name, fn)=>{
    return acquireLocalLock(name).then(async (release)=>{
        try {
            return await fn();
        } finally{
            release();
        }
    });
};
exports.requestLocalLock = requestLocalLock; //# sourceMappingURL=lock.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Runtime = void 0;
const base64_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
const lock_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/lock.js [app-ssr] (ecmascript)");
class Runtime {
    constructor(implementation){
        Object.defineProperty(this, "implementation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: implementation
        });
        Object.defineProperty(this, "hasImplementationLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "usingLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { requestLock } = implementation;
        this.hasImplementationLock = requestLock != null;
        this.usingLock = requestLock?.bind(implementation) || // Falling back to a local lock
        lock_js_1.requestLocalLock;
    }
    async generateKey(algs) {
        const algsSorted = Array.from(algs).sort(compareAlgos);
        return this.implementation.createKey(algsSorted);
    }
    async sha256(text) {
        const bytes = new TextEncoder().encode(text);
        const digest = await this.implementation.digest(bytes, {
            name: 'sha256'
        });
        return base64_1.base64url.baseEncode(digest);
    }
    async generateNonce(length = 16) {
        const bytes = await this.implementation.getRandomValues(length);
        return base64_1.base64url.baseEncode(bytes);
    }
    async generatePKCE(byteLength) {
        const verifier = await this.generateVerifier(byteLength);
        return {
            verifier,
            challenge: await this.sha256(verifier),
            method: 'S256'
        };
    }
    async calculateJwkThumbprint(jwk) {
        const components = extractJktComponents(jwk);
        const data = JSON.stringify(components);
        return this.sha256(data);
    }
    /**
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7636#section-4.1}
     * @note It is RECOMMENDED that the output of a suitable random number generator
     * be used to create a 32-octet sequence. The octet sequence is then
     * base64url-encoded to produce a 43-octet URL safe string to use as the code
     * verifier.
     */ async generateVerifier(byteLength = 32) {
        if (byteLength < 32 || byteLength > 96) {
            throw new TypeError('Invalid code_verifier length');
        }
        const bytes = await this.implementation.getRandomValues(byteLength);
        return base64_1.base64url.baseEncode(bytes);
    }
}
exports.Runtime = Runtime;
function extractJktComponents(jwk) {
    const get = (field)=>{
        const value = jwk[field];
        if (typeof value !== 'string' || !value) {
            throw new TypeError(`"${field}" Parameter missing or invalid`);
        }
        return value;
    };
    switch(jwk.kty){
        case 'EC':
            return {
                crv: get('crv'),
                kty: get('kty'),
                x: get('x'),
                y: get('y')
            };
        case 'OKP':
            return {
                crv: get('crv'),
                kty: get('kty'),
                x: get('x')
            };
        case 'RSA':
            return {
                e: get('e'),
                kty: get('kty'),
                n: get('n')
            };
        case 'oct':
            return {
                k: get('k'),
                kty: get('kty')
            };
        default:
            throw new TypeError('"kty" (Key Type) Parameter missing or unsupported');
    }
}
/**
 * 256K > ES (256 > 384 > 512) > PS (256 > 384 > 512) > RS (256 > 384 > 512) > other (in original order)
 */ function compareAlgos(a, b) {
    if (a === 'ES256K') return -1;
    if (b === 'ES256K') return 1;
    for (const prefix of [
        'ES',
        'PS',
        'RS'
    ]){
        if (a.startsWith(prefix)) {
            if (b.startsWith(prefix)) {
                const aLen = parseInt(a.slice(2, 5));
                const bLen = parseInt(b.slice(2, 5));
                // Prefer shorter key lengths
                return aLen - bLen;
            }
            return -1;
        } else if (b.startsWith(prefix)) {
            return 1;
        }
    }
    // Don't know how to compare, keep original order
    return 0;
} //# sourceMappingURL=runtime.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/session-getter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __addDisposableResource = this && this.__addDisposableResource || function(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
};
var __disposeResources = this && this.__disposeResources || function(SuppressedError1) {
    return function(env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError1(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionGetter = void 0;
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const token_invalid_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)");
const token_refresh_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)");
const token_revoked_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)");
const oauth_response_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
/**
 * There are several advantages to wrapping the sessionStore in a (single)
 * CachedGetter, the main of which is that the cached getter will ensure that at
 * most one fresh call is ever being made. Another advantage, is that it
 * contains the logic for reading from the cache which, if the cache is based on
 * localStorage/indexedDB, will sync across multiple tabs (for a given sub).
 */ class SessionGetter extends simple_store_1.CachedGetter {
    constructor(sessionStore, serverFactory, runtime){
        super(async (sub, options, storedSession)=>{
            // There needs to be a previous session to be able to refresh. If
            // storedSession is undefined, it means that the store does not contain
            // a session for the given sub.
            if (storedSession === undefined) {
                // Because the session is not in the store, this.delStored() method
                // will not be called by the CachedGetter class (because there is
                // nothing to delete). This would typically happen if there is no
                // synchronization mechanism between instances of this class. Let's
                // make sure an event is dispatched here if this occurs.
                const msg = 'The session was deleted by another process';
                const cause = new token_refresh_error_js_1.TokenRefreshError(sub, msg);
                this.dispatchEvent('deleted', {
                    sub,
                    cause
                });
                throw cause;
            }
            // From this point forward, throwing a TokenRefreshError will result in
            // this.delStored() being called, resulting in an event being
            // dispatched, even if the session was removed from the store through a
            // concurrent access (which, normally, should not happen if a proper
            // runtime lock was provided).
            const { dpopKey, tokenSet } = storedSession;
            if (sub !== tokenSet.sub) {
                // Fool-proofing (e.g. against invalid session storage)
                throw new token_refresh_error_js_1.TokenRefreshError(sub, 'Stored session sub mismatch');
            }
            if (!tokenSet.refresh_token) {
                throw new token_refresh_error_js_1.TokenRefreshError(sub, 'No refresh token available');
            }
            // Since refresh tokens can only be used once, we might run into
            // concurrency issues if multiple instances (e.g. browser tabs) are
            // trying to refresh the same token simultaneously. The chances of this
            // happening when multiple instances are started simultaneously is
            // reduced by randomizing the expiry time (see isStale() below). The
            // best solution is to use a mutex/lock to ensure that only one instance
            // is refreshing the token at a time (runtime.usingLock) but that is not
            // always possible. If no lock implementation is provided, we will use
            // the store to check if a concurrent refresh occurred.
            const server = await serverFactory.fromIssuer(tokenSet.iss, dpopKey);
            // Because refresh tokens can only be used once, we must not use the
            // "signal" to abort the refresh, or throw any abort error beyond this
            // point. Any thrown error beyond this point will prevent the
            // TokenGetter from obtaining, and storing, the new token set,
            // effectively rendering the currently saved session unusable.
            options?.signal?.throwIfAborted();
            try {
                const newTokenSet = await server.refresh(tokenSet);
                if (sub !== newTokenSet.sub) {
                    // The server returned another sub. Was the tokenSet manipulated?
                    throw new token_refresh_error_js_1.TokenRefreshError(sub, 'Token set sub mismatch');
                }
                return {
                    dpopKey,
                    tokenSet: newTokenSet
                };
            } catch (cause) {
                // If the refresh token is invalid, let's try to recover from
                // concurrency issues, or make sure the session is deleted by throwing
                // a TokenRefreshError.
                if (cause instanceof oauth_response_error_js_1.OAuthResponseError && cause.status === 400 && cause.error === 'invalid_grant') {
                    // In case there is no lock implementation in the runtime, we will
                    // wait for a short time to give the other concurrent instances a
                    // chance to finish their refreshing of the token. If a concurrent
                    // refresh did occur, we will pretend that this one succeeded.
                    if (!runtime.hasImplementationLock) {
                        await new Promise((r)=>setTimeout(r, 1000));
                        const stored = await this.getStored(sub);
                        if (stored === undefined) {
                            // A concurrent refresh occurred and caused the session to be
                            // deleted (for a reason we can't know at this point).
                            // Using a distinct error message mainly for debugging
                            // purposes. Also, throwing a TokenRefreshError to trigger
                            // deletion through the deleteOnError callback.
                            const msg = 'The session was deleted by another process';
                            throw new token_refresh_error_js_1.TokenRefreshError(sub, msg, {
                                cause
                            });
                        } else if (stored.tokenSet.access_token !== tokenSet.access_token || stored.tokenSet.refresh_token !== tokenSet.refresh_token) {
                            // A concurrent refresh occurred. Pretend this one succeeded.
                            return stored;
                        } else {
                        // There were no concurrent refresh. The token is (likely)
                        // simply no longer valid.
                        }
                    }
                    // Make sure the session gets deleted from the store
                    const msg = cause.errorDescription ?? 'The session was revoked';
                    throw new token_refresh_error_js_1.TokenRefreshError(sub, msg, {
                        cause
                    });
                }
                throw cause;
            }
        }, sessionStore, {
            isStale: (sub, { tokenSet })=>{
                return tokenSet.expires_at != null && new Date(tokenSet.expires_at).getTime() < Date.now() + // Add some lee way to ensure the token is not expired when it
                // reaches the server.
                10e3 + // Add some randomness to reduce the chances of multiple
                // instances trying to refresh the token at the same.
                30e3 * Math.random();
            },
            onStoreError: async (err, sub, { tokenSet, dpopKey })=>{
                // If the token data cannot be stored, let's revoke it
                const server = await serverFactory.fromIssuer(tokenSet.iss, dpopKey);
                await server.revoke(tokenSet.refresh_token ?? tokenSet.access_token);
                throw err;
            },
            deleteOnError: async (err)=>// Optimization: More likely to happen first
                err instanceof token_refresh_error_js_1.TokenRefreshError || err instanceof token_revoked_error_js_1.TokenRevokedError || err instanceof token_invalid_error_js_1.TokenInvalidError
        });
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: runtime
        });
        Object.defineProperty(this, "eventTarget", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new util_js_1.CustomEventTarget()
        });
    }
    addEventListener(type, callback, options) {
        this.eventTarget.addEventListener(type, callback, options);
    }
    removeEventListener(type, callback, options) {
        this.eventTarget.removeEventListener(type, callback, options);
    }
    dispatchEvent(type, detail) {
        return this.eventTarget.dispatchCustomEvent(type, detail);
    }
    async setStored(sub, session) {
        // Prevent tampering with the stored value
        if (sub !== session.tokenSet.sub) {
            throw new TypeError('Token set does not match the expected sub');
        }
        await super.setStored(sub, session);
        this.dispatchEvent('updated', {
            sub,
            ...session
        });
    }
    async delStored(sub, cause) {
        await super.delStored(sub, cause);
        this.dispatchEvent('deleted', {
            sub,
            cause
        });
    }
    /**
     * @param refresh When `true`, the credentials will be refreshed even if they
     * are not expired. When `false`, the credentials will not be refreshed even
     * if they are expired. When `undefined`, the credentials will be refreshed
     * if, and only if, they are (about to be) expired. Defaults to `undefined`.
     */ async getSession(sub, refresh) {
        return this.get(sub, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
    }
    async get(sub, options) {
        const session = await this.runtime.usingLock(`@atproto-oauth-client-${sub}`, async ()=>{
            const env_1 = {
                stack: [],
                error: void 0,
                hasError: false
            };
            try {
                // Make sure, even if there is no signal in the options, that the
                // request will be cancelled after at most 30 seconds.
                const signal = __addDisposableResource(env_1, (0, util_js_1.timeoutSignal)(30e3, options), false);
                const abortController = __addDisposableResource(env_1, (0, util_js_1.combineSignals)([
                    options?.signal,
                    signal
                ]), false);
                return await super.get(sub, {
                    ...options,
                    signal: abortController.signal
                });
            } catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            } finally{
                __disposeResources(env_1);
            }
        });
        if (sub !== session.tokenSet.sub) {
            // Fool-proofing (e.g. against invalid session storage)
            throw new Error('Token set does not match the expected sub');
        }
        return session;
    }
}
exports.SessionGetter = SessionGetter; //# sourceMappingURL=session-getter.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clientMetadataSchema = void 0;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.clientMetadataSchema = oauth_types_1.oauthClientMetadataSchema.extend({
    client_id: zod_1.z.union([
        oauth_types_1.oauthClientIdDiscoverableSchema,
        oauth_types_1.oauthClientIdLoopbackSchema
    ])
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/validate-client-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateClientMetadata = validateClientMetadata;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const types_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/types.js [app-ssr] (ecmascript)");
const TOKEN_ENDPOINT_AUTH_METHOD = `token_endpoint_auth_method`;
const TOKEN_ENDPOINT_AUTH_SIGNING_ALG = `token_endpoint_auth_signing_alg`;
function validateClientMetadata(input, keyset) {
    if (input.jwks) {
        if (!keyset) {
            throw new TypeError(`Keyset must not be provided when jwks is provided`);
        }
        for (const key of input.jwks.keys){
            if (!key.kid) {
                throw new TypeError(`Key must have a "kid" property`);
            } else if (!keyset.has(key.kid)) {
                throw new TypeError(`Key with kid "${key.kid}" not found in keyset`);
            }
        }
    }
    // Allow to pass a keyset and omit the jwks/jwks_uri properties
    if (!input.jwks && !input.jwks_uri && keyset?.size) {
        input = {
            ...input,
            jwks: keyset.toJSON()
        };
    }
    const metadata = types_js_1.clientMetadataSchema.parse(input);
    // Validate client ID
    if (metadata.client_id.startsWith('http:')) {
        (0, oauth_types_1.assertOAuthLoopbackClientId)(metadata.client_id);
    } else {
        (0, oauth_types_1.assertOAuthDiscoverableClientId)(metadata.client_id);
    }
    const scopes = metadata.scope?.split(' ');
    if (!scopes?.includes('atproto')) {
        throw new TypeError(`Client metadata must include the "atproto" scope`);
    }
    if (!metadata.response_types.includes('code')) {
        throw new TypeError(`"response_types" must include "code"`);
    }
    if (!metadata.grant_types.includes('authorization_code')) {
        throw new TypeError(`"grant_types" must include "authorization_code"`);
    }
    const method = metadata[TOKEN_ENDPOINT_AUTH_METHOD];
    switch(method){
        case undefined:
            throw new TypeError(`${TOKEN_ENDPOINT_AUTH_METHOD} must be provided`);
        case 'none':
            if (metadata[TOKEN_ENDPOINT_AUTH_SIGNING_ALG]) {
                throw new TypeError(`${TOKEN_ENDPOINT_AUTH_SIGNING_ALG} must not be provided when ${TOKEN_ENDPOINT_AUTH_METHOD} is "${method}"`);
            }
            break;
        case 'private_key_jwt':
            if (!keyset?.size) {
                throw new TypeError(`A non-empty keyset must be provided when ${TOKEN_ENDPOINT_AUTH_METHOD} is "${method}"`);
            }
            if (!metadata[TOKEN_ENDPOINT_AUTH_SIGNING_ALG]) {
                throw new TypeError(`${TOKEN_ENDPOINT_AUTH_SIGNING_ALG} must be provided when ${TOKEN_ENDPOINT_AUTH_METHOD} is "${method}"`);
            }
            break;
        default:
            throw new TypeError(`Invalid "token_endpoint_auth_method" value: ${method}`);
    }
    return metadata;
} //# sourceMappingURL=validate-client-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthClient = void 0;
const did_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/index.js [app-ssr] (ecmascript)");
const handle_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)");
const identity_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/identity-resolver/dist/index.js [app-ssr] (ecmascript)");
const simple_store_memory_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)");
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const constants_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/constants.js [app-ssr] (ecmascript)");
const token_revoked_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)");
const oauth_authorization_server_metadata_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-authorization-server-metadata-resolver.js [app-ssr] (ecmascript)");
const oauth_callback_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-callback-error.js [app-ssr] (ecmascript)");
const oauth_protected_resource_metadata_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-protected-resource-metadata-resolver.js [app-ssr] (ecmascript)");
const oauth_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver.js [app-ssr] (ecmascript)");
const oauth_server_factory_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-factory.js [app-ssr] (ecmascript)");
const oauth_session_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-session.js [app-ssr] (ecmascript)");
const runtime_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/runtime.js [app-ssr] (ecmascript)");
const session_getter_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/session-getter.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
const validate_client_metadata_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/validate-client-metadata.js [app-ssr] (ecmascript)");
class OAuthClient extends util_js_1.CustomEventTarget {
    static async fetchMetadata({ clientId, fetch = globalThis.fetch, signal }) {
        signal?.throwIfAborted();
        const request = new Request(clientId, {
            redirect: 'error',
            signal: signal
        });
        const response = await fetch(request);
        if (response.status !== 200) {
            response.body?.cancel?.();
            throw new TypeError(`Failed to fetch client metadata: ${response.status}`);
        }
        // https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#section-4.1
        const mime = response.headers.get('content-type')?.split(';')[0].trim();
        if (mime !== 'application/json') {
            response.body?.cancel?.();
            throw new TypeError(`Invalid client metadata content type: ${mime}`);
        }
        const json = await response.json();
        signal?.throwIfAborted();
        return oauth_types_1.oauthClientMetadataSchema.parse(json);
    }
    constructor({ fetch = globalThis.fetch, allowHttp = false, stateStore, sessionStore, didCache = undefined, dpopNonceCache = new simple_store_memory_1.SimpleStoreMemory({
        ttl: 60e3,
        max: 100
    }), handleCache = undefined, authorizationServerMetadataCache = new simple_store_memory_1.SimpleStoreMemory({
        ttl: 60e3,
        max: 100
    }), protectedResourceMetadataCache = new simple_store_memory_1.SimpleStoreMemory({
        ttl: 60e3,
        max: 100
    }), responseMode, clientMetadata, handleResolver, plcDirectoryUrl, runtimeImplementation, keyset }){
        super();
        // Config
        Object.defineProperty(this, "clientMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "responseMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Services
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oauthResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "serverFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Stores
        Object.defineProperty(this, "sessionGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stateStore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.keyset = keyset ? keyset instanceof jwk_1.Keyset ? keyset : new jwk_1.Keyset(keyset) : undefined;
        this.clientMetadata = (0, validate_client_metadata_js_1.validateClientMetadata)(clientMetadata, this.keyset);
        this.responseMode = responseMode;
        this.runtime = new runtime_js_1.Runtime(runtimeImplementation);
        this.fetch = fetch;
        this.oauthResolver = new oauth_resolver_js_1.OAuthResolver(new identity_resolver_1.IdentityResolver(new did_resolver_1.DidResolverCached(new did_resolver_1.DidResolverCommon({
            fetch,
            plcDirectoryUrl,
            allowHttp
        }), didCache), new handle_resolver_1.CachedHandleResolver(handle_resolver_1.AppViewHandleResolver.from(handleResolver, {
            fetch
        }), handleCache)), new oauth_protected_resource_metadata_resolver_js_1.OAuthProtectedResourceMetadataResolver(protectedResourceMetadataCache, fetch, {
            allowHttpResource: allowHttp
        }), new oauth_authorization_server_metadata_resolver_js_1.OAuthAuthorizationServerMetadataResolver(authorizationServerMetadataCache, fetch, {
            allowHttpIssuer: allowHttp
        }));
        this.serverFactory = new oauth_server_factory_js_1.OAuthServerFactory(this.clientMetadata, this.runtime, this.oauthResolver, this.fetch, this.keyset, dpopNonceCache);
        this.sessionGetter = new session_getter_js_1.SessionGetter(sessionStore, this.serverFactory, this.runtime);
        this.stateStore = stateStore;
        // Proxy sessionGetter events
        for (const type of [
            'deleted',
            'updated'
        ]){
            this.sessionGetter.addEventListener(type, (event)=>{
                if (!this.dispatchCustomEvent(type, event.detail)) {
                    event.preventDefault();
                }
            });
        }
    }
    // Exposed as public API for convenience
    get identityResolver() {
        return this.oauthResolver.identityResolver;
    }
    // Exposed as public API for convenience
    get didResolver() {
        return this.identityResolver.didResolver;
    }
    // Exposed as public API for convenience
    get handleResolver() {
        return this.identityResolver.handleResolver;
    }
    get jwks() {
        return this.keyset?.publicJwks ?? {
            keys: []
        };
    }
    async authorize(input, { signal, ...options } = {}) {
        const redirectUri = options?.redirect_uri ?? this.clientMetadata.redirect_uris[0];
        if (!this.clientMetadata.redirect_uris.includes(redirectUri)) {
            // The server will enforce this, but let's catch it early
            throw new TypeError('Invalid redirect_uri');
        }
        const { identity, metadata } = await this.oauthResolver.resolve(input, {
            signal
        });
        const pkce = await this.runtime.generatePKCE();
        const dpopKey = await this.runtime.generateKey(metadata.dpop_signing_alg_values_supported || [
            constants_js_1.FALLBACK_ALG
        ]);
        const state = await this.runtime.generateNonce();
        await this.stateStore.set(state, {
            iss: metadata.issuer,
            dpopKey,
            verifier: pkce.verifier,
            appState: options?.state
        });
        const parameters = {
            ...options,
            client_id: this.clientMetadata.client_id,
            redirect_uri: redirectUri,
            code_challenge: pkce.challenge,
            code_challenge_method: pkce.method,
            state,
            login_hint: identity ? input // If input is a handle or a DID, use it as a login_hint
             : undefined,
            response_mode: this.responseMode,
            response_type: 'code',
            scope: options?.scope ?? this.clientMetadata.scope
        };
        const authorizationUrl = new URL(metadata.authorization_endpoint);
        // Since the user will be redirected to the authorization_endpoint url using
        // a browser, we need to make sure that the url is valid.
        if (authorizationUrl.protocol !== 'https:' && authorizationUrl.protocol !== 'http:') {
            throw new TypeError(`Invalid authorization endpoint protocol: ${authorizationUrl.protocol}`);
        }
        if (metadata.pushed_authorization_request_endpoint) {
            const server = await this.serverFactory.fromMetadata(metadata, dpopKey);
            const parResponse = await server.request('pushed_authorization_request', parameters);
            authorizationUrl.searchParams.set('client_id', this.clientMetadata.client_id);
            authorizationUrl.searchParams.set('request_uri', parResponse.request_uri);
            return authorizationUrl;
        } else if (metadata.require_pushed_authorization_requests) {
            throw new Error('Server requires pushed authorization requests (PAR) but no PAR endpoint is available');
        } else {
            for (const [key, value] of Object.entries(parameters)){
                if (value) authorizationUrl.searchParams.set(key, String(value));
            }
            // Length of the URL that will be sent to the server
            const urlLength = authorizationUrl.pathname.length + authorizationUrl.search.length;
            if (urlLength < 2048) {
                return authorizationUrl;
            } else if (!metadata.pushed_authorization_request_endpoint) {
                throw new Error('Login URL too long');
            }
        }
        throw new Error('Server does not support pushed authorization requests (PAR)');
    }
    /**
     * This method allows the client to proactively revoke the request_uri it
     * created through PAR.
     */ async abortRequest(authorizeUrl) {
        const requestUri = authorizeUrl.searchParams.get('request_uri');
        if (!requestUri) return;
    // @NOTE This is not implemented here because, 1) the request server should
    // invalidate the request_uri after some delay anyways, and 2) I am not sure
    // that the revocation endpoint is even supposed to support this (and I
    // don't want to spend the time checking now).
    // @TODO investigate actual necessity & feasibility of this feature
    }
    async callback(params) {
        const responseJwt = params.get('response');
        if (responseJwt != null) {
            // https://openid.net/specs/oauth-v2-jarm.html
            throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'JARM not supported');
        }
        const issuerParam = params.get('iss');
        const stateParam = params.get('state');
        const errorParam = params.get('error');
        const codeParam = params.get('code');
        if (!stateParam) {
            throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Missing "state" parameter');
        }
        const stateData = await this.stateStore.get(stateParam);
        if (stateData) {
            // Prevent any kind of replay
            await this.stateStore.del(stateParam);
        } else {
            throw new oauth_callback_error_js_1.OAuthCallbackError(params, `Unknown authorization session "${stateParam}"`);
        }
        try {
            if (errorParam != null) {
                throw new oauth_callback_error_js_1.OAuthCallbackError(params, undefined, stateData.appState);
            }
            if (!codeParam) {
                throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Missing "code" query param', stateData.appState);
            }
            const server = await this.serverFactory.fromIssuer(stateData.iss, stateData.dpopKey);
            if (issuerParam != null) {
                if (!server.issuer) {
                    throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Issuer not found in metadata', stateData.appState);
                }
                if (server.issuer !== issuerParam) {
                    throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Issuer mismatch', stateData.appState);
                }
            } else if (server.serverMetadata.authorization_response_iss_parameter_supported) {
                throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'iss missing from the response', stateData.appState);
            }
            const tokenSet = await server.exchangeCode(codeParam, stateData.verifier);
            try {
                await this.sessionGetter.setStored(tokenSet.sub, {
                    dpopKey: stateData.dpopKey,
                    tokenSet
                });
                const session = this.createSession(server, tokenSet.sub);
                return {
                    session,
                    state: stateData.appState ?? null
                };
            } catch (err) {
                await server.revoke(tokenSet.refresh_token || tokenSet.access_token);
                throw err;
            }
        } catch (err) {
            // Make sure, whatever the underlying error, that the appState is
            // available in the calling code
            throw oauth_callback_error_js_1.OAuthCallbackError.from(err, params, stateData.appState);
        }
    }
    /**
     * Load a stored session. This will refresh the token only if needed (about to
     * expire) by default.
     *
     * @param refresh See {@link SessionGetter.getSession}
     */ async restore(sub, refresh = 'auto') {
        // sub arg is lightly typed for convenience of library user
        (0, did_resolver_1.assertAtprotoDid)(sub);
        const { dpopKey, tokenSet } = await this.sessionGetter.get(sub, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
        const server = await this.serverFactory.fromIssuer(tokenSet.iss, dpopKey, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
        return this.createSession(server, sub);
    }
    async revoke(sub) {
        // sub arg is lightly typed for convenience of library user
        (0, did_resolver_1.assertAtprotoDid)(sub);
        const { dpopKey, tokenSet } = await this.sessionGetter.get(sub, {
            allowStale: true
        });
        // NOT using `;(await this.restore(sub, false)).signOut()` because we want
        // the tokens to be deleted even if it was not possible to fetch the issuer
        // data.
        try {
            const server = await this.serverFactory.fromIssuer(tokenSet.iss, dpopKey);
            await server.revoke(tokenSet.access_token);
        } finally{
            await this.sessionGetter.delStored(sub, new token_revoked_error_js_1.TokenRevokedError(sub));
        }
    }
    createSession(server, sub) {
        return new oauth_session_js_1.OAuthSession(server, sub, this.sessionGetter, this.fetch);
    }
}
exports.OAuthClient = OAuthClient; //# sourceMappingURL=oauth-client.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/runtime-implementation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=runtime-implementation.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/state-store.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=state-store.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchResponseError = exports.FetchRequestError = exports.FetchError = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/index.js [app-ssr] (ecmascript)"), exports);
var fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FetchError", {
    enumerable: true,
    get: function() {
        return fetch_1.FetchError;
    }
});
Object.defineProperty(exports, "FetchRequestError", {
    enumerable: true,
    get: function() {
        return fetch_1.FetchRequestError;
    }
});
Object.defineProperty(exports, "FetchResponseError", {
    enumerable: true,
    get: function() {
        return fetch_1.FetchResponseError;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-authorization-server-metadata-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-callback-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-client.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-protected-resource-metadata-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-agent.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-factory.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-session.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/runtime-implementation.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/session-getter.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/state-store.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleRequest = handleRequest;
exports.promisify = promisify;
function handleRequest(request, onSuccess, onError) {
    const cleanup = ()=>{
        request.removeEventListener('success', success);
        request.removeEventListener('error', error);
    };
    const success = ()=>{
        onSuccess(request.result);
        cleanup();
    };
    const error = ()=>{
        onError(request.error || new Error('Unknown error'));
        cleanup();
    };
    request.addEventListener('success', success);
    request.addEventListener('error', error);
}
function promisify(request) {
    return new Promise((resolve, reject)=>{
        handleRequest(request, resolve, reject);
    });
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DBIndex = void 0;
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/util.js [app-ssr] (ecmascript)");
class DBIndex {
    constructor(idbIndex){
        Object.defineProperty(this, "idbIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: idbIndex
        });
    }
    count(query) {
        return (0, util_js_1.promisify)(this.idbIndex.count(query));
    }
    get(query) {
        return (0, util_js_1.promisify)(this.idbIndex.get(query));
    }
    getKey(query) {
        return (0, util_js_1.promisify)(this.idbIndex.getKey(query));
    }
    getAll(query, count) {
        return (0, util_js_1.promisify)(this.idbIndex.getAll(query, count));
    }
    getAllKeys(query, count) {
        return (0, util_js_1.promisify)(this.idbIndex.getAllKeys(query, count));
    }
    deleteAll(query) {
        return new Promise((resolve, reject)=>{
            const result = this.idbIndex.openCursor(query);
            result.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    cursor.delete();
                    cursor.continue();
                } else {
                    resolve();
                }
            };
            result.onerror = function(event) {
                reject(event.target?.error || new Error('Unexpected error'));
            };
        });
    }
}
exports.DBIndex = DBIndex; //# sourceMappingURL=db-index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-object-store.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DBObjectStore = void 0;
const db_index_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/util.js [app-ssr] (ecmascript)");
class DBObjectStore {
    constructor(idbObjStore){
        Object.defineProperty(this, "idbObjStore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: idbObjStore
        });
    }
    get name() {
        return this.idbObjStore.name;
    }
    index(name) {
        return new db_index_js_1.DBIndex(this.idbObjStore.index(name));
    }
    get(key) {
        return (0, util_js_1.promisify)(this.idbObjStore.get(key));
    }
    getKey(query) {
        return (0, util_js_1.promisify)(this.idbObjStore.getKey(query));
    }
    getAll(query, count) {
        return (0, util_js_1.promisify)(this.idbObjStore.getAll(query, count));
    }
    getAllKeys(query, count) {
        return (0, util_js_1.promisify)(this.idbObjStore.getAllKeys(query, count));
    }
    add(value, key) {
        return (0, util_js_1.promisify)(this.idbObjStore.add(value, key));
    }
    put(value, key) {
        return (0, util_js_1.promisify)(this.idbObjStore.put(value, key));
    }
    delete(key) {
        return (0, util_js_1.promisify)(this.idbObjStore.delete(key));
    }
    clear() {
        return (0, util_js_1.promisify)(this.idbObjStore.clear());
    }
}
exports.DBObjectStore = DBObjectStore; //# sourceMappingURL=db-object-store.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-transaction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DBTransaction_tx;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DBTransaction = void 0;
const db_object_store_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-object-store.js [app-ssr] (ecmascript)");
class DBTransaction {
    constructor(tx){
        _DBTransaction_tx.set(this, void 0);
        __classPrivateFieldSet(this, _DBTransaction_tx, tx, "f");
        const onAbort = ()=>{
            cleanup();
        };
        const onComplete = ()=>{
            cleanup();
        };
        const cleanup = ()=>{
            __classPrivateFieldSet(this, _DBTransaction_tx, null, "f");
            tx.removeEventListener('abort', onAbort);
            tx.removeEventListener('complete', onComplete);
        };
        tx.addEventListener('abort', onAbort);
        tx.addEventListener('complete', onComplete);
    }
    get tx() {
        if (!__classPrivateFieldGet(this, _DBTransaction_tx, "f")) throw new Error('Transaction already ended');
        return __classPrivateFieldGet(this, _DBTransaction_tx, "f");
    }
    async abort() {
        const { tx } = this;
        __classPrivateFieldSet(this, _DBTransaction_tx, null, "f");
        tx.abort();
    }
    async commit() {
        const { tx } = this;
        __classPrivateFieldSet(this, _DBTransaction_tx, null, "f");
        tx.commit?.();
    }
    objectStore(name) {
        const store = this.tx.objectStore(name);
        return new db_object_store_js_1.DBObjectStore(store);
    }
    [(_DBTransaction_tx = new WeakMap(), Symbol.dispose)]() {
        if (__classPrivateFieldGet(this, _DBTransaction_tx, "f")) this.commit();
    }
}
exports.DBTransaction = DBTransaction; //# sourceMappingURL=db-transaction.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DB_db;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DB = void 0;
const db_transaction_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-transaction.js [app-ssr] (ecmascript)");
class DB {
    static async open(dbName, migrations, txOptions) {
        const db = await new Promise((resolve, reject)=>{
            const request = indexedDB.open(dbName, migrations.length);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
            request.onupgradeneeded = ({ oldVersion, newVersion })=>{
                const db = request.result;
                try {
                    for(let version = oldVersion; version < (newVersion ?? migrations.length); ++version){
                        const migration = migrations[version];
                        if (migration) migration(db);
                        else throw new Error(`Missing migration for version ${version}`);
                    }
                } catch (err) {
                    db.close();
                    reject(err);
                }
            };
        });
        return new DB(db, txOptions);
    }
    constructor(db, txOptions){
        Object.defineProperty(this, "txOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: txOptions
        });
        _DB_db.set(this, void 0);
        __classPrivateFieldSet(this, _DB_db, db, "f");
        const cleanup = ()=>{
            __classPrivateFieldSet(this, _DB_db, null, "f");
            db.removeEventListener('versionchange', cleanup);
            db.removeEventListener('close', cleanup);
            db.close(); // Can we call close on a "closed" database?
        };
        db.addEventListener('versionchange', cleanup);
        db.addEventListener('close', cleanup);
    }
    get db() {
        if (!__classPrivateFieldGet(this, _DB_db, "f")) throw new Error('Database closed');
        return __classPrivateFieldGet(this, _DB_db, "f");
    }
    get name() {
        return this.db.name;
    }
    get objectStoreNames() {
        return this.db.objectStoreNames;
    }
    get version() {
        return this.db.version;
    }
    async transaction(storeNames, mode, run) {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject)=>{
            try {
                const tx = this.db.transaction(storeNames, mode, this.txOptions);
                let result = {
                    done: false
                };
                tx.oncomplete = ()=>{
                    if (result.done) resolve(result.value);
                    else reject(new Error('Transaction completed without result'));
                };
                tx.onerror = ()=>reject(tx.error);
                tx.onabort = ()=>reject(tx.error || new Error('Transaction aborted'));
                try {
                    const value = await run(new db_transaction_js_1.DBTransaction(tx));
                    result = {
                        done: true,
                        value
                    };
                    tx.commit();
                } catch (err) {
                    tx.abort();
                    throw err;
                }
            } catch (err) {
                reject(err);
            }
        });
    }
    close() {
        const { db } = this;
        __classPrivateFieldSet(this, _DB_db, null, "f");
        db.close();
    }
    [(_DB_db = new WeakMap(), Symbol.dispose)]() {
        if (__classPrivateFieldGet(this, _DB_db, "f")) return this.close();
    }
}
exports.DB = DB; //# sourceMappingURL=db.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/disposable-polyfill/index.js [app-ssr] (ecmascript)");
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-object-store.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-transaction.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-database.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BrowserOAuthDatabase_dbPromise, _BrowserOAuthDatabase_cleanupInterval;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserOAuthDatabase = void 0;
const jwk_webcrypto_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)");
const index_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/index.js [app-ssr] (ecmascript)");
function encodeKey(key) {
    if (!(key instanceof jwk_webcrypto_1.WebcryptoKey) || !key.kid) {
        throw new Error('Invalid key object');
    }
    return {
        keyId: key.kid,
        keyPair: key.cryptoKeyPair
    };
}
async function decodeKey(encoded) {
    return jwk_webcrypto_1.WebcryptoKey.fromKeypair(encoded.keyPair, encoded.keyId);
}
const STORES = [
    'state',
    'session',
    'didCache',
    'dpopNonceCache',
    'handleCache',
    'authorizationServerMetadataCache',
    'protectedResourceMetadataCache'
];
class BrowserOAuthDatabase {
    constructor(options){
        _BrowserOAuthDatabase_dbPromise.set(this, void 0);
        _BrowserOAuthDatabase_cleanupInterval.set(this, void 0);
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_dbPromise, index_js_1.DB.open(options?.name ?? '@atproto-oauth-client', [
            (db)=>{
                for (const name of STORES){
                    const store = db.createObjectStore(name, {
                        autoIncrement: true
                    });
                    store.createIndex('expiresAt', 'expiresAt', {
                        unique: false
                    });
                }
            }
        ], {
            durability: options?.durability ?? 'strict'
        }), "f");
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_cleanupInterval, setInterval(()=>{
            void this.cleanup();
        }, options?.cleanupInterval ?? 30e3), "f");
    }
    async run(storeName, mode, fn) {
        const db = await __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f");
        return await db.transaction([
            storeName
        ], mode, (tx)=>fn(tx.objectStore(storeName)));
    }
    createStore(name, { encode, decode, expiresAt }) {
        return {
            get: async (key)=>{
                // Find item in store
                const item = await this.run(name, 'readonly', (store)=>store.get(key));
                // Not found
                if (item === undefined) return undefined;
                // Too old (delete)
                if (item.expiresAt != null && new Date(item.expiresAt) < new Date()) {
                    await this.run(name, 'readwrite', (store)=>store.delete(key));
                    return undefined;
                }
                // Item found and valid. Decode
                return decode(item.value);
            },
            set: async (key, value)=>{
                // Create encoded item record
                const item = {
                    value: await encode(value),
                    expiresAt: expiresAt(value)?.toISOString()
                };
                // Store item record
                await this.run(name, 'readwrite', (store)=>store.put(item, key));
            },
            del: async (key)=>{
                // Delete
                await this.run(name, 'readwrite', (store)=>store.delete(key));
            }
        };
    }
    getSessionStore() {
        return this.createStore('session', {
            expiresAt: ({ tokenSet })=>tokenSet.refresh_token || tokenSet.expires_at == null ? null : new Date(tokenSet.expires_at),
            encode: ({ dpopKey, ...session })=>({
                    ...session,
                    dpopKey: encodeKey(dpopKey)
                }),
            decode: async ({ dpopKey, ...encoded })=>({
                    ...encoded,
                    dpopKey: await decodeKey(dpopKey)
                })
        });
    }
    getStateStore() {
        return this.createStore('state', {
            expiresAt: (_value)=>new Date(Date.now() + 10 * 60e3),
            encode: ({ dpopKey, ...session })=>({
                    ...session,
                    dpopKey: encodeKey(dpopKey)
                }),
            decode: async ({ dpopKey, ...encoded })=>({
                    ...encoded,
                    dpopKey: await decodeKey(dpopKey)
                })
        });
    }
    getDpopNonceCache() {
        return this.createStore('dpopNonceCache', {
            expiresAt: (_value)=>new Date(Date.now() + 600e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getDidCache() {
        return this.createStore('didCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getHandleCache() {
        return this.createStore('handleCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getAuthorizationServerMetadataCache() {
        return this.createStore('authorizationServerMetadataCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getProtectedResourceMetadataCache() {
        return this.createStore('protectedResourceMetadataCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    async cleanup() {
        const db = await __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f");
        for (const name of STORES){
            await db.transaction([
                name
            ], 'readwrite', (tx)=>tx.objectStore(name).index('expiresAt').deleteAll(IDBKeyRange.upperBound(Date.now())));
        }
    }
    async [(_BrowserOAuthDatabase_dbPromise = new WeakMap(), _BrowserOAuthDatabase_cleanupInterval = new WeakMap(), Symbol.asyncDispose)]() {
        clearInterval(__classPrivateFieldGet(this, _BrowserOAuthDatabase_cleanupInterval, "f"));
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_cleanupInterval, undefined, "f");
        const dbPromise = __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f");
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_dbPromise, Promise.reject(new Error('Database has been disposed')), "f");
        // Avoid "unhandled promise rejection"
        __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f").catch(()=>null);
        // Spec recommends not to throw errors in dispose
        const db = await dbPromise.catch(()=>null);
        if (db) await (db[Symbol.asyncDispose] || db[Symbol.dispose]).call(db);
    }
}
exports.BrowserOAuthDatabase = BrowserOAuthDatabase; //# sourceMappingURL=browser-oauth-database.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/browser-runtime-implementation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserRuntimeImplementation = void 0;
const jwk_webcrypto_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)");
/**
 * @see {@link // https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request}
 */ const nativeRequestLock = navigator.locks?.request ? (name, fn)=>navigator.locks.request(name, {
        mode: 'exclusive'
    }, async ()=>fn()) : undefined;
class BrowserRuntimeImplementation {
    constructor(){
        Object.defineProperty(this, "requestLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: nativeRequestLock
        });
        if (typeof crypto !== 'object' || !crypto?.subtle) {
            throw new Error('Crypto with CryptoSubtle is required. If running in a browser, make sure the current page is loaded over HTTPS.');
        }
        if (!this.requestLock) {
            // There is no real need to polyfill this on older browsers. Indeed, the
            // oauth-client library will try and recover from concurrency issues when
            // refreshing tokens.
            console.warn('Locks API not available. You should consider using a more recent browser.');
        }
    }
    async createKey(algs) {
        return jwk_webcrypto_1.WebcryptoKey.generate(algs);
    }
    getRandomValues(byteLength) {
        return crypto.getRandomValues(new Uint8Array(byteLength));
    }
    async digest(data, { name }) {
        switch(name){
            case 'sha256':
            case 'sha384':
            case 'sha512':
                {
                    const buf = await crypto.subtle.digest(`SHA-${name.slice(3)}`, data);
                    return new Uint8Array(buf);
                }
            default:
                throw new Error(`Unsupported digest algorithm: ${name}`);
        }
    }
}
exports.BrowserRuntimeImplementation = BrowserRuntimeImplementation; //# sourceMappingURL=browser-runtime-implementation.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoginContinuedInParentWindowError = void 0;
/**
 * Special error class destined to be thrown when the login process was
 * performed in a popup and should be continued in the parent/initiating window.
 */ class LoginContinuedInParentWindowError extends Error {
    constructor(){
        super('Login complete, please close the popup window.');
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'LOGIN_CONTINUED_IN_PARENT_WINDOW'
        });
    }
}
exports.LoginContinuedInParentWindowError = LoginContinuedInParentWindowError; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildLoopbackClientId = buildLoopbackClientId;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
/**
 * @example
 * ```ts
 * const clientId = buildLoopbackClientId(window.location)
 * ```
 */ function buildLoopbackClientId(location, localhost = '127.0.0.1') {
    if (!(0, oauth_types_1.isLoopbackHost)(location.hostname)) {
        throw new TypeError(`Expected a loopback host, got ${location.hostname}`);
    }
    const redirectUri = `http://${location.hostname === 'localhost' ? localhost : location.hostname}${location.port && !location.port.startsWith(':') ? `:${location.port}` : location.port}${location.pathname}`;
    return `http://localhost${location.pathname === '/' ? '' : location.pathname}?redirect_uri=${encodeURIComponent(redirectUri)}`;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserOAuthClient = void 0;
const oauth_client_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const browser_oauth_database_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-database.js [app-ssr] (ecmascript)");
const browser_runtime_implementation_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/browser-runtime-implementation.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/errors.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/util.js [app-ssr] (ecmascript)");
const NAMESPACE = `@@atproto/oauth-client-browser`;
//- Popup channel
const POPUP_CHANNEL_NAME = `${NAMESPACE}(popup-channel)`;
const POPUP_STATE_PREFIX = `${NAMESPACE}(popup-state):`;
const syncChannel = new BroadcastChannel(`${NAMESPACE}(synchronization-channel)`);
class BrowserOAuthClient extends oauth_client_1.OAuthClient {
    static async load({ clientId, ...options }) {
        if (clientId.startsWith('http:')) {
            const clientMetadata = (0, oauth_types_1.atprotoLoopbackClientMetadata)(clientId);
            return new BrowserOAuthClient({
                clientMetadata,
                ...options
            });
        } else if (clientId.startsWith('https:')) {
            (0, oauth_types_1.assertOAuthDiscoverableClientId)(clientId);
            const clientMetadata = await oauth_client_1.OAuthClient.fetchMetadata({
                clientId,
                ...options
            });
            return new BrowserOAuthClient({
                clientMetadata,
                ...options
            });
        } else {
            throw new TypeError(`Invalid client id: ${clientId}`);
        }
    }
    constructor({ clientMetadata = (0, oauth_types_1.atprotoLoopbackClientMetadata)((0, util_js_1.buildLoopbackClientId)(window.location)), // "fragment" is a safer default as the query params will not be sent to the server
    responseMode = 'fragment', ...options }){
        if (!globalThis.crypto?.subtle) {
            throw new Error('WebCrypto API is required');
        }
        if (![
            'query',
            'fragment'
        ].includes(responseMode)) {
            // Make sure "form_post" is not used as it is not supported in the browser
            throw new TypeError(`Invalid response mode: ${responseMode}`);
        }
        const database = new browser_oauth_database_js_1.BrowserOAuthDatabase();
        super({
            ...options,
            clientMetadata,
            responseMode,
            keyset: undefined,
            runtimeImplementation: new browser_runtime_implementation_js_1.BrowserRuntimeImplementation(),
            sessionStore: database.getSessionStore(),
            stateStore: database.getStateStore(),
            didCache: database.getDidCache(),
            handleCache: database.getHandleCache(),
            dpopNonceCache: database.getDpopNonceCache(),
            authorizationServerMetadataCache: database.getAuthorizationServerMetadataCache(),
            protectedResourceMetadataCache: database.getProtectedResourceMetadataCache()
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // TODO: replace with AsyncDisposableStack once they are standardized
        const ac = new AbortController();
        const { signal } = ac;
        this[Symbol.dispose] = ()=>ac.abort();
        signal.addEventListener('abort', ()=>database[Symbol.asyncDispose](), {
            once: true
        });
        // Keep track of the current session
        this.addEventListener('deleted', ({ detail: { sub } })=>{
            if (localStorage.getItem(`${NAMESPACE}(sub)`) === sub) {
                localStorage.removeItem(`${NAMESPACE}(sub)`);
            }
        });
        // Session synchronization across tabs
        for (const type of [
            'deleted',
            'updated'
        ]){
            this.sessionGetter.addEventListener(type, ({ detail })=>{
                // Notify other tabs when a session is deleted or updated
                syncChannel.postMessage([
                    type,
                    detail
                ]);
            });
        }
        syncChannel.addEventListener('message', (event)=>{
            if (event.source !== window) {
                // Trigger listeners when an event is received from another tab
                const [type, detail] = event.data;
                this.dispatchCustomEvent(type, detail);
            }
        }, // Remove the listener when the client is disposed
        {
            signal
        });
    }
    async init(refresh) {
        await fixLocation(this.clientMetadata);
        const signInResult = await this.signInCallback();
        if (signInResult) {
            localStorage.setItem(`${NAMESPACE}(sub)`, signInResult.session.sub);
            return signInResult;
        }
        const sub = localStorage.getItem(`${NAMESPACE}(sub)`);
        if (sub) {
            try {
                const session = await this.restore(sub, refresh);
                return {
                    session
                };
            } catch (err) {
                localStorage.removeItem(`${NAMESPACE}(sub)`);
                throw err;
            }
        }
    }
    async restore(sub, refresh) {
        const session = await super.restore(sub, refresh);
        localStorage.setItem(`${NAMESPACE}(sub)`, session.sub);
        return session;
    }
    async revoke(sub) {
        localStorage.removeItem(`${NAMESPACE}(sub)`);
        return super.revoke(sub);
    }
    async signIn(input, options) {
        if (options?.display === 'popup') {
            return this.signInPopup(input, options);
        } else {
            return this.signInRedirect(input, options);
        }
    }
    async signInRedirect(input, options) {
        const url = await this.authorize(input, options);
        window.location.href = url.href;
        // back-forward cache
        return new Promise((resolve, reject)=>{
            setTimeout((err)=>{
                // Take the opportunity to proactively cancel the pending request
                this.abortRequest(url).then(()=>reject(err), (reason)=>reject(new AggregateError([
                        err,
                        reason
                    ])));
            }, 5e3, new Error('User navigated back'));
        });
    }
    async signInPopup(input, options) {
        // Open new window asap to prevent popup busting by browsers
        const popupFeatures = 'width=600,height=600,menubar=no,toolbar=no';
        let popup = window.open('about:blank', '_blank', popupFeatures);
        const stateKey = `${Math.random().toString(36).slice(2)}`;
        const url = await this.authorize(input, {
            ...options,
            state: `${POPUP_STATE_PREFIX}${stateKey}`,
            display: options?.display ?? 'popup'
        });
        options?.signal?.throwIfAborted();
        if (popup) {
            popup.window.location.href = url.href;
        } else {
            popup = window.open(url.href, '_blank', popupFeatures);
        }
        popup?.focus();
        return new Promise((resolve, reject)=>{
            const popupChannel = new BroadcastChannel(POPUP_CHANNEL_NAME);
            const cleanup = ()=>{
                clearTimeout(timeout);
                popupChannel.removeEventListener('message', onMessage);
                popupChannel.close();
                options?.signal?.removeEventListener('abort', cancel);
                popup?.close();
            };
            const cancel = ()=>{
                // @TODO: Store fact that the request was cancelled, allowing any
                // callback (e.g. in the popup) to revoke the session or credentials.
                reject(new Error(options?.signal?.aborted ? 'Aborted' : 'Timeout'));
                cleanup();
            };
            options?.signal?.addEventListener('abort', cancel);
            const timeout = setTimeout(cancel, 5 * 60e3);
            const onMessage = async ({ data })=>{
                if (data.key !== stateKey) return;
                if (!('result' in data)) return;
                // Send acknowledgment to popup window
                popupChannel.postMessage({
                    key: stateKey,
                    ack: true
                });
                cleanup();
                const { result } = data;
                if (result.status === 'fulfilled') {
                    const sub = result.value;
                    try {
                        options?.signal?.throwIfAborted();
                        resolve(await this.restore(sub, false));
                    } catch (err) {
                        reject(err);
                        void this.revoke(sub);
                    }
                } else {
                    const { message, params } = result.reason;
                    reject(new oauth_client_1.OAuthCallbackError(new URLSearchParams(params), message));
                }
            };
            popupChannel.addEventListener('message', onMessage);
        });
    }
    readCallbackParams() {
        const params = this.responseMode === 'fragment' ? new URLSearchParams(location.hash.slice(1)) : new URLSearchParams(location.search);
        // Only if the current URL contains a valid oauth response params
        if (!params.has('state') || !(params.has('code') || params.has('error'))) {
            return null;
        }
        const matchesLocation = (url)=>location.origin === url.origin && location.pathname === url.pathname;
        const redirectUrls = this.clientMetadata.redirect_uris.map((uri)=>new URL(uri));
        // Only if the current URL is one of the redirect_uris
        if (!redirectUrls.some(matchesLocation)) return null;
        return params;
    }
    async signInCallback() {
        const params = this.readCallbackParams();
        // Not a (valid) OAuth redirect
        if (!params) return null;
        // Replace the current history entry without the params (this will prevent
        // the following code to run again if the user refreshes the page)
        if (this.responseMode === 'fragment') {
            history.replaceState(null, '', location.pathname + location.search);
        } else if (this.responseMode === 'query') {
            history.replaceState(null, '', location.pathname);
        }
        // Utility function to send the result of the popup to the parent window
        const sendPopupResult = (message)=>{
            const popupChannel = new BroadcastChannel(POPUP_CHANNEL_NAME);
            return new Promise((resolve)=>{
                const cleanup = (result)=>{
                    clearTimeout(timer);
                    popupChannel.removeEventListener('message', onMessage);
                    popupChannel.close();
                    resolve(result);
                };
                const onMessage = ({ data })=>{
                    if ('ack' in data && message.key === data.key) cleanup(true);
                };
                popupChannel.addEventListener('message', onMessage);
                popupChannel.postMessage(message);
                // Receiving of "ack" should be very fast, giving it 500 ms anyway
                const timer = setTimeout(cleanup, 500, false);
            });
        };
        return this.callback(params).then(async (result)=>{
            if (result.state?.startsWith(POPUP_STATE_PREFIX)) {
                const receivedByParent = await sendPopupResult({
                    key: result.state.slice(POPUP_STATE_PREFIX.length),
                    result: {
                        status: 'fulfilled',
                        value: result.session.sub
                    }
                });
                // Revoke the credentials if the parent window was closed
                if (!receivedByParent) await result.session.signOut();
                throw new errors_js_1.LoginContinuedInParentWindowError(); // signInPopup
            }
            return result;
        }).catch(async (err)=>{
            if (err instanceof oauth_client_1.OAuthCallbackError && err.state?.startsWith(POPUP_STATE_PREFIX)) {
                await sendPopupResult({
                    key: err.state.slice(POPUP_STATE_PREFIX.length),
                    result: {
                        status: 'rejected',
                        reason: {
                            message: err.message,
                            params: Array.from(err.params.entries())
                        }
                    }
                });
                throw new errors_js_1.LoginContinuedInParentWindowError(); // signInPopup
            }
            // Most probable cause at this point is that the "state" parameter is
            // invalid.
            throw err;
        }).catch((err)=>{
            if (err instanceof errors_js_1.LoginContinuedInParentWindowError) {
                // parent will also try to close the popup
                window.close();
            }
            throw err;
        });
    }
    dispose() {
        this[Symbol.dispose]();
    }
}
exports.BrowserOAuthClient = BrowserOAuthClient;
_a = Symbol.dispose;
/**
 * Since "localhost" is often used either in IP mode or in hostname mode,
 * and because the redirect uris must use the IP mode, we need to make sure
 * that the current location url is not using "localhost".
 *
 * This is required for the IndexedDB to work properly. Indeed, the IndexedDB
 * is shared by origin, so we must ensure to be on the same origin as the
 * redirect uris.
 */ function fixLocation(clientMetadata) {
    if (!(0, oauth_types_1.isOAuthClientIdLoopback)(clientMetadata.client_id)) return;
    if (window.location.hostname !== 'localhost') return;
    const locationUrl = new URL(window.location.href);
    for (const uri of clientMetadata.redirect_uris){
        const url = new URL(uri);
        if ((url.hostname === '127.0.0.1' || url.hostname === '[::1]') && (!url.port || url.port === locationUrl.port) && url.protocol === locationUrl.protocol && url.pathname === locationUrl.pathname) {
            url.port = locationUrl.port;
            window.location.href = url.href;
            // Prevent init() on the wrong origin
            throw new Error('Redirecting to loopback IP...');
        }
    }
    throw new Error(`Please use the loopback IP address instead of ${locationUrl}`);
} //# sourceMappingURL=browser-oauth-client.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildLoopbackClientId = void 0;
__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/disposable-polyfill/index.js [app-ssr] (ecmascript)");
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-client.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/errors.js [app-ssr] (ecmascript)"), exports);
var util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/util.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "buildLoopbackClientId", {
    enumerable: true,
    get: function() {
        return util_js_1.buildLoopbackClientId;
    }
}); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_1b0dcf._.js.map