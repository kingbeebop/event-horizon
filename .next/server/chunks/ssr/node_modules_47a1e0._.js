module.exports = {

"[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            module.exports = __turbopack_require__("[externals]/next/dist/compiled/next-server/app-page.runtime.dev.js [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)");
        } else {
            "TURBOPACK unreachable";
        }
    }
} //# sourceMappingURL=module.compiled.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
module.exports = __turbopack_require__("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
module.exports = __turbopack_require__("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/handle.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DisallowedDomainError = exports.UnsupportedDomainError = exports.ReservedHandleError = exports.InvalidHandleError = exports.isValidTld = exports.isValidHandle = exports.normalizeAndEnsureValidHandle = exports.normalizeHandle = exports.ensureValidHandleRegex = exports.ensureValidHandle = exports.DISALLOWED_TLDS = exports.INVALID_HANDLE = void 0;
exports.INVALID_HANDLE = 'handle.invalid';
// Currently these are registration-time restrictions, not protocol-level
// restrictions. We have a couple accounts in the wild that we need to clean up
// before hard-disallow.
// See also: https://en.wikipedia.org/wiki/Top-level_domain#Reserved_domains
exports.DISALLOWED_TLDS = [
    '.local',
    '.arpa',
    '.invalid',
    '.localhost',
    '.internal',
    '.example',
    '.alt',
    // policy could concievably change on ".onion" some day
    '.onion'
];
// Handle constraints, in English:
//  - must be a possible domain name
//    - RFC-1035 is commonly referenced, but has been updated. eg, RFC-3696,
//      section 2. and RFC-3986, section 3. can now have leading numbers (eg,
//      4chan.org)
//    - "labels" (sub-names) are made of ASCII letters, digits, hyphens
//    - can not start or end with a hyphen
//    - TLD (last component) should not start with a digit
//    - can't end with a hyphen (can end with digit)
//    - each segment must be between 1 and 63 characters (not including any periods)
//    - overall length can't be more than 253 characters
//    - separated by (ASCII) periods; does not start or end with period
//    - case insensitive
//    - domains (handles) are equal if they are the same lower-case
//    - punycode allowed for internationalization
//  - no whitespace, null bytes, joining chars, etc
//  - does not validate whether domain or TLD exists, or is a reserved or
//    special TLD (eg, .onion or .local)
//  - does not validate punycode
const ensureValidHandle = (handle)=>{
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9.-]*$/.test(handle)) {
        throw new InvalidHandleError('Disallowed characters in handle (ASCII letters, digits, dashes, periods only)');
    }
    if (handle.length > 253) {
        throw new InvalidHandleError('Handle is too long (253 chars max)');
    }
    const labels = handle.split('.');
    if (labels.length < 2) {
        throw new InvalidHandleError('Handle domain needs at least two parts');
    }
    for(let i = 0; i < labels.length; i++){
        const l = labels[i];
        if (l.length < 1) {
            throw new InvalidHandleError('Handle parts can not be empty');
        }
        if (l.length > 63) {
            throw new InvalidHandleError('Handle part too long (max 63 chars)');
        }
        if (l.endsWith('-') || l.startsWith('-')) {
            throw new InvalidHandleError('Handle parts can not start or end with hyphens');
        }
        if (i + 1 === labels.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError('Handle final component (TLD) must start with ASCII letter');
        }
    }
};
exports.ensureValidHandle = ensureValidHandle;
// simple regex translation of above constraints
const ensureValidHandleRegex = (handle)=>{
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(handle)) {
        throw new InvalidHandleError("Handle didn't validate via regex");
    }
    if (handle.length > 253) {
        throw new InvalidHandleError('Handle is too long (253 chars max)');
    }
};
exports.ensureValidHandleRegex = ensureValidHandleRegex;
const normalizeHandle = (handle)=>{
    return handle.toLowerCase();
};
exports.normalizeHandle = normalizeHandle;
const normalizeAndEnsureValidHandle = (handle)=>{
    const normalized = (0, exports.normalizeHandle)(handle);
    (0, exports.ensureValidHandle)(normalized);
    return normalized;
};
exports.normalizeAndEnsureValidHandle = normalizeAndEnsureValidHandle;
const isValidHandle = (handle)=>{
    try {
        (0, exports.ensureValidHandle)(handle);
    } catch (err) {
        if (err instanceof InvalidHandleError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidHandle = isValidHandle;
const isValidTld = (handle)=>{
    return !exports.DISALLOWED_TLDS.some((domain)=>handle.endsWith(domain));
};
exports.isValidTld = isValidTld;
class InvalidHandleError extends Error {
}
exports.InvalidHandleError = InvalidHandleError;
class ReservedHandleError extends Error {
}
exports.ReservedHandleError = ReservedHandleError;
class UnsupportedDomainError extends Error {
}
exports.UnsupportedDomainError = UnsupportedDomainError;
class DisallowedDomainError extends Error {
}
exports.DisallowedDomainError = DisallowedDomainError; //# sourceMappingURL=handle.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/did.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDidError = exports.ensureValidDidRegex = exports.ensureValidDid = void 0;
// Human-readable constraints:
//   - valid W3C DID (https://www.w3.org/TR/did-core/#did-syntax)
//      - entire URI is ASCII: [a-zA-Z0-9._:%-]
//      - always starts "did:" (lower-case)
//      - method name is one or more lower-case letters, followed by ":"
//      - remaining identifier can have any of the above chars, but can not end in ":"
//      - it seems that a bunch of ":" can be included, and don't need spaces between
//      - "%" is used only for "percent encoding" and must be followed by two hex characters (and thus can't end in "%")
//      - query ("?") and fragment ("#") stuff is defined for "DID URIs", but not as part of identifier itself
//      - "The current specification does not take a position on the maximum length of a DID"
//   - in current atproto, only allowing did:plc and did:web. But not *forcing* this at lexicon layer
//   - hard length limit of 8KBytes
//   - not going to validate "percent encoding" here
const ensureValidDid = (did)=>{
    if (!did.startsWith('did:')) {
        throw new InvalidDidError('DID requires "did:" prefix');
    }
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9._:%-]*$/.test(did)) {
        throw new InvalidDidError('Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)');
    }
    const { length, 1: method } = did.split(':');
    if (length < 3) {
        throw new InvalidDidError('DID requires prefix, method, and method-specific content');
    }
    if (!/^[a-z]+$/.test(method)) {
        throw new InvalidDidError('DID method must be lower-case letters');
    }
    if (did.endsWith(':') || did.endsWith('%')) {
        throw new InvalidDidError('DID can not end with ":" or "%"');
    }
    if (did.length > 2 * 1024) {
        throw new InvalidDidError('DID is too long (2048 chars max)');
    }
};
exports.ensureValidDid = ensureValidDid;
const ensureValidDidRegex = (did)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints
    if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(did)) {
        throw new InvalidDidError("DID didn't validate via regex");
    }
    if (did.length > 2 * 1024) {
        throw new InvalidDidError('DID is too long (2048 chars max)');
    }
};
exports.ensureValidDidRegex = ensureValidDidRegex;
class InvalidDidError extends Error {
}
exports.InvalidDidError = InvalidDidError; //# sourceMappingURL=did.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/nsid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
/*
Grammar:

alpha     = "a" / "b" / "c" / "d" / "e" / "f" / "g" / "h" / "i" / "j" / "k" / "l" / "m" / "n" / "o" / "p" / "q" / "r" / "s" / "t" / "u" / "v" / "w" / "x" / "y" / "z" / "A" / "B" / "C" / "D" / "E" / "F" / "G" / "H" / "I" / "J" / "K" / "L" / "M" / "N" / "O" / "P" / "Q" / "R" / "S" / "T" / "U" / "V" / "W" / "X" / "Y" / "Z"
number    = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" / "0"
delim     = "."
segment   = alpha *( alpha / number / "-" )
authority = segment *( delim segment )
name      = alpha *( alpha )
nsid      = authority delim name

*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidNsidError = exports.ensureValidNsidRegex = exports.ensureValidNsid = exports.NSID = void 0;
class NSID {
    static parse(nsid) {
        return new NSID(nsid);
    }
    static create(authority, name) {
        const segments = [
            ...authority.split('.').reverse(),
            name
        ].join('.');
        return new NSID(segments);
    }
    static isValid(nsid) {
        try {
            NSID.parse(nsid);
            return true;
        } catch (e) {
            return false;
        }
    }
    constructor(nsid){
        Object.defineProperty(this, "segments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        (0, exports.ensureValidNsid)(nsid);
        this.segments = nsid.split('.');
    }
    get authority() {
        return this.segments.slice(0, this.segments.length - 1).reverse().join('.');
    }
    get name() {
        return this.segments.at(this.segments.length - 1);
    }
    toString() {
        return this.segments.join('.');
    }
}
exports.NSID = NSID;
// Human readable constraints on NSID:
// - a valid domain in reversed notation
// - followed by an additional period-separated name, which is camel-case letters
const ensureValidNsid = (nsid)=>{
    const toCheck = nsid;
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
        throw new InvalidNsidError('Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)');
    }
    if (toCheck.length > 253 + 1 + 63) {
        throw new InvalidNsidError('NSID is too long (317 chars max)');
    }
    const labels = toCheck.split('.');
    if (labels.length < 3) {
        throw new InvalidNsidError('NSID needs at least three parts');
    }
    for(let i = 0; i < labels.length; i++){
        const l = labels[i];
        if (l.length < 1) {
            throw new InvalidNsidError('NSID parts can not be empty');
        }
        if (l.length > 63) {
            throw new InvalidNsidError('NSID part too long (max 63 chars)');
        }
        if (l.endsWith('-') || l.startsWith('-')) {
            throw new InvalidNsidError('NSID parts can not start or end with hyphen');
        }
        if (/^[0-9]/.test(l) && i === 0) {
            throw new InvalidNsidError('NSID first part may not start with a digit');
        }
        if (!/^[a-zA-Z]+$/.test(l) && i + 1 === labels.length) {
            throw new InvalidNsidError('NSID name part must be only letters');
        }
    }
};
exports.ensureValidNsid = ensureValidNsid;
const ensureValidNsidRegex = (nsid)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(nsid)) {
        throw new InvalidNsidError("NSID didn't validate via regex");
    }
    if (nsid.length > 253 + 1 + 63) {
        throw new InvalidNsidError('NSID is too long (317 chars max)');
    }
};
exports.ensureValidNsidRegex = ensureValidNsidRegex;
class InvalidNsidError extends Error {
}
exports.InvalidNsidError = InvalidNsidError; //# sourceMappingURL=nsid.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/aturi_validation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ensureValidAtUriRegex = exports.ensureValidAtUri = void 0;
const handle_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/handle.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/did.js [app-ssr] (ecmascript)");
const nsid_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/nsid.js [app-ssr] (ecmascript)");
// Human-readable constraints on ATURI:
//   - following regular URLs, a 8KByte hard total length limit
//   - follows ATURI docs on website
//      - all ASCII characters, no whitespace. non-ASCII could be URL-encoded
//      - starts "at://"
//      - "authority" is a valid DID or a valid handle
//      - optionally, follow "authority" with "/" and valid NSID as start of path
//      - optionally, if NSID given, follow that with "/" and rkey
//      - rkey path component can include URL-encoded ("percent encoded"), or:
//          ALPHA / DIGIT / "-" / "." / "_" / "~" / ":" / "@" / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
//          [a-zA-Z0-9._~:@!$&'\(\)*+,;=-]
//      - rkey must have at least one char
//      - regardless of path component, a fragment can follow  as "#" and then a JSON pointer (RFC-6901)
const ensureValidAtUri = (uri)=>{
    // JSON pointer is pretty different from rest of URI, so split that out first
    const uriParts = uri.split('#');
    if (uriParts.length > 2) {
        throw new Error('ATURI can have at most one "#", separating fragment out');
    }
    const fragmentPart = uriParts[1] || null;
    uri = uriParts[0];
    // check that all chars are boring ASCII
    if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {
        throw new Error('Disallowed characters in ATURI (ASCII)');
    }
    const parts = uri.split('/');
    if (parts.length >= 3 && (parts[0] !== 'at:' || parts[1].length !== 0)) {
        throw new Error('ATURI must start with "at://"');
    }
    if (parts.length < 3) {
        throw new Error('ATURI requires at least method and authority sections');
    }
    try {
        if (parts[2].startsWith('did:')) {
            (0, did_1.ensureValidDid)(parts[2]);
        } else {
            (0, handle_1.ensureValidHandle)(parts[2]);
        }
    } catch  {
        throw new Error('ATURI authority must be a valid handle or DID');
    }
    if (parts.length >= 4) {
        if (parts[3].length === 0) {
            throw new Error('ATURI can not have a slash after authority without a path segment');
        }
        try {
            (0, nsid_1.ensureValidNsid)(parts[3]);
        } catch  {
            throw new Error('ATURI requires first path segment (if supplied) to be valid NSID');
        }
    }
    if (parts.length >= 5) {
        if (parts[4].length === 0) {
            throw new Error('ATURI can not have a slash after collection, unless record key is provided');
        }
    // would validate rkey here, but there are basically no constraints!
    }
    if (parts.length >= 6) {
        throw new Error('ATURI path can have at most two parts, and no trailing slash');
    }
    if (uriParts.length >= 2 && fragmentPart == null) {
        throw new Error('ATURI fragment must be non-empty and start with slash');
    }
    if (fragmentPart != null) {
        if (fragmentPart.length === 0 || fragmentPart[0] !== '/') {
            throw new Error('ATURI fragment must be non-empty and start with slash');
        }
        // NOTE: enforcing *some* checks here for sanity. Eg, at least no whitespace
        if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
            throw new Error('Disallowed characters in ATURI fragment (ASCII)');
        }
    }
    if (uri.length > 8 * 1024) {
        throw new Error('ATURI is far too long');
    }
};
exports.ensureValidAtUri = ensureValidAtUri;
const ensureValidAtUriRegex = (uri)=>{
    // simple regex to enforce most constraints via just regex and length.
    // hand wrote this regex based on above constraints. whew!
    const aturiRegex = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/;
    const rm = uri.match(aturiRegex);
    if (!rm || !rm.groups) {
        throw new Error("ATURI didn't validate via regex");
    }
    const groups = rm.groups;
    try {
        (0, handle_1.ensureValidHandleRegex)(groups.authority);
    } catch  {
        try {
            (0, did_1.ensureValidDidRegex)(groups.authority);
        } catch  {
            throw new Error('ATURI authority must be a valid handle or DID');
        }
    }
    if (groups.collection) {
        try {
            (0, nsid_1.ensureValidNsidRegex)(groups.collection);
        } catch  {
            throw new Error('ATURI collection path segment must be a valid NSID');
        }
    }
    if (uri.length > 8 * 1024) {
        throw new Error('ATURI is far too long');
    }
};
exports.ensureValidAtUriRegex = ensureValidAtUriRegex; //# sourceMappingURL=aturi_validation.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/aturi.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtUri = exports.ATP_URI_REGEX = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/aturi_validation.js [app-ssr] (ecmascript)"), exports);
exports.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
/^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
//                       --path-----   --query--  --hash--
const RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
class AtUri {
    constructor(uri, base){
        Object.defineProperty(this, "hash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "host", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pathname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let parsed;
        if (base) {
            parsed = parse(base);
            if (!parsed) {
                throw new Error(`Invalid at uri: ${base}`);
            }
            const relativep = parseRelative(uri);
            if (!relativep) {
                throw new Error(`Invalid path: ${uri}`);
            }
            Object.assign(parsed, relativep);
        } else {
            parsed = parse(uri);
            if (!parsed) {
                throw new Error(`Invalid at uri: ${uri}`);
            }
        }
        this.hash = parsed.hash;
        this.host = parsed.host;
        this.pathname = parsed.pathname;
        this.searchParams = parsed.searchParams;
    }
    static make(handleOrDid, collection, rkey) {
        let str = handleOrDid;
        if (collection) str += '/' + collection;
        if (rkey) str += '/' + rkey;
        return new AtUri(str);
    }
    get protocol() {
        return 'at:';
    }
    get origin() {
        return `at://${this.host}`;
    }
    get hostname() {
        return this.host;
    }
    set hostname(v) {
        this.host = v;
    }
    get search() {
        return this.searchParams.toString();
    }
    set search(v) {
        this.searchParams = new URLSearchParams(v);
    }
    get collection() {
        return this.pathname.split('/').filter(Boolean)[0] || '';
    }
    set collection(v) {
        const parts = this.pathname.split('/').filter(Boolean);
        parts[0] = v;
        this.pathname = parts.join('/');
    }
    get rkey() {
        return this.pathname.split('/').filter(Boolean)[1] || '';
    }
    set rkey(v) {
        const parts = this.pathname.split('/').filter(Boolean);
        if (!parts[0]) parts[0] = 'undefined';
        parts[1] = v;
        this.pathname = parts.join('/');
    }
    get href() {
        return this.toString();
    }
    toString() {
        let path = this.pathname || '/';
        if (!path.startsWith('/')) {
            path = `/${path}`;
        }
        let qs = this.searchParams.toString();
        if (qs && !qs.startsWith('?')) {
            qs = `?${qs}`;
        }
        let hash = this.hash;
        if (hash && !hash.startsWith('#')) {
            hash = `#${hash}`;
        }
        return `at://${this.host}${path}${qs}${hash}`;
    }
}
exports.AtUri = AtUri;
function parse(str) {
    const match = exports.ATP_URI_REGEX.exec(str);
    if (match) {
        return {
            hash: match[5] || '',
            host: match[2] || '',
            pathname: match[3] || '',
            searchParams: new URLSearchParams(match[4] || '')
        };
    }
    return undefined;
}
function parseRelative(str) {
    const match = RELATIVE_REGEX.exec(str);
    if (match) {
        return {
            hash: match[3] || '',
            pathname: match[1] || '',
            searchParams: new URLSearchParams(match[2] || '')
        };
    }
    return undefined;
} //# sourceMappingURL=aturi.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/tid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidTidError = exports.isValidTid = exports.ensureValidTid = void 0;
const ensureValidTid = (tid)=>{
    if (tid.length !== 13) {
        throw new InvalidTidError('TID must be 13 characters');
    }
    // simple regex to enforce most constraints via just regex and length.
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(tid)) {
        throw new InvalidTidError('TID syntax not valid (regex)');
    }
};
exports.ensureValidTid = ensureValidTid;
const isValidTid = (tid)=>{
    try {
        (0, exports.ensureValidTid)(tid);
    } catch (err) {
        if (err instanceof InvalidTidError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidTid = isValidTid;
class InvalidTidError extends Error {
}
exports.InvalidTidError = InvalidTidError; //# sourceMappingURL=tid.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/recordkey.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidRecordKeyError = exports.isValidRecordKey = exports.ensureValidRecordKey = void 0;
const ensureValidRecordKey = (rkey)=>{
    if (rkey.length > 512 || rkey.length < 1) {
        throw new InvalidRecordKeyError('record key must be 1 to 512 characters');
    }
    // simple regex to enforce most constraints via just regex and length.
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(rkey)) {
        throw new InvalidRecordKeyError('record key syntax not valid (regex)');
    }
    if (rkey === '.' || rkey === '..') throw new InvalidRecordKeyError('record key can not be "." or ".."');
};
exports.ensureValidRecordKey = ensureValidRecordKey;
const isValidRecordKey = (rkey)=>{
    try {
        (0, exports.ensureValidRecordKey)(rkey);
    } catch (err) {
        if (err instanceof InvalidRecordKeyError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidRecordKey = isValidRecordKey;
class InvalidRecordKeyError extends Error {
}
exports.InvalidRecordKeyError = InvalidRecordKeyError; //# sourceMappingURL=recordkey.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/datetime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDatetimeError = exports.normalizeDatetimeAlways = exports.normalizeDatetime = exports.isValidDatetime = exports.ensureValidDatetime = void 0;
/* Validates datetime string against atproto Lexicon 'datetime' format.
 * Syntax is described at: https://atproto.com/specs/lexicon#datetime
 */ const ensureValidDatetime = (dtStr)=>{
    const date = new Date(dtStr);
    // must parse as ISO 8601; this also verifies semantics like month is not 13 or 00
    if (isNaN(date.getTime())) {
        throw new InvalidDatetimeError('datetime did not parse as ISO 8601');
    }
    if (date.toISOString().startsWith('-')) {
        throw new InvalidDatetimeError('datetime normalized to a negative time');
    }
    // regex and other checks for RFC-3339
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(dtStr)) {
        throw new InvalidDatetimeError("datetime didn't validate via regex");
    }
    if (dtStr.length > 64) {
        throw new InvalidDatetimeError('datetime is too long (64 chars max)');
    }
    if (dtStr.endsWith('-00:00')) {
        throw new InvalidDatetimeError('datetime can not use "-00:00" for UTC timezone');
    }
    if (dtStr.startsWith('000')) {
        throw new InvalidDatetimeError('datetime so close to year zero not allowed');
    }
};
exports.ensureValidDatetime = ensureValidDatetime;
/* Same logic as ensureValidDatetime(), but returns a boolean instead of throwing an exception.
 */ const isValidDatetime = (dtStr)=>{
    try {
        (0, exports.ensureValidDatetime)(dtStr);
    } catch (err) {
        if (err instanceof InvalidDatetimeError) {
            return false;
        }
        throw err;
    }
    return true;
};
exports.isValidDatetime = isValidDatetime;
/* Takes a flexible datetime string and normalizes representation.
 *
 * This function will work with any valid atproto datetime (eg, anything which isValidDatetime() is true for). It *additionally* is more flexible about accepting datetimes that don't comply to RFC 3339, or are missing timezone information, and normalizing them to a valid datetime.
 *
 * One use-case is a consistent, sortable string. Another is to work with older invalid createdAt datetimes.
 *
 * Successful output will be a valid atproto datetime with millisecond precision (3 sub-second digits) and UTC timezone with trailing 'Z' syntax. Throws `InvalidDatetimeError` if the input string could not be parsed as a datetime, even with permissive parsing.
 *
 * Expected output format: YYYY-MM-DDTHH:mm:ss.sssZ
 */ const normalizeDatetime = (dtStr)=>{
    if ((0, exports.isValidDatetime)(dtStr)) {
        const outStr = new Date(dtStr).toISOString();
        if ((0, exports.isValidDatetime)(outStr)) {
            return outStr;
        }
    }
    // check if this permissive datetime is missing a timezone
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(dtStr)) {
        const date = new Date(dtStr + 'Z');
        if (!isNaN(date.getTime())) {
            const tzStr = date.toISOString();
            if ((0, exports.isValidDatetime)(tzStr)) {
                return tzStr;
            }
        }
    }
    // finally try parsing as simple datetime
    const date = new Date(dtStr);
    if (isNaN(date.getTime())) {
        throw new InvalidDatetimeError('datetime did not parse as any timestamp format');
    }
    const isoStr = date.toISOString();
    if ((0, exports.isValidDatetime)(isoStr)) {
        return isoStr;
    } else {
        throw new InvalidDatetimeError('datetime normalized to invalid timestamp string');
    }
};
exports.normalizeDatetime = normalizeDatetime;
/* Variant of normalizeDatetime() which always returns a valid datetime strings.
 *
 * If a InvalidDatetimeError is encountered, returns the UNIX epoch time as a UTC datetime (1970-01-01T00:00:00.000Z).
 */ const normalizeDatetimeAlways = (dtStr)=>{
    try {
        return (0, exports.normalizeDatetime)(dtStr);
    } catch (err) {
        if (err instanceof InvalidDatetimeError) {
            return new Date(0).toISOString();
        }
        throw err;
    }
};
exports.normalizeDatetimeAlways = normalizeDatetimeAlways;
/* Indicates a datetime string did not pass full atproto Lexicon datetime string format checks.
 */ class InvalidDatetimeError extends Error {
}
exports.InvalidDatetimeError = InvalidDatetimeError; //# sourceMappingURL=datetime.js.map
}}),
"[project]/node_modules/@atproto/syntax/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/handle.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/did.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/nsid.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/aturi.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/tid.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/recordkey.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/syntax/dist/datetime.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toLexUri = toLexUri;
exports.toConcreteTypes = toConcreteTypes;
exports.requiredPropertiesRefinement = requiredPropertiesRefinement;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
function toLexUri(str, baseUri) {
    if (str.split('#').length > 2) {
        throw new Error('Uri can only have one hash segment');
    }
    if (str.startsWith('lex:')) {
        return str;
    }
    if (str.startsWith('#')) {
        if (!baseUri) {
            throw new Error(`Unable to resolve uri without anchor: ${str}`);
        }
        return `${baseUri}${str}`;
    }
    return `lex:${str}`;
}
function toConcreteTypes(lexicons, def) {
    if (def.type === 'ref') {
        return [
            lexicons.getDefOrThrow(def.ref)
        ];
    } else if (def.type === 'union') {
        return def.refs.map((ref)=>lexicons.getDefOrThrow(ref)).flat();
    } else {
        return [
            def
        ];
    }
}
function requiredPropertiesRefinement(object, ctx) {
    // Required fields check
    if (object.required === undefined) {
        return;
    }
    if (!Array.isArray(object.required)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.invalid_type,
            received: typeof object.required,
            expected: 'array'
        });
        return;
    }
    if (object.properties === undefined) {
        if (object.required.length > 0) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: `Required fields defined but no properties defined`
            });
        }
        return;
    }
    for (const field of object.required){
        if (object.properties[field] === undefined) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: `Required field "${field}" not defined`
            });
        }
    }
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LexiconDefNotFoundError = exports.InvalidLexiconError = exports.ValidationError = exports.discriminatedObject = exports.lexiconDoc = exports.lexUserType = exports.lexRecord = exports.lexXrpcSubscription = exports.lexXrpcProcedure = exports.lexXrpcQuery = exports.lexXrpcError = exports.lexXrpcSubscriptionMessage = exports.lexXrpcBody = exports.lexXrpcParameters = exports.lexObject = exports.lexToken = exports.lexPrimitiveArray = exports.lexArray = exports.lexBlob = exports.lexRefVariant = exports.lexRefUnion = exports.lexRef = exports.lexIpldType = exports.lexCidLink = exports.lexBytes = exports.lexPrimitive = exports.lexUnknown = exports.lexString = exports.lexStringFormat = exports.lexInteger = exports.lexBoolean = void 0;
exports.isValidLexiconDoc = isValidLexiconDoc;
exports.isObj = isObj;
exports.hasProp = hasProp;
exports.isDiscriminatedObject = isDiscriminatedObject;
exports.parseLexiconDoc = parseLexiconDoc;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const syntax_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/index.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/util.js [app-ssr] (ecmascript)");
// primitives
// =
exports.lexBoolean = zod_1.z.object({
    type: zod_1.z.literal('boolean'),
    description: zod_1.z.string().optional(),
    default: zod_1.z.boolean().optional(),
    const: zod_1.z.boolean().optional()
}).strict();
exports.lexInteger = zod_1.z.object({
    type: zod_1.z.literal('integer'),
    description: zod_1.z.string().optional(),
    default: zod_1.z.number().int().optional(),
    minimum: zod_1.z.number().int().optional(),
    maximum: zod_1.z.number().int().optional(),
    enum: zod_1.z.number().int().array().optional(),
    const: zod_1.z.number().int().optional()
}).strict();
exports.lexStringFormat = zod_1.z.enum([
    'datetime',
    'uri',
    'at-uri',
    'did',
    'handle',
    'at-identifier',
    'nsid',
    'cid',
    'language',
    'tid',
    'record-key'
]);
exports.lexString = zod_1.z.object({
    type: zod_1.z.literal('string'),
    format: exports.lexStringFormat.optional(),
    description: zod_1.z.string().optional(),
    default: zod_1.z.string().optional(),
    minLength: zod_1.z.number().int().optional(),
    maxLength: zod_1.z.number().int().optional(),
    minGraphemes: zod_1.z.number().int().optional(),
    maxGraphemes: zod_1.z.number().int().optional(),
    enum: zod_1.z.string().array().optional(),
    const: zod_1.z.string().optional(),
    knownValues: zod_1.z.string().array().optional()
}).strict();
exports.lexUnknown = zod_1.z.object({
    type: zod_1.z.literal('unknown'),
    description: zod_1.z.string().optional()
}).strict();
exports.lexPrimitive = zod_1.z.discriminatedUnion('type', [
    exports.lexBoolean,
    exports.lexInteger,
    exports.lexString,
    exports.lexUnknown
]);
// ipld types
// =
exports.lexBytes = zod_1.z.object({
    type: zod_1.z.literal('bytes'),
    description: zod_1.z.string().optional(),
    maxLength: zod_1.z.number().optional(),
    minLength: zod_1.z.number().optional()
}).strict();
exports.lexCidLink = zod_1.z.object({
    type: zod_1.z.literal('cid-link'),
    description: zod_1.z.string().optional()
}).strict();
exports.lexIpldType = zod_1.z.discriminatedUnion('type', [
    exports.lexBytes,
    exports.lexCidLink
]);
// references
// =
exports.lexRef = zod_1.z.object({
    type: zod_1.z.literal('ref'),
    description: zod_1.z.string().optional(),
    ref: zod_1.z.string()
}).strict();
exports.lexRefUnion = zod_1.z.object({
    type: zod_1.z.literal('union'),
    description: zod_1.z.string().optional(),
    refs: zod_1.z.string().array(),
    closed: zod_1.z.boolean().optional()
}).strict();
exports.lexRefVariant = zod_1.z.discriminatedUnion('type', [
    exports.lexRef,
    exports.lexRefUnion
]);
// blobs
// =
exports.lexBlob = zod_1.z.object({
    type: zod_1.z.literal('blob'),
    description: zod_1.z.string().optional(),
    accept: zod_1.z.string().array().optional(),
    maxSize: zod_1.z.number().optional()
}).strict();
// complex types
// =
exports.lexArray = zod_1.z.object({
    type: zod_1.z.literal('array'),
    description: zod_1.z.string().optional(),
    items: zod_1.z.discriminatedUnion('type', [
        // lexPrimitive
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown,
        // lexIpldType
        exports.lexBytes,
        exports.lexCidLink,
        // lexRefVariant
        exports.lexRef,
        exports.lexRefUnion,
        // other
        exports.lexBlob
    ]),
    minLength: zod_1.z.number().int().optional(),
    maxLength: zod_1.z.number().int().optional()
}).strict();
exports.lexPrimitiveArray = exports.lexArray.merge(zod_1.z.object({
    items: exports.lexPrimitive
}).strict());
exports.lexToken = zod_1.z.object({
    type: zod_1.z.literal('token'),
    description: zod_1.z.string().optional()
}).strict();
exports.lexObject = zod_1.z.object({
    type: zod_1.z.literal('object'),
    description: zod_1.z.string().optional(),
    required: zod_1.z.string().array().optional(),
    nullable: zod_1.z.string().array().optional(),
    properties: zod_1.z.record(zod_1.z.discriminatedUnion('type', [
        exports.lexArray,
        // lexPrimitive
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown,
        // lexIpldType
        exports.lexBytes,
        exports.lexCidLink,
        // lexRefVariant
        exports.lexRef,
        exports.lexRefUnion,
        // other
        exports.lexBlob
    ]))
}).strict().superRefine(util_1.requiredPropertiesRefinement);
// xrpc
// =
exports.lexXrpcParameters = zod_1.z.object({
    type: zod_1.z.literal('params'),
    description: zod_1.z.string().optional(),
    required: zod_1.z.string().array().optional(),
    properties: zod_1.z.record(zod_1.z.discriminatedUnion('type', [
        exports.lexPrimitiveArray,
        // lexPrimitive
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown
    ]))
}).strict().superRefine(util_1.requiredPropertiesRefinement);
exports.lexXrpcBody = zod_1.z.object({
    description: zod_1.z.string().optional(),
    encoding: zod_1.z.string(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: zod_1.z.union([
        exports.lexRefVariant,
        exports.lexObject
    ]).optional()
}).strict();
exports.lexXrpcSubscriptionMessage = zod_1.z.object({
    description: zod_1.z.string().optional(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: zod_1.z.union([
        exports.lexRefVariant,
        exports.lexObject
    ]).optional()
}).strict();
exports.lexXrpcError = zod_1.z.object({
    name: zod_1.z.string(),
    description: zod_1.z.string().optional()
}).strict();
exports.lexXrpcQuery = zod_1.z.object({
    type: zod_1.z.literal('query'),
    description: zod_1.z.string().optional(),
    parameters: exports.lexXrpcParameters.optional(),
    output: exports.lexXrpcBody.optional(),
    errors: exports.lexXrpcError.array().optional()
}).strict();
exports.lexXrpcProcedure = zod_1.z.object({
    type: zod_1.z.literal('procedure'),
    description: zod_1.z.string().optional(),
    parameters: exports.lexXrpcParameters.optional(),
    input: exports.lexXrpcBody.optional(),
    output: exports.lexXrpcBody.optional(),
    errors: exports.lexXrpcError.array().optional()
}).strict();
exports.lexXrpcSubscription = zod_1.z.object({
    type: zod_1.z.literal('subscription'),
    description: zod_1.z.string().optional(),
    parameters: exports.lexXrpcParameters.optional(),
    message: exports.lexXrpcSubscriptionMessage.optional(),
    errors: exports.lexXrpcError.array().optional()
}).strict();
// database
// =
exports.lexRecord = zod_1.z.object({
    type: zod_1.z.literal('record'),
    description: zod_1.z.string().optional(),
    key: zod_1.z.string().optional(),
    record: exports.lexObject
}).strict();
// core
// =
// We need to use `z.custom` here because
// lexXrpcProperty and lexObject are refined
// `z.union` would work, but it's too slow
// see #915 for details
exports.lexUserType = zod_1.z.custom((val)=>{
    if (!val || typeof val !== 'object') {
        return;
    }
    if (val['type'] === undefined) {
        return;
    }
    switch(val['type']){
        case 'record':
            return exports.lexRecord.parse(val);
        case 'query':
            return exports.lexXrpcQuery.parse(val);
        case 'procedure':
            return exports.lexXrpcProcedure.parse(val);
        case 'subscription':
            return exports.lexXrpcSubscription.parse(val);
        case 'blob':
            return exports.lexBlob.parse(val);
        case 'array':
            return exports.lexArray.parse(val);
        case 'token':
            return exports.lexToken.parse(val);
        case 'object':
            return exports.lexObject.parse(val);
        case 'boolean':
            return exports.lexBoolean.parse(val);
        case 'integer':
            return exports.lexInteger.parse(val);
        case 'string':
            return exports.lexString.parse(val);
        case 'bytes':
            return exports.lexBytes.parse(val);
        case 'cid-link':
            return exports.lexCidLink.parse(val);
        case 'unknown':
            return exports.lexUnknown.parse(val);
    }
}, (val)=>{
    if (!val || typeof val !== 'object') {
        return {
            message: 'Must be an object',
            fatal: true
        };
    }
    if (val['type'] === undefined) {
        return {
            message: 'Must have a type',
            fatal: true
        };
    }
    if (typeof val['type'] !== 'string') {
        return {
            message: 'Type property must be a string',
            fatal: true
        };
    }
    return {
        message: `Invalid type: ${val['type']} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
        fatal: true
    };
});
exports.lexiconDoc = zod_1.z.object({
    lexicon: zod_1.z.literal(1),
    id: zod_1.z.string().refine((v)=>syntax_1.NSID.isValid(v), {
        message: 'Must be a valid NSID'
    }),
    revision: zod_1.z.number().optional(),
    description: zod_1.z.string().optional(),
    defs: zod_1.z.record(exports.lexUserType)
}).strict().superRefine((doc, ctx)=>{
    for(const defId in doc.defs){
        const def = doc.defs[defId];
        if (defId !== 'main' && (def.type === 'record' || def.type === 'procedure' || def.type === 'query' || def.type === 'subscription')) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
        }
    }
});
// helpers
// =
function isValidLexiconDoc(v) {
    return exports.lexiconDoc.safeParse(v).success;
}
function isObj(obj) {
    return obj !== null && typeof obj === 'object';
}
function hasProp(data, prop) {
    return prop in data;
}
exports.discriminatedObject = zod_1.z.object({
    $type: zod_1.z.string()
});
function isDiscriminatedObject(value) {
    return exports.discriminatedObject.safeParse(value).success;
}
function parseLexiconDoc(v) {
    exports.lexiconDoc.parse(v);
    return v;
}
class ValidationError extends Error {
}
exports.ValidationError = ValidationError;
class InvalidLexiconError extends Error {
}
exports.InvalidLexiconError = InvalidLexiconError;
class LexiconDefNotFoundError extends Error {
}
exports.LexiconDefNotFoundError = LexiconDefNotFoundError; //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlobRef = exports.jsonBlobRef = exports.untypedJsonBlobRef = exports.typedJsonBlobRef = void 0;
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-ssr] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.typedJsonBlobRef = zod_1.z.object({
    $type: zod_1.z.literal('blob'),
    ref: common_web_1.schema.cid,
    mimeType: zod_1.z.string(),
    size: zod_1.z.number()
}).strict();
exports.untypedJsonBlobRef = zod_1.z.object({
    cid: zod_1.z.string(),
    mimeType: zod_1.z.string()
}).strict();
exports.jsonBlobRef = zod_1.z.union([
    exports.typedJsonBlobRef,
    exports.untypedJsonBlobRef
]);
class BlobRef {
    constructor(ref, mimeType, size, original){
        Object.defineProperty(this, "ref", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ref
        });
        Object.defineProperty(this, "mimeType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mimeType
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: size
        });
        Object.defineProperty(this, "original", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.original = original ?? {
            $type: 'blob',
            ref,
            mimeType,
            size
        };
    }
    static asBlobRef(obj) {
        if (common_web_1.check.is(obj, exports.jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
        }
        return null;
    }
    static fromJsonRef(json) {
        if (common_web_1.check.is(json, exports.typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
        } else {
            return new BlobRef(cid_1.CID.parse(json.cid), json.mimeType, -1, json);
        }
    }
    ipld() {
        return {
            $type: 'blob',
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
        };
    }
    toJSON() {
        return (0, common_web_1.ipldToJson)(this.ipld());
    }
}
exports.BlobRef = BlobRef; //# sourceMappingURL=blob-refs.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/blob.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blob = blob;
const blob_refs_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)");
function blob(lexicons, path, def, value) {
    // check
    if (!value || !(value instanceof blob_refs_1.BlobRef)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} should be a blob ref`)
        };
    }
    return {
        success: true,
        value
    };
} //# sourceMappingURL=blob.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/formats.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.datetime = datetime;
exports.uri = uri;
exports.atUri = atUri;
exports.did = did;
exports.handle = handle;
exports.atIdentifier = atIdentifier;
exports.nsid = nsid;
exports.cid = cid;
exports.language = language;
exports.tid = tid;
exports.recordKey = recordKey;
const iso_datestring_validator_1 = __turbopack_require__("[project]/node_modules/iso-datestring-validator/dist/index.js [app-ssr] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)");
const syntax_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/index.js [app-ssr] (ecmascript)");
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-ssr] (ecmascript)");
function datetime(path, value) {
    try {
        if (!(0, iso_datestring_validator_1.isValidISODateString)(value)) {
            throw new Error();
        }
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
        };
    }
    return {
        success: true,
        value
    };
}
function uri(path, value) {
    const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
    if (!isUri) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a uri`)
        };
    }
    return {
        success: true,
        value
    };
}
function atUri(path, value) {
    try {
        (0, syntax_1.ensureValidAtUri)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid at-uri`)
        };
    }
    return {
        success: true,
        value
    };
}
function did(path, value) {
    try {
        (0, syntax_1.ensureValidDid)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid did`)
        };
    }
    return {
        success: true,
        value
    };
}
function handle(path, value) {
    try {
        (0, syntax_1.ensureValidHandle)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid handle`)
        };
    }
    return {
        success: true,
        value
    };
}
function atIdentifier(path, value) {
    // We can discriminate based on the "did:" prefix
    if (value.startsWith('did:')) {
        const didResult = did(path, value);
        if (didResult.success) return didResult;
    } else {
        const handleResult = handle(path, value);
        if (handleResult.success) return handleResult;
    }
    return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a valid did or a handle`)
    };
}
function nsid(path, value) {
    try {
        (0, syntax_1.ensureValidNsid)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid nsid`)
        };
    }
    return {
        success: true,
        value
    };
}
function cid(path, value) {
    try {
        cid_1.CID.parse(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a cid string`)
        };
    }
    return {
        success: true,
        value
    };
}
// The language format validates well-formed BCP 47 language tags: https://www.rfc-editor.org/info/bcp47
function language(path, value) {
    if ((0, common_web_1.validateLanguage)(value)) {
        return {
            success: true,
            value
        };
    }
    return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a well-formed BCP 47 language tag`)
    };
}
function tid(path, value) {
    try {
        (0, syntax_1.ensureValidTid)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid TID (timestamp identifier)`)
        };
    }
    return {
        success: true,
        value
    };
}
function recordKey(path, value) {
    try {
        (0, syntax_1.ensureValidRecordKey)(value);
    } catch  {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a valid Record Key`)
        };
    }
    return {
        success: true,
        value
    };
} //# sourceMappingURL=formats.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/primitives.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = validate;
exports.boolean = boolean;
exports.integer = integer;
exports.string = string;
exports.bytes = bytes;
exports.cidLink = cidLink;
exports.unknown = unknown;
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-ssr] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
const formats = __importStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/formats.js [app-ssr] (ecmascript)"));
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)");
function validate(lexicons, path, def, value) {
    switch(def.type){
        case 'boolean':
            return boolean(lexicons, path, def, value);
        case 'integer':
            return integer(lexicons, path, def, value);
        case 'string':
            return string(lexicons, path, def, value);
        case 'bytes':
            return bytes(lexicons, path, def, value);
        case 'cid-link':
            return cidLink(lexicons, path, def, value);
        case 'unknown':
            return unknown(lexicons, path, def, value);
        default:
            return {
                success: false,
                error: new types_1.ValidationError(`Unexpected lexicon type: ${def.type}`)
            };
    }
}
function boolean(lexicons, path, def, value) {
    def = def;
    // type
    const type = typeof value;
    if (type === 'undefined') {
        if (typeof def.default === 'boolean') {
            return {
                success: true,
                value: def.default
            };
        }
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a boolean`)
        };
    } else if (type !== 'boolean') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a boolean`)
        };
    }
    // const
    if (typeof def.const === 'boolean') {
        if (value !== def.const) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be ${def.const}`)
            };
        }
    }
    return {
        success: true,
        value
    };
}
function integer(lexicons, path, def, value) {
    def = def;
    // type
    const type = typeof value;
    if (type === 'undefined') {
        if (typeof def.default === 'number') {
            return {
                success: true,
                value: def.default
            };
        }
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an integer`)
        };
    } else if (!Number.isInteger(value)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an integer`)
        };
    }
    // const
    if (typeof def.const === 'number') {
        if (value !== def.const) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be ${def.const}`)
            };
        }
    }
    // enum
    if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be one of (${def.enum.join('|')})`)
            };
        }
    }
    // maximum
    if (typeof def.maximum === 'number') {
        if (value > def.maximum) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} can not be greater than ${def.maximum}`)
            };
        }
    }
    // minimum
    if (typeof def.minimum === 'number') {
        if (value < def.minimum) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} can not be less than ${def.minimum}`)
            };
        }
    }
    return {
        success: true,
        value
    };
}
function string(lexicons, path, def, value) {
    def = def;
    // type
    if (typeof value === 'undefined') {
        if (typeof def.default === 'string') {
            return {
                success: true,
                value: def.default
            };
        }
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a string`)
        };
    } else if (typeof value !== 'string') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a string`)
        };
    }
    // const
    if (typeof def.const === 'string') {
        if (value !== def.const) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be ${def.const}`)
            };
        }
    }
    // enum
    if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be one of (${def.enum.join('|')})`)
            };
        }
    }
    // maxLength and minLength
    if (typeof def.minLength === 'number' || typeof def.maxLength === 'number') {
        // If the JavaScript string length * 3 is below the maximum limit,
        // its UTF8 length (which <= .length * 3) will also be below.
        if (typeof def.minLength === 'number' && value.length * 3 < def.minLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
            };
        }
        // If the JavaScript string length * 3 is within the maximum limit,
        // its UTF8 length (which <= .length * 3) will also be within.
        // When there's no minimal length, this lets us skip the UTF8 length check.
        let canSkipUtf8LenChecks = false;
        if (typeof def.minLength === 'undefined' && typeof def.maxLength === 'number' && value.length * 3 <= def.maxLength) {
            canSkipUtf8LenChecks = true;
        }
        if (!canSkipUtf8LenChecks) {
            const len = (0, common_web_1.utf8Len)(value);
            if (typeof def.maxLength === 'number') {
                if (len > def.maxLength) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be longer than ${def.maxLength} characters`)
                    };
                }
            }
            if (typeof def.minLength === 'number') {
                if (len < def.minLength) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
                    };
                }
            }
        }
    }
    // maxGraphemes and minGraphemes
    if (typeof def.maxGraphemes === 'number' || typeof def.minGraphemes === 'number') {
        let needsMaxGraphemesCheck = false;
        let needsMinGraphemesCheck = false;
        if (typeof def.maxGraphemes === 'number') {
            if (value.length <= def.maxGraphemes) {
                // If the JavaScript string length (UTF-16) is within the maximum limit,
                // its grapheme length (which <= .length) will also be within.
                needsMaxGraphemesCheck = false;
            } else {
                needsMaxGraphemesCheck = true;
            }
        }
        if (typeof def.minGraphemes === 'number') {
            if (value.length < def.minGraphemes) {
                // If the JavaScript string length (UTF-16) is below the minimal limit,
                // its grapheme length (which <= .length) will also be below.
                // Fail early.
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
                };
            } else {
                needsMinGraphemesCheck = true;
            }
        }
        if (needsMaxGraphemesCheck || needsMinGraphemesCheck) {
            const len = (0, common_web_1.graphemeLen)(value);
            if (typeof def.maxGraphemes === 'number') {
                if (len > def.maxGraphemes) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be longer than ${def.maxGraphemes} graphemes`)
                    };
                }
            }
            if (typeof def.minGraphemes === 'number') {
                if (len < def.minGraphemes) {
                    return {
                        success: false,
                        error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
                    };
                }
            }
        }
    }
    if (typeof def.format === 'string') {
        switch(def.format){
            case 'datetime':
                return formats.datetime(path, value);
            case 'uri':
                return formats.uri(path, value);
            case 'at-uri':
                return formats.atUri(path, value);
            case 'did':
                return formats.did(path, value);
            case 'handle':
                return formats.handle(path, value);
            case 'at-identifier':
                return formats.atIdentifier(path, value);
            case 'nsid':
                return formats.nsid(path, value);
            case 'cid':
                return formats.cid(path, value);
            case 'language':
                return formats.language(path, value);
            case 'tid':
                return formats.tid(path, value);
            case 'record-key':
                return formats.recordKey(path, value);
        }
    }
    return {
        success: true,
        value
    };
}
function bytes(lexicons, path, def, value) {
    def = def;
    if (!value || !(value instanceof Uint8Array)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a byte array`)
        };
    }
    // maxLength
    if (typeof def.maxLength === 'number') {
        if (value.byteLength > def.maxLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be larger than ${def.maxLength} bytes`)
            };
        }
    }
    // minLength
    if (typeof def.minLength === 'number') {
        if (value.byteLength < def.minLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be smaller than ${def.minLength} bytes`)
            };
        }
    }
    return {
        success: true,
        value
    };
}
function cidLink(lexicons, path, def, value) {
    if (cid_1.CID.asCID(value) === null) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be a CID`)
        };
    }
    return {
        success: true,
        value
    };
}
function unknown(lexicons, path, def, value) {
    // type
    if (!value || typeof value !== 'object') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an object`)
        };
    }
    return {
        success: true,
        value
    };
} //# sourceMappingURL=primitives.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = validate;
exports.array = array;
exports.object = object;
exports.validateOneOf = validateOneOf;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/util.js [app-ssr] (ecmascript)");
const blob_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/blob.js [app-ssr] (ecmascript)");
const primitives_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/primitives.js [app-ssr] (ecmascript)");
function validate(lexicons, path, def, value) {
    switch(def.type){
        case 'boolean':
            return (0, primitives_1.boolean)(lexicons, path, def, value);
        case 'integer':
            return (0, primitives_1.integer)(lexicons, path, def, value);
        case 'string':
            return (0, primitives_1.string)(lexicons, path, def, value);
        case 'bytes':
            return (0, primitives_1.bytes)(lexicons, path, def, value);
        case 'cid-link':
            return (0, primitives_1.cidLink)(lexicons, path, def, value);
        case 'unknown':
            return (0, primitives_1.unknown)(lexicons, path, def, value);
        case 'object':
            return object(lexicons, path, def, value);
        case 'array':
            return array(lexicons, path, def, value);
        case 'blob':
            return (0, blob_1.blob)(lexicons, path, def, value);
        default:
            return {
                success: false,
                error: new types_1.ValidationError(`Unexpected lexicon type: ${def.type}`)
            };
    }
}
function array(lexicons, path, def, value) {
    // type
    if (!Array.isArray(value)) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an array`)
        };
    }
    // maxLength
    if (typeof def.maxLength === 'number') {
        if (value.length > def.maxLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not have more than ${def.maxLength} elements`)
            };
        }
    }
    // minLength
    if (typeof def.minLength === 'number') {
        if (value.length < def.minLength) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must not have fewer than ${def.minLength} elements`)
            };
        }
    }
    // items
    const itemsDef = def.items;
    for(let i = 0; i < value.length; i++){
        const itemValue = value[i];
        const itemPath = `${path}/${i}`;
        const res = validateOneOf(lexicons, itemPath, itemsDef, itemValue);
        if (!res.success) {
            return res;
        }
    }
    return {
        success: true,
        value
    };
}
function object(lexicons, path, def, value) {
    def = def;
    // type
    if (!value || typeof value !== 'object') {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an object`)
        };
    }
    const requiredProps = new Set(def.required);
    const nullableProps = new Set(def.nullable);
    // properties
    let resultValue = value;
    if (typeof def.properties === 'object') {
        for(const key in def.properties){
            if (value[key] === null && nullableProps.has(key)) {
                continue;
            }
            const propDef = def.properties[key];
            if (typeof value[key] === 'undefined' && !requiredProps.has(key)) {
                // Fast path for non-required undefined props.
                if (propDef.type === 'integer' || propDef.type === 'boolean' || propDef.type === 'string') {
                    if (typeof propDef.default === 'undefined') {
                        continue;
                    }
                } else {
                    continue;
                }
            }
            const propPath = `${path}/${key}`;
            const validated = validateOneOf(lexicons, propPath, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === 'undefined';
            // Return error for bad validation, giving required rule precedence
            if (propIsUndefined && requiredProps.has(key)) {
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} must have the property "${key}"`)
                };
            } else if (!propIsUndefined && !validated.success) {
                return validated;
            }
            // Adjust value based on e.g. applied defaults, cloning shallowly if there was a changed value
            if (propValue !== value[key]) {
                if (resultValue === value) {
                    // Lazy shallow clone
                    resultValue = {
                        ...value
                    };
                }
                resultValue[key] = propValue;
            }
        }
    }
    return {
        success: true,
        value: resultValue
    };
}
function validateOneOf(lexicons, path, def, value, mustBeObj = false) {
    let error;
    let concreteDefs;
    if (def.type === 'union') {
        if (!(0, types_1.isDiscriminatedObject)(value)) {
            return {
                success: false,
                error: new types_1.ValidationError(`${path} must be an object which includes the "$type" property`)
            };
        }
        if (!refsContainType(def.refs, value.$type)) {
            if (def.closed) {
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} $type must be one of ${def.refs.join(', ')}`)
                };
            }
            return {
                success: true,
                value
            };
        } else {
            concreteDefs = (0, util_1.toConcreteTypes)(lexicons, {
                type: 'ref',
                ref: value.$type
            });
        }
    } else {
        concreteDefs = (0, util_1.toConcreteTypes)(lexicons, def);
    }
    for (const concreteDef of concreteDefs){
        const result = mustBeObj ? object(lexicons, path, concreteDef, value) : validate(lexicons, path, concreteDef, value);
        if (result.success) {
            return result;
        }
        error ?? (error = result.error);
    }
    if (concreteDefs.length > 1) {
        return {
            success: false,
            error: new types_1.ValidationError(`${path} did not match any of the expected definitions`)
        };
    }
    return {
        success: false,
        error
    };
}
// to avoid bugs like #0189 this needs to handle both
// explicit and implicit #main
const refsContainType = (refs, type)=>{
    const lexUri = (0, util_1.toLexUri)(type);
    if (refs.includes(lexUri)) {
        return true;
    }
    if (lexUri.endsWith('#main')) {
        return refs.includes(lexUri.replace('#main', ''));
    } else {
        return refs.includes(lexUri + '#main');
    }
}; //# sourceMappingURL=complex.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validators/xrpc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.params = params;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)");
const PrimitiveValidators = __importStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/primitives.js [app-ssr] (ecmascript)"));
const complex_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-ssr] (ecmascript)");
function params(lexicons, path, def, val) {
    // type
    const value = val && typeof val === 'object' ? val : {};
    const requiredProps = new Set(def.required ?? []);
    // properties
    let resultValue = value;
    if (typeof def.properties === 'object') {
        for(const key in def.properties){
            const propDef = def.properties[key];
            const validated = propDef.type === 'array' ? (0, complex_1.array)(lexicons, key, propDef, value[key]) : PrimitiveValidators.validate(lexicons, key, propDef, value[key]);
            const propValue = validated.success ? validated.value : value[key];
            const propIsUndefined = typeof propValue === 'undefined';
            // Return error for bad validation, giving required rule precedence
            if (propIsUndefined && requiredProps.has(key)) {
                return {
                    success: false,
                    error: new types_1.ValidationError(`${path} must have the property "${key}"`)
                };
            } else if (!propIsUndefined && !validated.success) {
                return validated;
            }
            // Adjust value based on e.g. applied defaults, cloning shallowly if there was a changed value
            if (propValue !== value[key]) {
                if (resultValue === value) {
                    // Lazy shallow clone
                    resultValue = {
                        ...value
                    };
                }
                resultValue[key] = propValue;
            }
        }
    }
    return {
        success: true,
        value: resultValue
    };
} //# sourceMappingURL=xrpc.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/validation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertValidRecord = assertValidRecord;
exports.assertValidXrpcParams = assertValidXrpcParams;
exports.assertValidXrpcInput = assertValidXrpcInput;
exports.assertValidXrpcOutput = assertValidXrpcOutput;
exports.assertValidXrpcMessage = assertValidXrpcMessage;
const complex_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-ssr] (ecmascript)");
const xrpc_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/xrpc.js [app-ssr] (ecmascript)");
function assertValidRecord(lexicons, def, value) {
    const res = (0, complex_1.object)(lexicons, 'Record', def.record, value);
    if (!res.success) throw res.error;
    return res.value;
}
function assertValidXrpcParams(lexicons, def, value) {
    if (def.parameters) {
        const res = (0, xrpc_1.params)(lexicons, 'Params', def.parameters, value);
        if (!res.success) throw res.error;
        return res.value;
    }
}
function assertValidXrpcInput(lexicons, def, value) {
    if (def.input?.schema) {
        // loop: all input schema definitions
        return assertValidOneOf(lexicons, 'Input', def.input.schema, value, true);
    }
}
function assertValidXrpcOutput(lexicons, def, value) {
    if (def.output?.schema) {
        // loop: all output schema definitions
        return assertValidOneOf(lexicons, 'Output', def.output.schema, value, true);
    }
}
function assertValidXrpcMessage(lexicons, def, value) {
    if (def.message?.schema) {
        // loop: all output schema definitions
        return assertValidOneOf(lexicons, 'Message', def.message.schema, value, true);
    }
}
function assertValidOneOf(lexicons, path, def, value, mustBeObj = false) {
    const res = (0, complex_1.validateOneOf)(lexicons, path, def, value, mustBeObj);
    if (!res.success) throw res.error;
    return res.value;
} //# sourceMappingURL=validation.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/lexicons.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Lexicons = void 0;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)");
const validation_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validation.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/util.js [app-ssr] (ecmascript)");
const ComplexValidators = __importStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/validators/complex.js [app-ssr] (ecmascript)"));
/**
 * A collection of compiled lexicons.
 */ class Lexicons {
    constructor(docs){
        Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "defs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        if (docs) {
            for (const doc of docs){
                this.add(doc);
            }
        }
    }
    /**
     * @example clone a lexicon:
     * ```ts
     * const clone = new Lexicons(originalLexicon)
     * ```
     *
     * @example get docs array:
     * ```ts
     * const docs = Array.from(lexicons)
     * ```
     */ [Symbol.iterator]() {
        return this.docs.values();
    }
    /**
     * Add a lexicon doc.
     */ add(doc) {
        const uri = (0, util_1.toLexUri)(doc.id);
        if (this.docs.has(uri)) {
            throw new Error(`${uri} has already been registered`);
        }
        // WARNING
        // mutates the object
        // -prf
        resolveRefUris(doc, uri);
        this.docs.set(uri, doc);
        for (const [defUri, def] of iterDefs(doc)){
            this.defs.set(defUri, def);
        }
    }
    /**
     * Remove a lexicon doc.
     */ remove(uri) {
        uri = (0, util_1.toLexUri)(uri);
        const doc = this.docs.get(uri);
        if (!doc) {
            throw new Error(`Unable to remove "${uri}": does not exist`);
        }
        for (const [defUri, _def] of iterDefs(doc)){
            this.defs.delete(defUri);
        }
        this.docs.delete(uri);
    }
    /**
     * Get a lexicon doc.
     */ get(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.docs.get(uri);
    }
    /**
     * Get a definition.
     */ getDef(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.defs.get(uri);
    }
    getDefOrThrow(uri, types) {
        const def = this.getDef(uri);
        if (!def) {
            throw new types_1.LexiconDefNotFoundError(`Lexicon not found: ${uri}`);
        }
        if (types && !types.includes(def.type)) {
            throw new types_1.InvalidLexiconError(`Not a ${types.join(' or ')} lexicon: ${uri}`);
        }
        return def;
    }
    /**
     * Validate a record or object.
     */ validate(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'record',
            'object'
        ]);
        if (!(0, types_1.isObj)(value)) {
            throw new types_1.ValidationError(`Value must be an object`);
        }
        if (def.type === 'record') {
            return ComplexValidators.object(this, 'Record', def.record, value);
        } else if (def.type === 'object') {
            return ComplexValidators.object(this, 'Object', def, value);
        } else {
            // shouldn't happen
            throw new types_1.InvalidLexiconError('Definition must be a record or object');
        }
    }
    /**
     * Validate a record and throw on any error.
     */ assertValidRecord(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'record'
        ]);
        if (!(0, types_1.isObj)(value)) {
            throw new types_1.ValidationError(`Record must be an object`);
        }
        if (!(0, types_1.hasProp)(value, '$type') || typeof value.$type !== 'string') {
            throw new types_1.ValidationError(`Record/$type must be a string`);
        }
        const $type = value.$type || '';
        if ((0, util_1.toLexUri)($type) !== lexUri) {
            throw new types_1.ValidationError(`Invalid $type: must be ${lexUri}, got ${$type}`);
        }
        return (0, validation_1.assertValidRecord)(this, def, value);
    }
    /**
     * Validate xrpc query params and throw on any error.
     */ assertValidXrpcParams(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'query',
            'procedure',
            'subscription'
        ]);
        return (0, validation_1.assertValidXrpcParams)(this, def, value);
    }
    /**
     * Validate xrpc input body and throw on any error.
     */ assertValidXrpcInput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'procedure'
        ]);
        return (0, validation_1.assertValidXrpcInput)(this, def, value);
    }
    /**
     * Validate xrpc output body and throw on any error.
     */ assertValidXrpcOutput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'query',
            'procedure'
        ]);
        return (0, validation_1.assertValidXrpcOutput)(this, def, value);
    }
    /**
     * Validate xrpc subscription message and throw on any error.
     */ assertValidXrpcMessage(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
            'subscription'
        ]);
        return (0, validation_1.assertValidXrpcMessage)(this, def, value);
    }
    /**
     * Resolve a lex uri given a ref
     */ resolveLexUri(lexUri, ref) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        return (0, util_1.toLexUri)(ref, lexUri);
    }
}
exports.Lexicons = Lexicons;
function* iterDefs(doc) {
    for(const defId in doc.defs){
        yield [
            `lex:${doc.id}#${defId}`,
            doc.defs[defId]
        ];
        if (defId === 'main') {
            yield [
                `lex:${doc.id}`,
                doc.defs[defId]
            ];
        }
    }
}
// WARNING
// this method mutates objects
// -prf
function resolveRefUris(obj, baseUri) {
    for(const k in obj){
        if (obj.type === 'ref') {
            obj.ref = (0, util_1.toLexUri)(obj.ref, baseUri);
        } else if (obj.type === 'union') {
            obj.refs = obj.refs.map((ref)=>(0, util_1.toLexUri)(ref, baseUri));
        } else if (Array.isArray(obj[k])) {
            obj[k] = obj[k].map((item)=>{
                if (typeof item === 'string') {
                    return item.startsWith('#') ? (0, util_1.toLexUri)(item, baseUri) : item;
                } else if (item && typeof item === 'object') {
                    return resolveRefUris(item, baseUri);
                }
                return item;
            });
        } else if (obj[k] && typeof obj[k] === 'object') {
            obj[k] = resolveRefUris(obj[k], baseUri);
        }
    }
    return obj;
} //# sourceMappingURL=lexicons.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/serialize.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jsonStringToLex = exports.jsonToLex = exports.stringifyLex = exports.lexToJson = exports.ipldToLex = exports.lexToIpld = void 0;
const common_web_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/index.js [app-ssr] (ecmascript)");
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
const blob_refs_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-ssr] (ecmascript)");
// @NOTE avoiding use of check.is() here only because it makes
// these implementations slow, and they often live in hot paths.
const lexToIpld = (val)=>{
    // walk arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.lexToIpld)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // convert blobs, leaving the original encoding so that we don't change CIDs on re-encode
        if (val instanceof blob_refs_1.BlobRef) {
            return val.original;
        }
        // retain cids & bytes
        if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
        }
        // walk plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.lexToIpld)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.lexToIpld = lexToIpld;
const ipldToLex = (val)=>{
    // map arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.ipldToLex)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // convert blobs, using hints to avoid expensive is() check
        if ((val['$type'] === 'blob' || typeof val['cid'] === 'string' && typeof val['mimeType'] === 'string') && common_web_1.check.is(val, blob_refs_1.jsonBlobRef)) {
            return blob_refs_1.BlobRef.fromJsonRef(val);
        }
        // retain cids, bytes
        if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
        }
        // map plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.ipldToLex)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.ipldToLex = ipldToLex;
const lexToJson = (val)=>{
    return (0, common_web_1.ipldToJson)((0, exports.lexToIpld)(val));
};
exports.lexToJson = lexToJson;
const stringifyLex = (val)=>{
    return JSON.stringify((0, exports.lexToJson)(val));
};
exports.stringifyLex = stringifyLex;
const jsonToLex = (val)=>{
    return (0, exports.ipldToLex)((0, common_web_1.jsonToIpld)(val));
};
exports.jsonToLex = jsonToLex;
const jsonStringToLex = (val)=>{
    return (0, exports.jsonToLex)(JSON.parse(val));
};
exports.jsonStringToLex = jsonStringToLex; //# sourceMappingURL=serialize.js.map
}}),
"[project]/node_modules/@atproto/lexicon/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/lexicons.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/blob-refs.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/serialize.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/check.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Explicitly not using "zod" types here to avoid mismatching types due to
// version differences.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isObject = exports.assure = exports.create = exports.is = void 0;
const is = (obj, def)=>{
    return def.safeParse(obj).success;
};
exports.is = is;
const create = (def)=>(v)=>def.safeParse(v).success;
exports.create = create;
const assure = (def, obj)=>{
    return def.parse(obj);
};
exports.assure = assure;
const isObject = (obj)=>{
    return typeof obj === 'object' && obj !== null;
};
exports.isObject = isObject; //# sourceMappingURL=check.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseIntWithFallback = exports.dedupeStrs = exports.range = exports.chunkArray = exports.errHasMsg = exports.isErrnoException = exports.asyncFilter = exports.s32decode = exports.s32encode = exports.streamToBuffer = exports.flattenUint8Arrays = exports.bailableWait = exports.wait = exports.jitter = exports.noUndefinedVals = void 0;
exports.omit = omit;
const noUndefinedVals = (obj)=>{
    Object.keys(obj).forEach((k)=>{
        if (obj[k] === undefined) {
            delete obj[k];
        }
    });
    return obj;
};
exports.noUndefinedVals = noUndefinedVals;
function omit(src, rejectedKeys) {
    // Hot path
    if (!src) return src;
    const dst = {};
    const srcKeys = Object.keys(src);
    for(let i = 0; i < srcKeys.length; i++){
        const key = srcKeys[i];
        if (!rejectedKeys.includes(key)) {
            dst[key] = src[key];
        }
    }
    return dst;
}
const jitter = (maxMs)=>{
    return Math.round((Math.random() - 0.5) * maxMs * 2);
};
exports.jitter = jitter;
const wait = (ms)=>{
    return new Promise((res)=>setTimeout(res, ms));
};
exports.wait = wait;
const bailableWait = (ms)=>{
    let bail;
    const waitPromise = new Promise((res)=>{
        const timeout = setTimeout(res, ms);
        bail = ()=>{
            clearTimeout(timeout);
            res();
        };
    });
    return {
        bail,
        wait: ()=>waitPromise
    };
};
exports.bailableWait = bailableWait;
const flattenUint8Arrays = (arrs)=>{
    const length = arrs.reduce((acc, cur)=>{
        return acc + cur.length;
    }, 0);
    const flattened = new Uint8Array(length);
    let offset = 0;
    arrs.forEach((arr)=>{
        flattened.set(arr, offset);
        offset += arr.length;
    });
    return flattened;
};
exports.flattenUint8Arrays = flattenUint8Arrays;
const streamToBuffer = async (stream)=>{
    const arrays = [];
    for await (const chunk of stream){
        arrays.push(chunk);
    }
    return (0, exports.flattenUint8Arrays)(arrays);
};
exports.streamToBuffer = streamToBuffer;
const S32_CHAR = '234567abcdefghijklmnopqrstuvwxyz';
const s32encode = (i)=>{
    let s = '';
    while(i){
        const c = i % 32;
        i = Math.floor(i / 32);
        s = S32_CHAR.charAt(c) + s;
    }
    return s;
};
exports.s32encode = s32encode;
const s32decode = (s)=>{
    let i = 0;
    for (const c of s){
        i = i * 32 + S32_CHAR.indexOf(c);
    }
    return i;
};
exports.s32decode = s32decode;
const asyncFilter = async (arr, fn)=>{
    const results = await Promise.all(arr.map((t)=>fn(t)));
    return arr.filter((_, i)=>results[i]);
};
exports.asyncFilter = asyncFilter;
const isErrnoException = (err)=>{
    return !!err && err['code'];
};
exports.isErrnoException = isErrnoException;
const errHasMsg = (err, msg)=>{
    return !!err && typeof err === 'object' && err['message'] === msg;
};
exports.errHasMsg = errHasMsg;
const chunkArray = (arr, chunkSize)=>{
    return arr.reduce((acc, cur, i)=>{
        const chunkI = Math.floor(i / chunkSize);
        if (!acc[chunkI]) {
            acc[chunkI] = [];
        }
        acc[chunkI].push(cur);
        return acc;
    }, []);
};
exports.chunkArray = chunkArray;
const range = (num)=>{
    const nums = [];
    for(let i = 0; i < num; i++){
        nums.push(i);
    }
    return nums;
};
exports.range = range;
const dedupeStrs = (strs)=>{
    return [
        ...new Set(strs)
    ];
};
exports.dedupeStrs = dedupeStrs;
const parseIntWithFallback = (value, fallback)=>{
    const parsed = parseInt(value || '', 10);
    return isNaN(parsed) ? fallback : parsed;
};
exports.parseIntWithFallback = parseIntWithFallback; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/arrays.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapDefined = exports.keyBy = void 0;
const keyBy = (arr, key)=>{
    return arr.reduce((acc, cur)=>{
        acc[cur[key]] = cur;
        return acc;
    }, {});
};
exports.keyBy = keyBy;
const mapDefined = (arr, fn)=>{
    const output = [];
    for (const item of arr){
        const val = fn(item);
        if (val !== undefined) {
            output.push(val);
        }
    }
    return output;
};
exports.mapDefined = mapDefined; //# sourceMappingURL=arrays.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/async.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsyncBufferFullError = exports.AsyncBuffer = exports.allComplete = exports.createDeferrables = exports.createDeferrable = exports.readFromGenerator = void 0;
exports.allFulfilled = allFulfilled;
exports.handleAllSettledErrors = handleAllSettledErrors;
exports.isRejectedResult = isRejectedResult;
exports.isFulfilledResult = isFulfilledResult;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-ssr] (ecmascript)");
// reads values from a generator into a list
// breaks when isDone signals `true` AND `waitFor` completes OR when a max length is reached
// NOTE: does not signal generator to close. it *will* continue to produce values
const readFromGenerator = async (gen, isDone, waitFor = Promise.resolve(), maxLength = Number.MAX_SAFE_INTEGER)=>{
    const evts = [];
    let bail;
    let hasBroke = false;
    const awaitDone = async ()=>{
        if (await isDone(evts.at(-1))) {
            return true;
        }
        const bailable = (0, util_1.bailableWait)(20);
        await bailable.wait();
        bail = bailable.bail;
        if (hasBroke) return false;
        return await awaitDone();
    };
    const breakOn = new Promise((resolve)=>{
        waitFor.then(()=>{
            awaitDone().then(()=>resolve());
        });
    });
    try {
        while(evts.length < maxLength){
            const maybeEvt = await Promise.race([
                gen.next(),
                breakOn
            ]);
            if (!maybeEvt) break;
            const evt = maybeEvt;
            if (evt.done) break;
            evts.push(evt.value);
        }
    } finally{
        hasBroke = true;
        bail && bail();
    }
    return evts;
};
exports.readFromGenerator = readFromGenerator;
const createDeferrable = ()=>{
    let resolve;
    const promise = new Promise((res)=>{
        resolve = ()=>res();
    });
    return {
        resolve,
        complete: promise
    };
};
exports.createDeferrable = createDeferrable;
const createDeferrables = (count)=>{
    const list = [];
    for(let i = 0; i < count; i++){
        list.push((0, exports.createDeferrable)());
    }
    return list;
};
exports.createDeferrables = createDeferrables;
const allComplete = async (deferrables)=>{
    await Promise.all(deferrables.map((d)=>d.complete));
};
exports.allComplete = allComplete;
class AsyncBuffer {
    constructor(maxSize){
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: maxSize
        });
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "promise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "toThrow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Initializing to satisfy types/build, immediately reset by resetPromise()
        this.promise = Promise.resolve();
        this.resolve = ()=>null;
        this.resetPromise();
    }
    get curr() {
        return this.buffer;
    }
    get size() {
        return this.buffer.length;
    }
    get isClosed() {
        return this.closed;
    }
    resetPromise() {
        this.promise = new Promise((r)=>this.resolve = r);
    }
    push(item) {
        this.buffer.push(item);
        this.resolve();
    }
    pushMany(items) {
        items.forEach((i)=>this.buffer.push(i));
        this.resolve();
    }
    async *events() {
        while(true){
            if (this.closed && this.buffer.length === 0) {
                if (this.toThrow) {
                    throw this.toThrow;
                } else {
                    return;
                }
            }
            await this.promise;
            if (this.toThrow) {
                throw this.toThrow;
            }
            if (this.maxSize && this.size > this.maxSize) {
                throw new AsyncBufferFullError(this.maxSize);
            }
            const [first, ...rest] = this.buffer;
            if (first) {
                this.buffer = rest;
                yield first;
            } else {
                this.resetPromise();
            }
        }
    }
    throw(err) {
        this.toThrow = err;
        this.closed = true;
        this.resolve();
    }
    close() {
        this.closed = true;
        this.resolve();
    }
}
exports.AsyncBuffer = AsyncBuffer;
class AsyncBufferFullError extends Error {
    constructor(maxSize){
        super(`ReachedMaxBufferSize: ${maxSize}`);
    }
}
exports.AsyncBufferFullError = AsyncBufferFullError;
function allFulfilled(promises) {
    return Promise.allSettled(promises).then(handleAllSettledErrors);
}
function handleAllSettledErrors(results) {
    const errors = results.filter(isRejectedResult).map(extractReason);
    if (errors.length === 0) {
        // No need to filter here, it is safe to assume that all promises are fulfilled
        return results.map(extractValue);
    }
    if (errors.length === 1) {
        throw errors[0];
    }
    throw new AggregateError(errors, `Multiple errors: ${errors.map(stringifyReason).join('\n')}`);
}
function isRejectedResult(result) {
    return result.status === 'rejected';
}
function extractReason(result) {
    return result.reason;
}
function isFulfilledResult(result) {
    return result.status === 'fulfilled';
}
function extractValue(result) {
    return result.value;
}
function stringifyReason(reason) {
    if (reason instanceof Error) {
        return reason.message;
    }
    return String(reason);
} //# sourceMappingURL=async.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/tid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TID = void 0;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-ssr] (ecmascript)");
const TID_LEN = 13;
let lastTimestamp = 0;
let timestampCount = 0;
let clockid = null;
function dedash(str) {
    return str.replaceAll('-', '');
}
class TID {
    constructor(str){
        Object.defineProperty(this, "str", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const noDashes = dedash(str);
        if (noDashes.length !== TID_LEN) {
            throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
        }
        this.str = noDashes;
    }
    static next(prev) {
        // javascript does not have microsecond precision
        // instead, we append a counter to the timestamp to indicate if multiple timestamps were created within the same millisecond
        // take max of current time & last timestamp to prevent tids moving backwards if system clock drifts backwards
        const time = Math.max(Date.now(), lastTimestamp);
        if (time === lastTimestamp) {
            timestampCount++;
        }
        lastTimestamp = time;
        const timestamp = time * 1000 + timestampCount;
        // the bottom 32 clock ids can be randomized & are not guaranteed to be collision resistant
        // we use the same clockid for all tids coming from this machine
        if (clockid === null) {
            clockid = Math.floor(Math.random() * 32);
        }
        const tid = TID.fromTime(timestamp, clockid);
        if (!prev || tid.newerThan(prev)) {
            return tid;
        }
        return TID.fromTime(prev.timestamp() + 1, clockid);
    }
    static nextStr(prev) {
        return TID.next(prev ? new TID(prev) : undefined).toString();
    }
    static fromTime(timestamp, clockid) {
        // base32 encode with encoding variant sort (s32)
        const str = `${(0, util_1.s32encode)(timestamp)}${(0, util_1.s32encode)(clockid).padStart(2, '2')}`;
        return new TID(str);
    }
    static fromStr(str) {
        return new TID(str);
    }
    static oldestFirst(a, b) {
        return a.compareTo(b);
    }
    static newestFirst(a, b) {
        return b.compareTo(a);
    }
    static is(str) {
        return dedash(str).length === TID_LEN;
    }
    timestamp() {
        return (0, util_1.s32decode)(this.str.slice(0, 11));
    }
    clockid() {
        return (0, util_1.s32decode)(this.str.slice(11, 13));
    }
    formatted() {
        const str = this.toString();
        return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(7, 11)}-${str.slice(11, 13)}`;
    }
    toString() {
        return this.str;
    }
    // newer > older
    compareTo(other) {
        if (this.str > other.str) return 1;
        if (this.str < other.str) return -1;
        return 0;
    }
    equals(other) {
        return this.str === other.str;
    }
    newerThan(other) {
        return this.compareTo(other) > 0;
    }
    olderThan(other) {
        return this.compareTo(other) < 0;
    }
}
exports.TID = TID;
exports.default = TID; //# sourceMappingURL=tid.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/ipld.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ipldEquals = exports.ipldToJson = exports.jsonToIpld = void 0;
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
const ui8 = __importStar(__turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/index.js [app-ssr] (ecmascript)"));
// @NOTE avoiding use of check.is() here only because it makes
// these implementations slow, and they often live in hot paths.
const jsonToIpld = (val)=>{
    // walk arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.jsonToIpld)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // check for dag json values
        if (typeof val['$link'] === 'string' && Object.keys(val).length === 1) {
            return cid_1.CID.parse(val['$link']);
        }
        if (typeof val['$bytes'] === 'string' && Object.keys(val).length === 1) {
            return ui8.fromString(val['$bytes'], 'base64');
        }
        // walk plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.jsonToIpld)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.jsonToIpld = jsonToIpld;
const ipldToJson = (val)=>{
    // walk arrays
    if (Array.isArray(val)) {
        return val.map((item)=>(0, exports.ipldToJson)(item));
    }
    // objects
    if (val && typeof val === 'object') {
        // convert bytes
        if (val instanceof Uint8Array) {
            return {
                $bytes: ui8.toString(val, 'base64')
            };
        }
        // convert cids
        if (cid_1.CID.asCID(val)) {
            return {
                $link: val.toString()
            };
        }
        // walk plain objects
        const toReturn = {};
        for (const key of Object.keys(val)){
            toReturn[key] = (0, exports.ipldToJson)(val[key]);
        }
        return toReturn;
    }
    // pass through
    return val;
};
exports.ipldToJson = ipldToJson;
const ipldEquals = (a, b)=>{
    // walk arrays
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length; i++){
            if (!(0, exports.ipldEquals)(a[i], b[i])) return false;
        }
        return true;
    }
    // objects
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        // check bytes
        if (a instanceof Uint8Array && b instanceof Uint8Array) {
            return ui8.equals(a, b);
        }
        // check cids
        if (cid_1.CID.asCID(a) && cid_1.CID.asCID(b)) {
            return cid_1.CID.asCID(a)?.equals(cid_1.CID.asCID(b));
        }
        // walk plain objects
        if (Object.keys(a).length !== Object.keys(b).length) return false;
        for (const key of Object.keys(a)){
            if (!(0, exports.ipldEquals)(a[key], b[key])) return false;
        }
        return true;
    }
    return a === b;
};
exports.ipldEquals = ipldEquals; //# sourceMappingURL=ipld.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/retry.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.retry = retry;
exports.createRetryable = createRetryable;
exports.backoffMs = backoffMs;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-ssr] (ecmascript)");
async function retry(fn, opts = {}) {
    const { maxRetries = 3, retryable = ()=>true, getWaitMs = backoffMs } = opts;
    let retries = 0;
    let doneError;
    while(!doneError){
        try {
            return await fn();
        } catch (err) {
            const waitMs = getWaitMs(retries);
            const willRetry = retries < maxRetries && waitMs !== null && retryable(err);
            if (willRetry) {
                retries += 1;
                if (waitMs !== 0) {
                    await (0, util_1.wait)(waitMs);
                }
            } else {
                doneError = err;
            }
        }
    }
    throw doneError;
}
function createRetryable(retryable) {
    return async (fn, opts)=>retry(fn, {
            ...opts,
            retryable
        });
}
// Waits exponential backoff with max and jitter: ~100, ~200, ~400, ~800, ~1000, ~1000, ...
function backoffMs(n, multiplier = 100, max = 1000) {
    const exponentialMs = Math.pow(2, n) * multiplier;
    const ms = Math.min(exponentialMs, max);
    return jitter(ms);
}
// Adds randomness +/-15% of value
function jitter(value) {
    const delta = value * 0.15;
    return value + randomRange(-delta, delta);
}
function randomRange(from, to) {
    const rand = Math.random() * (to - from);
    return rand + from;
} //# sourceMappingURL=retry.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.def = exports.schema = void 0;
const cid_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const cidSchema = zod_1.z.any().refine((obj)=>cid_1.CID.asCID(obj) !== null, {
    message: 'Not a CID'
}).transform((obj)=>cid_1.CID.asCID(obj));
exports.schema = {
    cid: cidSchema,
    bytes: zod_1.z.instanceof(Uint8Array),
    string: zod_1.z.string(),
    array: zod_1.z.array(zod_1.z.unknown()),
    map: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
    unknown: zod_1.z.unknown()
};
exports.def = {
    cid: {
        name: 'cid',
        schema: exports.schema.cid
    },
    bytes: {
        name: 'bytes',
        schema: exports.schema.bytes
    },
    string: {
        name: 'string',
        schema: exports.schema.string
    },
    map: {
        name: 'map',
        schema: exports.schema.map
    },
    unknown: {
        name: 'unknown',
        schema: exports.schema.unknown
    }
}; //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/times.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addHoursToDate = exports.lessThanAgoMs = exports.DAY = exports.HOUR = exports.MINUTE = exports.SECOND = void 0;
exports.SECOND = 1000;
exports.MINUTE = exports.SECOND * 60;
exports.HOUR = exports.MINUTE * 60;
exports.DAY = exports.HOUR * 24;
const lessThanAgoMs = (time, range)=>{
    return Date.now() < time.getTime() + range;
};
exports.lessThanAgoMs = lessThanAgoMs;
const addHoursToDate = (hours, startingDate)=>{
    // When date is passed, clone before calling `setHours()` so that we are not mutating the original date
    const currentDate = startingDate ? new Date(startingDate) : new Date();
    currentDate.setHours(currentDate.getHours() + hours);
    return currentDate;
};
exports.addHoursToDate = addHoursToDate; //# sourceMappingURL=times.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/strings.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateLanguage = exports.parseLanguage = exports.b64UrlToUtf8 = exports.utf8ToB64Url = exports.graphemeLen = exports.utf8Len = void 0;
const graphemer_1 = __importDefault(__turbopack_require__("[project]/node_modules/graphemer/lib/index.js [app-ssr] (ecmascript)"));
const ui8 = __importStar(__turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/index.js [app-ssr] (ecmascript)"));
// counts the number of bytes in a utf8 string
const utf8Len = (str)=>{
    return new TextEncoder().encode(str).byteLength;
};
exports.utf8Len = utf8Len;
// counts the number of graphemes (user-displayed characters) in a string
const graphemeLen = (str)=>{
    const splitter = new graphemer_1.default();
    return splitter.countGraphemes(str);
};
exports.graphemeLen = graphemeLen;
const utf8ToB64Url = (utf8)=>{
    return ui8.toString(ui8.fromString(utf8, 'utf8'), 'base64url');
};
exports.utf8ToB64Url = utf8ToB64Url;
const b64UrlToUtf8 = (b64)=>{
    return ui8.toString(ui8.fromString(b64, 'base64url'), 'utf8');
};
exports.b64UrlToUtf8 = b64UrlToUtf8;
const parseLanguage = (langTag)=>{
    const parsed = langTag.match(bcp47Regexp);
    if (!parsed?.groups) return null;
    const parts = parsed.groups;
    return {
        grandfathered: parts.grandfathered,
        language: parts.language,
        extlang: parts.extlang,
        script: parts.script,
        region: parts.region,
        variant: parts.variant,
        extension: parts.extension,
        privateUse: parts.privateUseA || parts.privateUseB
    };
};
exports.parseLanguage = parseLanguage;
const validateLanguage = (langTag)=>{
    return bcp47Regexp.test(langTag);
};
exports.validateLanguage = validateLanguage;
// Validates well-formed BCP 47 syntax: https://www.rfc-editor.org/rfc/rfc5646.html#section-2.1
const bcp47Regexp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/; //# sourceMappingURL=strings.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/did-doc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didDocument = exports.getServiceEndpoint = exports.getNotifEndpoint = exports.getFeedGenEndpoint = exports.getPdsEndpoint = exports.getSigningDidKey = exports.getVerificationMaterial = exports.getSigningKey = exports.getHandle = exports.getDid = exports.isValidDidDoc = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
// Parsing atproto data
// --------
const isValidDidDoc = (doc)=>{
    return exports.didDocument.safeParse(doc).success;
};
exports.isValidDidDoc = isValidDidDoc;
const getDid = (doc)=>{
    const id = doc.id;
    if (typeof id !== 'string') {
        throw new Error('No `id` on document');
    }
    return id;
};
exports.getDid = getDid;
const getHandle = (doc)=>{
    const aka = doc.alsoKnownAs;
    if (aka) {
        for(let i = 0; i < aka.length; i++){
            const alias = aka[i];
            if (alias.startsWith('at://')) {
                // strip off "at://" prefix
                return alias.slice(5);
            }
        }
    }
    return undefined;
};
exports.getHandle = getHandle;
// @NOTE we parse to type/publicKeyMultibase to avoid the dependency on @atproto/crypto
const getSigningKey = (doc)=>{
    return (0, exports.getVerificationMaterial)(doc, 'atproto');
};
exports.getSigningKey = getSigningKey;
const getVerificationMaterial = (doc, keyId)=>{
    // /!\ Hot path
    const key = findItemById(doc, 'verificationMethod', `#${keyId}`);
    if (!key) {
        return undefined;
    }
    if (!key.publicKeyMultibase) {
        return undefined;
    }
    return {
        type: key.type,
        publicKeyMultibase: key.publicKeyMultibase
    };
};
exports.getVerificationMaterial = getVerificationMaterial;
const getSigningDidKey = (doc)=>{
    const parsed = (0, exports.getSigningKey)(doc);
    if (!parsed) return;
    return `did:key:${parsed.publicKeyMultibase}`;
};
exports.getSigningDidKey = getSigningDidKey;
const getPdsEndpoint = (doc)=>{
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#atproto_pds',
        type: 'AtprotoPersonalDataServer'
    });
};
exports.getPdsEndpoint = getPdsEndpoint;
const getFeedGenEndpoint = (doc)=>{
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#bsky_fg',
        type: 'BskyFeedGenerator'
    });
};
exports.getFeedGenEndpoint = getFeedGenEndpoint;
const getNotifEndpoint = (doc)=>{
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#bsky_notif',
        type: 'BskyNotificationService'
    });
};
exports.getNotifEndpoint = getNotifEndpoint;
const getServiceEndpoint = (doc, opts)=>{
    // /!\ Hot path
    const service = findItemById(doc, 'service', opts.id);
    if (!service) {
        return undefined;
    }
    if (opts.type && service.type !== opts.type) {
        return undefined;
    }
    if (typeof service.serviceEndpoint !== 'string') {
        return undefined;
    }
    return validateUrl(service.serviceEndpoint);
};
exports.getServiceEndpoint = getServiceEndpoint;
function findItemById(doc, type, id) {
    // /!\ Hot path
    const items = doc[type];
    if (items) {
        for(let i = 0; i < items.length; i++){
            const item = items[i];
            const itemId = item.id;
            if (itemId[0] === '#' ? itemId === id : itemId.length === doc.id.length + id.length && itemId[doc.id.length] === '#' && itemId.endsWith(id) && itemId.startsWith(doc.id) // <== We could probably skip this check
            ) {
                return item;
            }
        }
    }
    return undefined;
}
// Check protocol and hostname to prevent potential SSRF
const validateUrl = (urlStr)=>{
    if (!urlStr.startsWith('http://') && !urlStr.startsWith('https://')) {
        return undefined;
    }
    if (!canParseUrl(urlStr)) {
        return undefined;
    }
    return urlStr;
};
const canParseUrl = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
((urlStr)=>{
    try {
        new URL(urlStr);
        return true;
    } catch  {
        return false;
    }
});
// Types
// --------
const verificationMethod = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.string(),
    controller: zod_1.z.string(),
    publicKeyMultibase: zod_1.z.string().optional()
});
const service = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.string(),
    serviceEndpoint: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.record(zod_1.z.unknown())
    ])
});
exports.didDocument = zod_1.z.object({
    id: zod_1.z.string(),
    alsoKnownAs: zod_1.z.array(zod_1.z.string()).optional(),
    verificationMethod: zod_1.z.array(verificationMethod).optional(),
    service: zod_1.z.array(service).optional()
}); //# sourceMappingURL=did-doc.js.map
}}),
"[project]/node_modules/@atproto/common-web/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.util = exports.check = void 0;
exports.check = __importStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/check.js [app-ssr] (ecmascript)"));
exports.util = __importStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/arrays.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/async.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/util.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/tid.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/ipld.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/retry.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/times.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/strings.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/common-web/dist/did-doc.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/multiformats/cjs/vendor/varint.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
var encode_1 = encode;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 255 | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1)
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
var varint$1 = _brrp_varint;
module.exports = varint$1;
}}),
"[project]/node_modules/multiformats/cjs/src/varint.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var varint$1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/vendor/varint.js [app-ssr] (ecmascript)");
const decode = (data, offset = 0)=>{
    const code = varint$1.decode(data, offset);
    return [
        code,
        varint$1.decode.bytes
    ];
};
const encodeTo = (int, target, offset = 0)=>{
    varint$1.encode(int, target, offset);
    return target;
};
const encodingLength = (int)=>{
    return varint$1.encodingLength(int);
};
exports.decode = decode;
exports.encodeTo = encodeTo;
exports.encodingLength = encodingLength;
}}),
"[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
const empty = new Uint8Array(0);
const toHex = (d)=>d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, '0'), '');
const fromHex = (hex)=>{
    const hexes = hex.match(/../g);
    return hexes ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
};
const equals = (aa, bb)=>{
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
};
const coerce = (o)=>{
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
};
const isBinary = (o)=>o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString = (str)=>new TextEncoder().encode(str);
const toString = (b)=>new TextDecoder().decode(b);
exports.coerce = coerce;
exports.empty = empty;
exports.equals = equals;
exports.fromHex = fromHex;
exports.fromString = fromString;
exports.isBinary = isBinary;
exports.toHex = toHex;
exports.toString = toString;
}}),
"[project]/node_modules/multiformats/cjs/src/hashes/digest.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
var varint = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/varint.js [app-ssr] (ecmascript)");
const create = (code, digest)=>{
    const size = digest.byteLength;
    const sizeOffset = varint.encodingLength(code);
    const digestOffset = sizeOffset + varint.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    varint.encodeTo(code, bytes, 0);
    varint.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
};
const decode = (multihash)=>{
    const bytes$1 = bytes.coerce(multihash);
    const [code, sizeOffset] = varint.decode(bytes$1);
    const [size, digestOffset] = varint.decode(bytes$1.subarray(sizeOffset));
    const digest = bytes$1.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error('Incorrect length');
    }
    return new Digest(code, size, digest, bytes$1);
};
const equals = (a, b)=>{
    if (a === b) {
        return true;
    } else {
        return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);
    }
};
class Digest {
    constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}
exports.Digest = Digest;
exports.create = create;
exports.decode = decode;
exports.equals = equals;
}}),
"[project]/node_modules/multiformats/cjs/vendor/base-x.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while(pbegin !== pend){
            var carry = source[pbegin];
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === ' ') {
            return;
        }
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while(source[psz]){
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        if (source[psz] === ' ') {
            return;
        }
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
module.exports = _brrp__multiformats_scope_baseX;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var baseX$1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/vendor/base-x.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
class Encoder {
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
class Decoder {
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        } else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
            return decoder.decode(input);
        } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
const or = (left, right)=>new ComposedDecoder({
        ...left.decoders || {
            [left.prefix]: left
        },
        ...right.decoders || {
            [right.prefix]: right
        }
    });
class Codec {
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
const from = ({ name, prefix, encode, decode })=>new Codec(name, prefix, encode, decode);
const baseX = ({ prefix, name, alphabet })=>{
    const { encode, decode } = baseX$1(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>bytes.coerce(decode(text))
    });
};
const decode = (string, alphabet, bitsPerChar, name)=>{
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i){
        codes[alphabet[i]] = i;
    }
    let end = string.length;
    while(string[end - 1] === '='){
        --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for(let i = 0; i < end; ++i){
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
        }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
};
const encode = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0;
    let buffer = 0;
    for(let i = 0; i < data.length; ++i){
        buffer = buffer << 8 | data[i];
        bits += 8;
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
        while(out.length * bitsPerChar & 7){
            out += '=';
        }
    }
    return out;
};
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet })=>{
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
};
exports.Codec = Codec;
exports.baseX = baseX;
exports.from = from;
exports.or = or;
exports.rfc4648 = rfc4648;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base58.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base58btc = base.baseX({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = base.baseX({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});
exports.base58btc = base58btc;
exports.base58flickr = base58flickr;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base32.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base32 = base.rfc4648({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
const base32upper = base.rfc4648({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
const base32pad = base.rfc4648({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
const base32padupper = base.rfc4648({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
const base32hex = base.rfc4648({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
const base32hexupper = base.rfc4648({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
const base32hexpad = base.rfc4648({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
const base32hexpadupper = base.rfc4648({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
const base32z = base.rfc4648({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
});
exports.base32 = base32;
exports.base32hex = base32hex;
exports.base32hexpad = base32hexpad;
exports.base32hexpadupper = base32hexpadupper;
exports.base32hexupper = base32hexupper;
exports.base32pad = base32pad;
exports.base32padupper = base32padupper;
exports.base32upper = base32upper;
exports.base32z = base32z;
}}),
"[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var varint = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/varint.js [app-ssr] (ecmascript)");
var digest = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/digest.js [app-ssr] (ecmascript)");
var base58 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base58.js [app-ssr] (ecmascript)");
var base32 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base32.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
class CID {
    constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = new Map();
        Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
        });
    }
    toV0() {
        switch(this.version){
            case 0:
                {
                    return this;
                }
            default:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) {
                        throw new Error('Cannot convert a non dag-pb CID to CIDv0');
                    }
                    if (multihash.code !== SHA_256_CODE) {
                        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
                    }
                    return CID.createV0(multihash);
                }
        }
    }
    toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest: digest$1 } = this.multihash;
                    const multihash = digest.create(code, digest$1);
                    return CID.createV1(this.code, multihash);
                }
            case 1:
                {
                    return this;
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
                }
        }
    }
    equals(other) {
        return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);
    }
    toString(base) {
        const { bytes, version, _baseCache } = this;
        switch(version){
            case 0:
                return toStringV0(bytes, _baseCache, base || base58.base58btc.encoder);
            default:
                return toStringV1(bytes, _baseCache, base || base32.base32.encoder);
        }
    }
    toJSON() {
        return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
        };
    }
    get [Symbol.toStringTag]() {
        return 'CID';
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return 'CID(' + this.toString() + ')';
    }
    static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
    }
    get toBaseEncodedString() {
        throw new Error('Deprecated, use .toString()');
    }
    get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
        throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');
    }
    get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
        throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
        if (value instanceof CID) {
            return value;
        } else if (value != null && value.asCID === value) {
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
            const { version, multihash, code } = value;
            const digest$1 = digest.decode(multihash);
            return CID.create(version, code, digest$1);
        } else {
            return null;
        }
    }
    static create(version, code, digest) {
        if (typeof code !== 'number') {
            throw new Error('String codecs are no longer supported');
        }
        switch(version){
            case 0:
                {
                    if (code !== DAG_PB_CODE) {
                        throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                    } else {
                        return new CID(version, code, digest, digest.bytes);
                    }
                }
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                {
                    throw new Error('Invalid version');
                }
        }
    }
    static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
            throw new Error('Incorrect length');
        }
        return cid;
    }
    static decodeFirst(bytes$1) {
        const specs = CID.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error('Incorrect length');
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest$1) : CID.createV1(specs.codec, digest$1);
        return [
            cid,
            bytes$1.subarray(specs.size)
        ];
    }
    static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length] = varint.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            version = 0;
            offset = 0;
        } else if (version === 1) {
            codec = next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
    }
}
const parseCIDtoBytes = (source, base)=>{
    switch(source[0]){
        case 'Q':
            {
                const decoder = base || base58.base58btc;
                return [
                    base58.base58btc.prefix,
                    decoder.decode(`${base58.base58btc.prefix}${source}`)
                ];
            }
        case base58.base58btc.prefix:
            {
                const decoder = base || base58.base58btc;
                return [
                    base58.base58btc.prefix,
                    decoder.decode(source)
                ];
            }
        case base32.base32.prefix:
            {
                const decoder = base || base32.base32;
                return [
                    base32.base32.prefix,
                    decoder.decode(source)
                ];
            }
        default:
            {
                if (base == null) {
                    throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
                }
                return [
                    source[0],
                    base.decode(source)
                ];
            }
    }
};
const toStringV0 = (bytes, cache, base)=>{
    const { prefix } = base;
    if (prefix !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    }
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
};
const toStringV1 = (bytes, cache, base)=>{
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version, code, multihash)=>{
    const codeOffset = varint.encodingLength(version);
    const hashOffset = codeOffset + varint.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    varint.encodeTo(version, bytes, 0);
    varint.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
};
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
const readonly = {
    writable: false,
    configurable: false,
    enumerable: true
};
const hidden = {
    writable: false,
    enumerable: false,
    configurable: false
};
const version = '0.0.0-dev';
const deprecate = (range, message)=>{
    if (range.test(version)) {
        console.warn(message);
    } else {
        throw new Error(message);
    }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
exports.CID = CID;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/identity.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
const identity = base.from({
    prefix: '\0',
    name: 'identity',
    encode: (buf)=>bytes.toString(buf),
    decode: (str)=>bytes.fromString(str)
});
exports.identity = identity;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base2.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base2 = base.rfc4648({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
});
exports.base2 = base2;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base8.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base8 = base.rfc4648({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
});
exports.base8 = base8;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base10.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base10 = base.baseX({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
});
exports.base10 = base10;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base16.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base16 = base.rfc4648({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
});
const base16upper = base.rfc4648({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
});
exports.base16 = base16;
exports.base16upper = base16upper;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base36.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base36 = base.baseX({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = base.baseX({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});
exports.base36 = base36;
exports.base36upper = base36upper;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const base64 = base.rfc4648({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = base.rfc4648({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = base.rfc4648({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = base.rfc4648({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
});
exports.base64 = base64;
exports.base64pad = base64pad;
exports.base64url = base64url;
exports.base64urlpad = base64urlpad;
}}),
"[project]/node_modules/multiformats/cjs/src/bases/base256emoji.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var base = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base.js [app-ssr] (ecmascript)");
const alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42');
const alphabetBytesToChars = alphabet.reduce((p, c, i)=>{
    p[i] = c;
    return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i)=>{
    p[c.codePointAt(0)] = i;
    return p;
}, []);
function encode(data) {
    return data.reduce((p, c)=>{
        p += alphabetBytesToChars[c];
        return p;
    }, '');
}
function decode(str) {
    const byts = [];
    for (const char of str){
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) {
            throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = base.from({
    prefix: '\uD83D\uDE80',
    name: 'base256emoji',
    encode,
    decode
});
exports.base256emoji = base256emoji;
}}),
"[project]/node_modules/multiformats/cjs/src/hashes/hasher.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var digest = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/digest.js [app-ssr] (ecmascript)");
const from = ({ name, code, encode })=>new Hasher(name, code, encode);
class Hasher {
    constructor(name, code, encode){
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? digest.create(this.code, result) : result.then((digest$1)=>digest.create(this.code, digest$1));
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
exports.Hasher = Hasher;
exports.from = from;
}}),
"[project]/node_modules/multiformats/cjs/src/hashes/sha2.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var crypto = __turbopack_require__("[externals]/crypto [external] (crypto, cjs)");
var hasher = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/hasher.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
        'default': e
    };
}
var crypto__default = /*#__PURE__*/ _interopDefaultLegacy(crypto);
const sha256 = hasher.from({
    name: 'sha2-256',
    code: 18,
    encode: (input)=>bytes.coerce(crypto__default["default"].createHash('sha256').update(input).digest())
});
const sha512 = hasher.from({
    name: 'sha2-512',
    code: 19,
    encode: (input)=>bytes.coerce(crypto__default["default"].createHash('sha512').update(input).digest())
});
exports.sha256 = sha256;
exports.sha512 = sha512;
}}),
"[project]/node_modules/multiformats/cjs/src/hashes/identity.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
var digest$1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/digest.js [app-ssr] (ecmascript)");
const code = 0;
const name = 'identity';
const encode = bytes.coerce;
const digest = (input)=>digest$1.create(code, encode(input));
const identity = {
    code,
    name,
    encode,
    digest
};
exports.identity = identity;
}}),
"[project]/node_modules/multiformats/cjs/src/codecs/raw.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
const name = 'raw';
const code = 85;
const encode = (node)=>bytes.coerce(node);
const decode = (data)=>bytes.coerce(data);
exports.code = code;
exports.decode = decode;
exports.encode = encode;
exports.name = name;
}}),
"[project]/node_modules/multiformats/cjs/src/codecs/json.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 512;
const encode = (node)=>textEncoder.encode(JSON.stringify(node));
const decode = (data)=>JSON.parse(textDecoder.decode(data));
exports.code = code;
exports.decode = decode;
exports.encode = encode;
exports.name = name;
}}),
"[project]/node_modules/multiformats/cjs/src/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var cid = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
var varint = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/varint.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
var hasher = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/hasher.js [app-ssr] (ecmascript)");
var digest = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/digest.js [app-ssr] (ecmascript)");
exports.CID = cid.CID;
exports.varint = varint;
exports.bytes = bytes;
exports.hasher = hasher;
exports.digest = digest;
}}),
"[project]/node_modules/multiformats/cjs/src/basics.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var identity = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/identity.js [app-ssr] (ecmascript)");
var base2 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base2.js [app-ssr] (ecmascript)");
var base8 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base8.js [app-ssr] (ecmascript)");
var base10 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base10.js [app-ssr] (ecmascript)");
var base16 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base16.js [app-ssr] (ecmascript)");
var base32 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base32.js [app-ssr] (ecmascript)");
var base36 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base36.js [app-ssr] (ecmascript)");
var base58 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base58.js [app-ssr] (ecmascript)");
var base64 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
var base256emoji = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base256emoji.js [app-ssr] (ecmascript)");
var sha2 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/sha2.js [app-ssr] (ecmascript)");
var identity$1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/identity.js [app-ssr] (ecmascript)");
var raw = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/codecs/raw.js [app-ssr] (ecmascript)");
var json = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/codecs/json.js [app-ssr] (ecmascript)");
__turbopack_require__("[project]/node_modules/multiformats/cjs/src/index.js [app-ssr] (ecmascript)");
var cid = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/cid.js [app-ssr] (ecmascript)");
var hasher = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/hasher.js [app-ssr] (ecmascript)");
var digest = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/hashes/digest.js [app-ssr] (ecmascript)");
var varint = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/varint.js [app-ssr] (ecmascript)");
var bytes = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bytes.js [app-ssr] (ecmascript)");
const bases = {
    ...identity,
    ...base2,
    ...base8,
    ...base10,
    ...base16,
    ...base32,
    ...base36,
    ...base58,
    ...base64,
    ...base256emoji
};
const hashes = {
    ...sha2,
    ...identity$1
};
const codecs = {
    raw,
    json
};
exports.CID = cid.CID;
exports.hasher = hasher;
exports.digest = digest;
exports.varint = varint;
exports.bytes = bytes;
exports.bases = bases;
exports.codecs = codecs;
exports.hashes = hashes;
}}),
"[project]/node_modules/uint8arrays/cjs/src/compare.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
}
exports.compare = compare;
}}),
"[project]/node_modules/uint8arrays/cjs/src/concat.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
function concat(arrays, length) {
    if (!length) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return output;
}
exports.concat = concat;
}}),
"[project]/node_modules/uint8arrays/cjs/src/equals.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equals = equals;
}}),
"[project]/node_modules/uint8arrays/cjs/src/util/bases.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
var basics = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/basics.js [app-ssr] (ecmascript)");
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: basics.bases.base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii,
    ...basics.bases
};
module.exports = BASES;
}}),
"[project]/node_modules/uint8arrays/cjs/src/from-string.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var bases = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/util/bases.js [app-ssr] (ecmascript)");
function fromString(string, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base.decoder.decode(`${base.prefix}${string}`);
}
exports.fromString = fromString;
}}),
"[project]/node_modules/uint8arrays/cjs/src/to-string.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var bases = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/util/bases.js [app-ssr] (ecmascript)");
function toString(array, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base.encoder.encode(array).substring(1);
}
exports.toString = toString;
}}),
"[project]/node_modules/uint8arrays/cjs/src/xor.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
function xor(a, b) {
    if (a.length !== b.length) {
        throw new Error('Inputs should have the same length');
    }
    const result = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++){
        result[i] = a[i] ^ b[i];
    }
    return result;
}
exports.xor = xor;
}}),
"[project]/node_modules/uint8arrays/cjs/src/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var compare = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/compare.js [app-ssr] (ecmascript)");
var concat = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/concat.js [app-ssr] (ecmascript)");
var equals = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/equals.js [app-ssr] (ecmascript)");
var fromString = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/from-string.js [app-ssr] (ecmascript)");
var toString = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/to-string.js [app-ssr] (ecmascript)");
var xor = __turbopack_require__("[project]/node_modules/uint8arrays/cjs/src/xor.js [app-ssr] (ecmascript)");
exports.compare = compare.compare;
exports.concat = concat.concat;
exports.equals = equals.equals;
exports.fromString = fromString.fromString;
exports.toString = toString.toString;
exports.xor = xor.xor;
}}),
"[project]/node_modules/iso-datestring-validator/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        d: (t, r)=>{
            for(var n in r)e.o(r, n) && !e.o(t, n) && Object.defineProperty(t, n, {
                enumerable: !0,
                get: r[n]
            });
        },
        o: (e, t)=>Object.prototype.hasOwnProperty.call(e, t),
        r: (e)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        }
    }, t = {};
    function r(e, t) {
        return void 0 === t && (t = "-"), new RegExp("^(?!0{4}" + t + "0{2}" + t + "0{2})((?=[0-9]{4}" + t + "(((0[^2])|1[0-2])|02(?=" + t + "(([0-1][0-9])|2[0-8])))" + t + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t + "02" + t + "29))([0-9]{4})" + t + "(?!((0[469])|11)" + t + "31)((0[1,3-9]|1[0-2])|(02(?!" + t + "3)))" + t + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e);
    }
    function n(e) {
        var t = /\D/.exec(e);
        return t ? t[0] : "";
    }
    function i(e, t, r) {
        void 0 === t && (t = ":"), void 0 === r && (r = !1);
        var i = new RegExp("^([0-1]|2(?=([0-3])|4" + t + "00))[0-9]" + t + "[0-5][0-9](" + t + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
        if (!r || !/[Z+\-]/.test(e)) return i.test(e);
        if (/Z$/.test(e)) return i.test(e.replace("Z", ""));
        var o = e.includes("+"), a = e.split(/[+-]/), u = a[0], d = a[1];
        return i.test(u) && function(e, t, r) {
            return void 0 === r && (r = ":"), new RegExp(t ? "^(0(?!(2" + r + "4)|0" + r + "3)|1(?=([0-1]|2(?=" + r + "[04])|[34](?=" + r + "0))))([03469](?=" + r + "[03])|[17](?=" + r + "0)|2(?=" + r + "[04])|5(?=" + r + "[034])|8(?=" + r + "[04]))" + r + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r + "[03])|[0-24-8](?=" + r + "00))" + r + "[03]0$").test(e);
        }(d, o, n(d));
    }
    function o(e) {
        var t = e.split("T"), o = t[0], a = t[1], u = r(o, n(o));
        if (!a) return !1;
        var d, s = (d = a.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d) ? d[0] : "");
        return u && i(a, s, !0);
    }
    function a(e, t) {
        return void 0 === t && (t = "-"), new RegExp("^[0-9]{4}" + t + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e);
    }
    e.r(t), e.d(t, {
        isValidDate: ()=>r,
        isValidISODateString: ()=>o,
        isValidTime: ()=>i,
        isValidYearMonth: ()=>a
    });
    var u = exports;
    for(var d in t)u[d] = t[d];
    t.__esModule && Object.defineProperty(u, "__esModule", {
        value: !0
    });
})();
}}),
"[project]/node_modules/@atproto/xrpc/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XRPCInvalidResponseError = exports.XRPCError = exports.XRPCResponse = exports.ResponseTypeStrings = exports.ResponseTypeNames = exports.ResponseType = exports.errorResponseBody = void 0;
exports.httpResponseCodeToEnum = httpResponseCodeToEnum;
exports.httpResponseCodeToName = httpResponseCodeToName;
exports.httpResponseCodeToString = httpResponseCodeToString;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.errorResponseBody = zod_1.z.object({
    error: zod_1.z.string().optional(),
    message: zod_1.z.string().optional()
});
var ResponseType;
(function(ResponseType) {
    ResponseType[ResponseType["Unknown"] = 1] = "Unknown";
    ResponseType[ResponseType["InvalidResponse"] = 2] = "InvalidResponse";
    ResponseType[ResponseType["Success"] = 200] = "Success";
    ResponseType[ResponseType["InvalidRequest"] = 400] = "InvalidRequest";
    ResponseType[ResponseType["AuthRequired"] = 401] = "AuthRequired";
    ResponseType[ResponseType["Forbidden"] = 403] = "Forbidden";
    ResponseType[ResponseType["XRPCNotSupported"] = 404] = "XRPCNotSupported";
    ResponseType[ResponseType["NotAcceptable"] = 406] = "NotAcceptable";
    ResponseType[ResponseType["PayloadTooLarge"] = 413] = "PayloadTooLarge";
    ResponseType[ResponseType["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    ResponseType[ResponseType["RateLimitExceeded"] = 429] = "RateLimitExceeded";
    ResponseType[ResponseType["InternalServerError"] = 500] = "InternalServerError";
    ResponseType[ResponseType["MethodNotImplemented"] = 501] = "MethodNotImplemented";
    ResponseType[ResponseType["UpstreamFailure"] = 502] = "UpstreamFailure";
    ResponseType[ResponseType["NotEnoughResources"] = 503] = "NotEnoughResources";
    ResponseType[ResponseType["UpstreamTimeout"] = 504] = "UpstreamTimeout";
})(ResponseType || (exports.ResponseType = ResponseType = {}));
function httpResponseCodeToEnum(status) {
    if (status in ResponseType) {
        return status;
    } else if (status >= 100 && status < 200) {
        return ResponseType.XRPCNotSupported;
    } else if (status >= 200 && status < 300) {
        return ResponseType.Success;
    } else if (status >= 300 && status < 400) {
        return ResponseType.XRPCNotSupported;
    } else if (status >= 400 && status < 500) {
        return ResponseType.InvalidRequest;
    } else {
        return ResponseType.InternalServerError;
    }
}
exports.ResponseTypeNames = {
    [ResponseType.Unknown]: 'Unknown',
    [ResponseType.InvalidResponse]: 'InvalidResponse',
    [ResponseType.Success]: 'Success',
    [ResponseType.InvalidRequest]: 'InvalidRequest',
    [ResponseType.AuthRequired]: 'AuthenticationRequired',
    [ResponseType.Forbidden]: 'Forbidden',
    [ResponseType.XRPCNotSupported]: 'XRPCNotSupported',
    [ResponseType.PayloadTooLarge]: 'PayloadTooLarge',
    [ResponseType.UnsupportedMediaType]: 'UnsupportedMediaType',
    [ResponseType.RateLimitExceeded]: 'RateLimitExceeded',
    [ResponseType.InternalServerError]: 'InternalServerError',
    [ResponseType.MethodNotImplemented]: 'MethodNotImplemented',
    [ResponseType.UpstreamFailure]: 'UpstreamFailure',
    [ResponseType.NotEnoughResources]: 'NotEnoughResources',
    [ResponseType.UpstreamTimeout]: 'UpstreamTimeout'
};
function httpResponseCodeToName(status) {
    return exports.ResponseTypeNames[httpResponseCodeToEnum(status)];
}
exports.ResponseTypeStrings = {
    [ResponseType.Unknown]: 'Unknown',
    [ResponseType.InvalidResponse]: 'Invalid Response',
    [ResponseType.Success]: 'Success',
    [ResponseType.InvalidRequest]: 'Invalid Request',
    [ResponseType.AuthRequired]: 'Authentication Required',
    [ResponseType.Forbidden]: 'Forbidden',
    [ResponseType.XRPCNotSupported]: 'XRPC Not Supported',
    [ResponseType.PayloadTooLarge]: 'Payload Too Large',
    [ResponseType.UnsupportedMediaType]: 'Unsupported Media Type',
    [ResponseType.RateLimitExceeded]: 'Rate Limit Exceeded',
    [ResponseType.InternalServerError]: 'Internal Server Error',
    [ResponseType.MethodNotImplemented]: 'Method Not Implemented',
    [ResponseType.UpstreamFailure]: 'Upstream Failure',
    [ResponseType.NotEnoughResources]: 'Not Enough Resources',
    [ResponseType.UpstreamTimeout]: 'Upstream Timeout'
};
function httpResponseCodeToString(status) {
    return exports.ResponseTypeStrings[httpResponseCodeToEnum(status)];
}
class XRPCResponse {
    constructor(data, headers){
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: data
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
        });
        Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
    }
}
exports.XRPCResponse = XRPCResponse;
class XRPCError extends Error {
    constructor(statusCode, error = httpResponseCodeToName(statusCode), message, headers, options){
        super(message || error || httpResponseCodeToString(statusCode), options);
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: error
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
        });
        Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.status = httpResponseCodeToEnum(statusCode);
        // Pre 2022 runtimes won't handle the "options" constructor argument
        const cause = options?.cause;
        if (this.cause === undefined && cause !== undefined) {
            this.cause = cause;
        }
    }
    static from(cause, fallbackStatus) {
        if (cause instanceof XRPCError) {
            return cause;
        }
        // Type cast the cause to an Error if it is one
        const causeErr = cause instanceof Error ? cause : undefined;
        // Try and find a Response object in the cause
        const causeResponse = cause instanceof Response ? cause : cause?.['response'] instanceof Response ? cause['response'] : undefined;
        const statusCode = // Extract status code from "http-errors" like errors
        causeErr?.['statusCode'] ?? causeErr?.['status'] ?? // Use the status code from the response object as fallback
        causeResponse?.status;
        // Convert the status code to a ResponseType
        const status = typeof statusCode === 'number' ? httpResponseCodeToEnum(statusCode) : fallbackStatus ?? ResponseType.Unknown;
        const message = causeErr?.message ?? String(cause);
        const headers = causeResponse ? Object.fromEntries(causeResponse.headers.entries()) : undefined;
        return new XRPCError(status, undefined, message, headers, {
            cause
        });
    }
}
exports.XRPCError = XRPCError;
class XRPCInvalidResponseError extends XRPCError {
    constructor(lexiconNsid, validationError, responseBody){
        super(ResponseType.InvalidResponse, exports.ResponseTypeStrings[ResponseType.InvalidResponse], `The server gave an invalid response and may be out of date.`, undefined, {
            cause: validationError
        });
        Object.defineProperty(this, "lexiconNsid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lexiconNsid
        });
        Object.defineProperty(this, "validationError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: validationError
        });
        Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: responseBody
        });
    }
}
exports.XRPCInvalidResponseError = XRPCInvalidResponseError; //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isErrorResponseBody = isErrorResponseBody;
exports.getMethodSchemaHTTPMethod = getMethodSchemaHTTPMethod;
exports.constructMethodCallUri = constructMethodCallUri;
exports.constructMethodCallUrl = constructMethodCallUrl;
exports.encodeQueryParam = encodeQueryParam;
exports.constructMethodCallHeaders = constructMethodCallHeaders;
exports.combineHeaders = combineHeaders;
exports.isBodyInit = isBodyInit;
exports.isIterable = isIterable;
exports.encodeMethodCallBody = encodeMethodCallBody;
exports.httpResponseBodyParse = httpResponseBodyParse;
const lexicon_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/index.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/types.js [app-ssr] (ecmascript)");
const ReadableStream = globalThis.ReadableStream || class {
    constructor(){
        // This anonymous class will never pass any "instanceof" check and cannot
        // be instantiated.
        throw new Error('ReadableStream is not supported in this environment');
    }
};
function isErrorResponseBody(v) {
    return types_1.errorResponseBody.safeParse(v).success;
}
function getMethodSchemaHTTPMethod(schema) {
    if (schema.type === 'procedure') {
        return 'post';
    }
    return 'get';
}
function constructMethodCallUri(nsid, schema, serviceUri, params) {
    const uri = new URL(constructMethodCallUrl(nsid, schema, params), serviceUri);
    return uri.toString();
}
function constructMethodCallUrl(nsid, schema, params) {
    const pathname = `/xrpc/${encodeURIComponent(nsid)}`;
    if (!params) return pathname;
    const searchParams = [];
    for (const [key, value] of Object.entries(params)){
        const paramSchema = schema.parameters?.properties?.[key];
        if (!paramSchema) {
            throw new Error(`Invalid query parameter: ${key}`);
        }
        if (value !== undefined) {
            if (paramSchema.type === 'array') {
                const values = Array.isArray(value) ? value : [
                    value
                ];
                for (const val of values){
                    searchParams.push([
                        key,
                        encodeQueryParam(paramSchema.items.type, val)
                    ]);
                }
            } else {
                searchParams.push([
                    key,
                    encodeQueryParam(paramSchema.type, value)
                ]);
            }
        }
    }
    if (!searchParams.length) return pathname;
    return `${pathname}?${new URLSearchParams(searchParams).toString()}`;
}
function encodeQueryParam(type, value) {
    if (type === 'string' || type === 'unknown') {
        return String(value);
    }
    if (type === 'float') {
        return String(Number(value));
    } else if (type === 'integer') {
        return String(Number(value) | 0);
    } else if (type === 'boolean') {
        return value ? 'true' : 'false';
    } else if (type === 'datetime') {
        if (value instanceof Date) {
            return value.toISOString();
        }
        return String(value);
    }
    throw new Error(`Unsupported query param type: ${type}`);
}
function constructMethodCallHeaders(schema, data, opts) {
    // Not using `new Headers(opts?.headers)` to avoid duplicating headers values
    // due to inconsistent casing in headers name. In case of multiple headers
    // with the same name (but using a different case), the last one will be used.
    // new Headers({ 'content-type': 'foo', 'Content-Type': 'bar' }).get('content-type')
    // => 'foo, bar'
    const headers = new Headers();
    if (opts?.headers) {
        for(const name in opts.headers){
            if (headers.has(name)) {
                throw new TypeError(`Duplicate header: ${name}`);
            }
            const value = opts.headers[name];
            if (value != null) {
                headers.set(name, value);
            }
        }
    }
    if (schema.type === 'procedure') {
        if (opts?.encoding) {
            headers.set('content-type', opts.encoding);
        } else if (!headers.has('content-type') && typeof data !== 'undefined') {
            // Special handling of BodyInit types before falling back to JSON encoding
            if (data instanceof ArrayBuffer || data instanceof ReadableStream || ArrayBuffer.isView(data)) {
                headers.set('content-type', 'application/octet-stream');
            } else if (data instanceof FormData) {
                // Note: The multipart form data boundary is missing from the header
                // we set here, making that header invalid. This special case will be
                // handled in encodeMethodCallBody()
                headers.set('content-type', 'multipart/form-data');
            } else if (data instanceof URLSearchParams) {
                headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            } else if (isBlobLike(data)) {
                headers.set('content-type', data.type || 'application/octet-stream');
            } else if (typeof data === 'string') {
                headers.set('content-type', 'text/plain;charset=UTF-8');
            } else if (isIterable(data)) {
                headers.set('content-type', 'application/octet-stream');
            } else if (typeof data === 'boolean' || typeof data === 'number' || typeof data === 'string' || typeof data === 'object' // covers "null"
            ) {
                headers.set('content-type', 'application/json');
            } else {
                // symbol, function, bigint
                throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unsupported data type: ${typeof data}`);
            }
        }
    }
    return headers;
}
function combineHeaders(headersInit, defaultHeaders) {
    if (!defaultHeaders) return headersInit;
    let headers = undefined;
    for (const [name, definition] of defaultHeaders){
        // Ignore undefined values (allowed for convenience when using
        // Object.entries).
        if (definition === undefined) continue;
        // Lazy initialization of the headers object
        headers ?? (headers = new Headers(headersInit));
        if (headers.has(name)) continue;
        const value = typeof definition === 'function' ? definition() : definition;
        if (typeof value === 'string') headers.set(name, value);
        else if (value === null) headers.delete(name);
        else throw new TypeError(`Invalid "${name}" header value: ${typeof value}`);
    }
    return headers ?? headersInit;
}
function isBlobLike(value) {
    if (value == null) return false;
    if (typeof value !== 'object') return false;
    if (typeof Blob === 'function' && value instanceof Blob) return true;
    // Support for Blobs provided by libraries that don't use the native Blob
    // (e.g. fetch-blob from node-fetch).
    // https://github.com/node-fetch/fetch-blob/blob/a1a182e5978811407bef4ea1632b517567dda01f/index.js#L233-L244
    const tag = value[Symbol.toStringTag];
    if (tag === 'Blob' || tag === 'File') {
        return 'stream' in value && typeof value.stream === 'function';
    }
    return false;
}
function isBodyInit(value) {
    switch(typeof value){
        case 'string':
            return true;
        case 'object':
            return value instanceof ArrayBuffer || value instanceof FormData || value instanceof URLSearchParams || value instanceof ReadableStream || ArrayBuffer.isView(value) || isBlobLike(value);
        default:
            return false;
    }
}
function isIterable(value) {
    return value != null && typeof value === 'object' && (Symbol.iterator in value || Symbol.asyncIterator in value);
}
function encodeMethodCallBody(headers, data) {
    // Silently ignore the body if there is no content-type header.
    const contentType = headers.get('content-type');
    if (!contentType) {
        return undefined;
    }
    if (typeof data === 'undefined') {
        // This error would be returned by the server, but we can catch it earlier
        // to avoid un-necessary requests. Note that a content-length of 0 does not
        // necessary mean that the body is "empty" (e.g. an empty txt file).
        throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `A request body is expected but none was provided`);
    }
    if (isBodyInit(data)) {
        if (data instanceof FormData && contentType === 'multipart/form-data') {
            // fetch() will encode FormData payload itself, but it won't override the
            // content-type header if already present. This would cause the boundary
            // to be missing from the content-type header, resulting in a 400 error.
            // Deleting the content-type header here to let fetch() re-create it.
            headers.delete('content-type');
        }
        // Will be encoded by the fetch API.
        return data;
    }
    if (isIterable(data)) {
        // Note that some environments support using Iterable & AsyncIterable as the
        // body (e.g. Node's fetch), but not all of them do (browsers).
        return iterableToReadableStream(data);
    }
    if (contentType.startsWith('text/')) {
        return new TextEncoder().encode(String(data));
    }
    if (contentType.startsWith('application/json')) {
        const json = (0, lexicon_1.stringifyLex)(data);
        // Server would return a 400 error if the JSON is invalid (e.g. trying to
        // JSONify a function, or an object that implements toJSON() poorly).
        if (json === undefined) {
            throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Failed to encode request body as JSON`);
        }
        return new TextEncoder().encode(json);
    }
    // At this point, "data" is not a valid BodyInit value, and we don't know how
    // to encode it into one. Passing it to fetch would result in an error. Let's
    // throw our own error instead.
    const type = !data || typeof data !== 'object' ? typeof data : data.constructor !== Object && typeof data.constructor === 'function' && typeof data.constructor?.name === 'string' ? data.constructor.name : 'object';
    throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unable to encode ${type} as ${contentType} data`);
}
/**
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/from_static}
 */ function iterableToReadableStream(iterable) {
    // Use the native ReadableStream.from() if available.
    if ('from' in ReadableStream && typeof ReadableStream.from === 'function') {
        return ReadableStream.from(iterable);
    }
    // If you see this error, consider using a polyfill for ReadableStream. For
    // example, the "web-streams-polyfill" package:
    // https://github.com/MattiasBuelens/web-streams-polyfill
    throw new TypeError('ReadableStream.from() is not supported in this environment. ' + 'It is required to support using iterables as the request body. ' + 'Consider using a polyfill or re-write your code to use a different body type.');
}
function httpResponseBodyParse(mimeType, data) {
    try {
        if (mimeType) {
            if (mimeType.includes('application/json')) {
                const str = new TextDecoder().decode(data);
                return (0, lexicon_1.jsonStringToLex)(str);
            }
            if (mimeType.startsWith('text/')) {
                return new TextDecoder().decode(data);
            }
        }
        if (data instanceof ArrayBuffer) {
            return new Uint8Array(data);
        }
        return data;
    } catch (cause) {
        throw new types_1.XRPCError(types_1.ResponseType.InvalidResponse, undefined, `Failed to parse response body: ${String(cause)}`, undefined, {
            cause
        });
    }
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/fetch-handler.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildFetchHandler = buildFetchHandler;
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-ssr] (ecmascript)");
function buildFetchHandler(options) {
    // Already a fetch handler (allowed for convenience)
    if (typeof options === 'function') return options;
    if (typeof options === 'object' && 'fetchHandler' in options) {
        return options.fetchHandler.bind(options);
    }
    const { service, headers: defaultHeaders = undefined, fetch = globalThis.fetch } = typeof options === 'string' || options instanceof URL ? {
        service: options
    } : options;
    if (typeof fetch !== 'function') {
        throw new TypeError('XrpcDispatcher requires fetch() to be available in your environment.');
    }
    const defaultHeadersEntries = defaultHeaders != null ? Object.entries(defaultHeaders) : undefined;
    return async function(url, init) {
        const base = typeof service === 'function' ? service() : service;
        const fullUrl = new URL(url, base);
        const headers = (0, util_1.combineHeaders)(init.headers, defaultHeadersEntries);
        return fetch(fullUrl, {
            ...init,
            headers
        });
    };
} //# sourceMappingURL=fetch-handler.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/xrpc-client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XrpcClient = void 0;
const lexicon_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/index.js [app-ssr] (ecmascript)");
const fetch_handler_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/fetch-handler.js [app-ssr] (ecmascript)");
const types_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/types.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-ssr] (ecmascript)");
class XrpcClient {
    constructor(fetchHandlerOpts, // "Lexicons" is redundant here (because that class implements
    // "Iterable<LexiconDoc>") but we keep it for explicitness:
    lex){
        Object.defineProperty(this, "fetchHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "lex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetchHandler = (0, fetch_handler_1.buildFetchHandler)(fetchHandlerOpts);
        this.lex = lex instanceof lexicon_1.Lexicons ? lex : new lexicon_1.Lexicons(lex);
    }
    setHeader(key, value) {
        this.headers.set(key.toLowerCase(), value);
    }
    unsetHeader(key) {
        this.headers.delete(key.toLowerCase());
    }
    clearHeaders() {
        this.headers.clear();
    }
    async call(methodNsid, params, data, opts) {
        const def = this.lex.getDefOrThrow(methodNsid);
        if (!def || def.type !== 'query' && def.type !== 'procedure') {
            throw new TypeError(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
        }
        // @TODO: should we validate the params and data here?
        // this.lex.assertValidXrpcParams(methodNsid, params)
        // if (data !== undefined) {
        //   this.lex.assertValidXrpcInput(methodNsid, data)
        // }
        const reqUrl = (0, util_1.constructMethodCallUrl)(methodNsid, def, params);
        const reqMethod = (0, util_1.getMethodSchemaHTTPMethod)(def);
        const reqHeaders = (0, util_1.constructMethodCallHeaders)(def, data, opts);
        const reqBody = (0, util_1.encodeMethodCallBody)(reqHeaders, data);
        // The duplex field is required for streaming bodies, but not yet reflected
        // anywhere in docs or types. See whatwg/fetch#1438, nodejs/node#46221.
        const init = {
            method: reqMethod,
            headers: (0, util_1.combineHeaders)(reqHeaders, this.headers),
            body: reqBody,
            duplex: 'half',
            signal: opts?.signal
        };
        try {
            const response = await this.fetchHandler.call(undefined, reqUrl, init);
            const resStatus = response.status;
            const resHeaders = Object.fromEntries(response.headers.entries());
            const resBodyBytes = await response.arrayBuffer();
            const resBody = (0, util_1.httpResponseBodyParse)(response.headers.get('content-type'), resBodyBytes);
            const resCode = (0, types_1.httpResponseCodeToEnum)(resStatus);
            if (resCode !== types_1.ResponseType.Success) {
                const { error = undefined, message = undefined } = resBody && (0, util_1.isErrorResponseBody)(resBody) ? resBody : {};
                throw new types_1.XRPCError(resCode, error, message, resHeaders);
            }
            try {
                this.lex.assertValidXrpcOutput(methodNsid, resBody);
            } catch (e) {
                if (e instanceof lexicon_1.ValidationError) {
                    throw new types_1.XRPCInvalidResponseError(methodNsid, e, resBody);
                }
                throw e;
            }
            return new types_1.XRPCResponse(resBody, resHeaders);
        } catch (err) {
            throw types_1.XRPCError.from(err);
        }
    }
}
exports.XrpcClient = XrpcClient; //# sourceMappingURL=xrpc-client.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceClient = exports.Client = void 0;
const lexicon_1 = __turbopack_require__("[project]/node_modules/@atproto/lexicon/dist/index.js [app-ssr] (ecmascript)");
const xrpc_client_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/xrpc-client.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-ssr] (ecmascript)");
/** @deprecated Use {@link XrpcClient} instead */ class Client {
    constructor(){
        Object.defineProperty(this, "lex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new lexicon_1.Lexicons()
        });
    }
    /** @deprecated */ get fetch() {
        throw new Error('Client.fetch is no longer supported. Use an XrpcClient instead.');
    }
    /** @deprecated */ set fetch(_) {
        throw new Error('Client.fetch is no longer supported. Use an XrpcClient instead.');
    }
    // method calls
    //
    async call(serviceUri, methodNsid, params, data, opts) {
        return this.service(serviceUri).call(methodNsid, params, data, opts);
    }
    service(serviceUri) {
        return new ServiceClient(this, serviceUri);
    }
    // schemas
    // =
    addLexicon(doc) {
        this.lex.add(doc);
    }
    addLexicons(docs) {
        for (const doc of docs){
            this.addLexicon(doc);
        }
    }
    removeLexicon(uri) {
        this.lex.remove(uri);
    }
}
exports.Client = Client;
/** @deprecated Use {@link XrpcClient} instead */ class ServiceClient extends xrpc_client_1.XrpcClient {
    constructor(baseClient, serviceUri){
        super(async (input, init)=>{
            const headers = (0, util_1.combineHeaders)(init.headers, Object.entries(this.headers));
            return fetch(new URL(input, this.uri), {
                ...init,
                headers
            });
        }, baseClient.lex);
        Object.defineProperty(this, "baseClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: baseClient
        });
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.uri = typeof serviceUri === 'string' ? new URL(serviceUri) : serviceUri;
    }
}
exports.ServiceClient = ServiceClient; //# sourceMappingURL=client.js.map
}}),
"[project]/node_modules/@atproto/xrpc/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/client.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/fetch-handler.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/util.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/xrpc-client.js [app-ssr] (ecmascript)"), exports);
const client_1 = __turbopack_require__("[project]/node_modules/@atproto/xrpc/dist/client.js [app-ssr] (ecmascript)");
/** @deprecated create a local {@link XrpcClient} instance instead */ const defaultInst = new client_1.Client();
exports.default = defaultInst; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/tlds/index.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("[\"aaa\",\"aarp\",\"abb\",\"abbott\",\"abbvie\",\"abc\",\"able\",\"abogado\",\"abudhabi\",\"ac\",\"academy\",\"accenture\",\"accountant\",\"accountants\",\"aco\",\"actor\",\"ad\",\"ads\",\"adult\",\"ae\",\"aeg\",\"aero\",\"aetna\",\"af\",\"afl\",\"africa\",\"ag\",\"agakhan\",\"agency\",\"ai\",\"aig\",\"airbus\",\"airforce\",\"airtel\",\"akdn\",\"al\",\"alibaba\",\"alipay\",\"allfinanz\",\"allstate\",\"ally\",\"alsace\",\"alstom\",\"am\",\"amazon\",\"americanexpress\",\"americanfamily\",\"amex\",\"amfam\",\"amica\",\"amsterdam\",\"analytics\",\"android\",\"anquan\",\"anz\",\"ao\",\"aol\",\"apartments\",\"app\",\"apple\",\"aq\",\"aquarelle\",\"ar\",\"arab\",\"aramco\",\"archi\",\"army\",\"arpa\",\"art\",\"arte\",\"as\",\"asda\",\"asia\",\"associates\",\"at\",\"athleta\",\"attorney\",\"au\",\"auction\",\"audi\",\"audible\",\"audio\",\"auspost\",\"author\",\"auto\",\"autos\",\"aw\",\"aws\",\"ax\",\"axa\",\"az\",\"azure\",\"ba\",\"baby\",\"baidu\",\"banamex\",\"band\",\"bank\",\"bar\",\"barcelona\",\"barclaycard\",\"barclays\",\"barefoot\",\"bargains\",\"baseball\",\"basketball\",\"bauhaus\",\"bayern\",\"bb\",\"bbc\",\"bbt\",\"bbva\",\"bcg\",\"bcn\",\"bd\",\"be\",\"beats\",\"beauty\",\"beer\",\"bentley\",\"berlin\",\"best\",\"bestbuy\",\"bet\",\"bf\",\"bg\",\"bh\",\"bharti\",\"bi\",\"bible\",\"bid\",\"bike\",\"bing\",\"bingo\",\"bio\",\"biz\",\"bj\",\"black\",\"blackfriday\",\"blockbuster\",\"blog\",\"bloomberg\",\"blue\",\"bm\",\"bms\",\"bmw\",\"bn\",\"bnpparibas\",\"bo\",\"boats\",\"boehringer\",\"bofa\",\"bom\",\"bond\",\"boo\",\"book\",\"booking\",\"bosch\",\"bostik\",\"boston\",\"bot\",\"boutique\",\"box\",\"br\",\"bradesco\",\"bridgestone\",\"broadway\",\"broker\",\"brother\",\"brussels\",\"bs\",\"bt\",\"build\",\"builders\",\"business\",\"buy\",\"buzz\",\"bv\",\"bw\",\"by\",\"bz\",\"bzh\",\"ca\",\"cab\",\"cafe\",\"cal\",\"call\",\"calvinklein\",\"cam\",\"camera\",\"camp\",\"canon\",\"capetown\",\"capital\",\"capitalone\",\"car\",\"caravan\",\"cards\",\"care\",\"career\",\"careers\",\"cars\",\"casa\",\"case\",\"cash\",\"casino\",\"cat\",\"catering\",\"catholic\",\"cba\",\"cbn\",\"cbre\",\"cc\",\"cd\",\"center\",\"ceo\",\"cern\",\"cf\",\"cfa\",\"cfd\",\"cg\",\"ch\",\"chanel\",\"channel\",\"charity\",\"chase\",\"chat\",\"cheap\",\"chintai\",\"christmas\",\"chrome\",\"church\",\"ci\",\"cipriani\",\"circle\",\"cisco\",\"citadel\",\"citi\",\"citic\",\"city\",\"ck\",\"cl\",\"claims\",\"cleaning\",\"click\",\"clinic\",\"clinique\",\"clothing\",\"cloud\",\"club\",\"clubmed\",\"cm\",\"cn\",\"co\",\"coach\",\"codes\",\"coffee\",\"college\",\"cologne\",\"com\",\"commbank\",\"community\",\"company\",\"compare\",\"computer\",\"comsec\",\"condos\",\"construction\",\"consulting\",\"contact\",\"contractors\",\"cooking\",\"cool\",\"coop\",\"corsica\",\"country\",\"coupon\",\"coupons\",\"courses\",\"cpa\",\"cr\",\"credit\",\"creditcard\",\"creditunion\",\"cricket\",\"crown\",\"crs\",\"cruise\",\"cruises\",\"cu\",\"cuisinella\",\"cv\",\"cw\",\"cx\",\"cy\",\"cymru\",\"cyou\",\"cz\",\"dad\",\"dance\",\"data\",\"date\",\"dating\",\"datsun\",\"day\",\"dclk\",\"dds\",\"de\",\"deal\",\"dealer\",\"deals\",\"degree\",\"delivery\",\"dell\",\"deloitte\",\"delta\",\"democrat\",\"dental\",\"dentist\",\"desi\",\"design\",\"dev\",\"dhl\",\"diamonds\",\"diet\",\"digital\",\"direct\",\"directory\",\"discount\",\"discover\",\"dish\",\"diy\",\"dj\",\"dk\",\"dm\",\"dnp\",\"do\",\"docs\",\"doctor\",\"dog\",\"domains\",\"dot\",\"download\",\"drive\",\"dtv\",\"dubai\",\"dunlop\",\"dupont\",\"durban\",\"dvag\",\"dvr\",\"dz\",\"earth\",\"eat\",\"ec\",\"eco\",\"edeka\",\"edu\",\"education\",\"ee\",\"eg\",\"email\",\"emerck\",\"energy\",\"engineer\",\"engineering\",\"enterprises\",\"epson\",\"equipment\",\"er\",\"ericsson\",\"erni\",\"es\",\"esq\",\"estate\",\"et\",\"eu\",\"eurovision\",\"eus\",\"events\",\"exchange\",\"expert\",\"exposed\",\"express\",\"extraspace\",\"fage\",\"fail\",\"fairwinds\",\"faith\",\"family\",\"fan\",\"fans\",\"farm\",\"farmers\",\"fashion\",\"fast\",\"fedex\",\"feedback\",\"ferrari\",\"ferrero\",\"fi\",\"fidelity\",\"fido\",\"film\",\"final\",\"finance\",\"financial\",\"fire\",\"firestone\",\"firmdale\",\"fish\",\"fishing\",\"fit\",\"fitness\",\"fj\",\"fk\",\"flickr\",\"flights\",\"flir\",\"florist\",\"flowers\",\"fly\",\"fm\",\"fo\",\"foo\",\"food\",\"football\",\"ford\",\"forex\",\"forsale\",\"forum\",\"foundation\",\"fox\",\"fr\",\"free\",\"fresenius\",\"frl\",\"frogans\",\"frontier\",\"ftr\",\"fujitsu\",\"fun\",\"fund\",\"furniture\",\"futbol\",\"fyi\",\"ga\",\"gal\",\"gallery\",\"gallo\",\"gallup\",\"game\",\"games\",\"gap\",\"garden\",\"gay\",\"gb\",\"gbiz\",\"gd\",\"gdn\",\"ge\",\"gea\",\"gent\",\"genting\",\"george\",\"gf\",\"gg\",\"ggee\",\"gh\",\"gi\",\"gift\",\"gifts\",\"gives\",\"giving\",\"gl\",\"glass\",\"gle\",\"global\",\"globo\",\"gm\",\"gmail\",\"gmbh\",\"gmo\",\"gmx\",\"gn\",\"godaddy\",\"gold\",\"goldpoint\",\"golf\",\"goo\",\"goodyear\",\"goog\",\"google\",\"gop\",\"got\",\"gov\",\"gp\",\"gq\",\"gr\",\"grainger\",\"graphics\",\"gratis\",\"green\",\"gripe\",\"grocery\",\"group\",\"gs\",\"gt\",\"gu\",\"gucci\",\"guge\",\"guide\",\"guitars\",\"guru\",\"gw\",\"gy\",\"hair\",\"hamburg\",\"hangout\",\"haus\",\"hbo\",\"hdfc\",\"hdfcbank\",\"health\",\"healthcare\",\"help\",\"helsinki\",\"here\",\"hermes\",\"hiphop\",\"hisamitsu\",\"hitachi\",\"hiv\",\"hk\",\"hkt\",\"hm\",\"hn\",\"hockey\",\"holdings\",\"holiday\",\"homedepot\",\"homegoods\",\"homes\",\"homesense\",\"honda\",\"horse\",\"hospital\",\"host\",\"hosting\",\"hot\",\"hotels\",\"hotmail\",\"house\",\"how\",\"hr\",\"hsbc\",\"ht\",\"hu\",\"hughes\",\"hyatt\",\"hyundai\",\"ibm\",\"icbc\",\"ice\",\"icu\",\"id\",\"ie\",\"ieee\",\"ifm\",\"ikano\",\"il\",\"im\",\"imamat\",\"imdb\",\"immo\",\"immobilien\",\"in\",\"inc\",\"industries\",\"infiniti\",\"info\",\"ing\",\"ink\",\"institute\",\"insurance\",\"insure\",\"int\",\"international\",\"intuit\",\"investments\",\"io\",\"ipiranga\",\"iq\",\"ir\",\"irish\",\"is\",\"ismaili\",\"ist\",\"istanbul\",\"it\",\"itau\",\"itv\",\"jaguar\",\"java\",\"jcb\",\"je\",\"jeep\",\"jetzt\",\"jewelry\",\"jio\",\"jll\",\"jm\",\"jmp\",\"jnj\",\"jo\",\"jobs\",\"joburg\",\"jot\",\"joy\",\"jp\",\"jpmorgan\",\"jprs\",\"juegos\",\"juniper\",\"kaufen\",\"kddi\",\"ke\",\"kerryhotels\",\"kerrylogistics\",\"kerryproperties\",\"kfh\",\"kg\",\"kh\",\"ki\",\"kia\",\"kids\",\"kim\",\"kindle\",\"kitchen\",\"kiwi\",\"km\",\"kn\",\"koeln\",\"komatsu\",\"kosher\",\"kp\",\"kpmg\",\"kpn\",\"kr\",\"krd\",\"kred\",\"kuokgroup\",\"kw\",\"ky\",\"kyoto\",\"kz\",\"la\",\"lacaixa\",\"lamborghini\",\"lamer\",\"lancaster\",\"land\",\"landrover\",\"lanxess\",\"lasalle\",\"lat\",\"latino\",\"latrobe\",\"law\",\"lawyer\",\"lb\",\"lc\",\"lds\",\"lease\",\"leclerc\",\"lefrak\",\"legal\",\"lego\",\"lexus\",\"lgbt\",\"li\",\"lidl\",\"life\",\"lifeinsurance\",\"lifestyle\",\"lighting\",\"like\",\"lilly\",\"limited\",\"limo\",\"lincoln\",\"link\",\"lipsy\",\"live\",\"living\",\"lk\",\"llc\",\"llp\",\"loan\",\"loans\",\"locker\",\"locus\",\"lol\",\"london\",\"lotte\",\"lotto\",\"love\",\"lpl\",\"lplfinancial\",\"lr\",\"ls\",\"lt\",\"ltd\",\"ltda\",\"lu\",\"lundbeck\",\"luxe\",\"luxury\",\"lv\",\"ly\",\"ma\",\"madrid\",\"maif\",\"maison\",\"makeup\",\"man\",\"management\",\"mango\",\"map\",\"market\",\"marketing\",\"markets\",\"marriott\",\"marshalls\",\"mattel\",\"mba\",\"mc\",\"mckinsey\",\"md\",\"me\",\"med\",\"media\",\"meet\",\"melbourne\",\"meme\",\"memorial\",\"men\",\"menu\",\"merckmsd\",\"mg\",\"mh\",\"miami\",\"microsoft\",\"mil\",\"mini\",\"mint\",\"mit\",\"mitsubishi\",\"mk\",\"ml\",\"mlb\",\"mls\",\"mm\",\"mma\",\"mn\",\"mo\",\"mobi\",\"mobile\",\"moda\",\"moe\",\"moi\",\"mom\",\"monash\",\"money\",\"monster\",\"mormon\",\"mortgage\",\"moscow\",\"moto\",\"motorcycles\",\"mov\",\"movie\",\"mp\",\"mq\",\"mr\",\"ms\",\"msd\",\"mt\",\"mtn\",\"mtr\",\"mu\",\"museum\",\"music\",\"mv\",\"mw\",\"mx\",\"my\",\"mz\",\"na\",\"nab\",\"nagoya\",\"name\",\"navy\",\"nba\",\"nc\",\"ne\",\"nec\",\"net\",\"netbank\",\"netflix\",\"network\",\"neustar\",\"new\",\"news\",\"next\",\"nextdirect\",\"nexus\",\"nf\",\"nfl\",\"ng\",\"ngo\",\"nhk\",\"ni\",\"nico\",\"nike\",\"nikon\",\"ninja\",\"nissan\",\"nissay\",\"nl\",\"no\",\"nokia\",\"norton\",\"now\",\"nowruz\",\"nowtv\",\"np\",\"nr\",\"nra\",\"nrw\",\"ntt\",\"nu\",\"nyc\",\"nz\",\"obi\",\"observer\",\"office\",\"okinawa\",\"olayan\",\"olayangroup\",\"ollo\",\"om\",\"omega\",\"one\",\"ong\",\"onl\",\"online\",\"ooo\",\"open\",\"oracle\",\"orange\",\"org\",\"organic\",\"origins\",\"osaka\",\"otsuka\",\"ott\",\"ovh\",\"pa\",\"page\",\"panasonic\",\"paris\",\"pars\",\"partners\",\"parts\",\"party\",\"pay\",\"pccw\",\"pe\",\"pet\",\"pf\",\"pfizer\",\"pg\",\"ph\",\"pharmacy\",\"phd\",\"philips\",\"phone\",\"photo\",\"photography\",\"photos\",\"physio\",\"pics\",\"pictet\",\"pictures\",\"pid\",\"pin\",\"ping\",\"pink\",\"pioneer\",\"pizza\",\"pk\",\"pl\",\"place\",\"play\",\"playstation\",\"plumbing\",\"plus\",\"pm\",\"pn\",\"pnc\",\"pohl\",\"poker\",\"politie\",\"porn\",\"post\",\"pr\",\"pramerica\",\"praxi\",\"press\",\"prime\",\"pro\",\"prod\",\"productions\",\"prof\",\"progressive\",\"promo\",\"properties\",\"property\",\"protection\",\"pru\",\"prudential\",\"ps\",\"pt\",\"pub\",\"pw\",\"pwc\",\"py\",\"qa\",\"qpon\",\"quebec\",\"quest\",\"racing\",\"radio\",\"re\",\"read\",\"realestate\",\"realtor\",\"realty\",\"recipes\",\"red\",\"redstone\",\"redumbrella\",\"rehab\",\"reise\",\"reisen\",\"reit\",\"reliance\",\"ren\",\"rent\",\"rentals\",\"repair\",\"report\",\"republican\",\"rest\",\"restaurant\",\"review\",\"reviews\",\"rexroth\",\"rich\",\"richardli\",\"ricoh\",\"ril\",\"rio\",\"rip\",\"ro\",\"rocks\",\"rodeo\",\"rogers\",\"room\",\"rs\",\"rsvp\",\"ru\",\"rugby\",\"ruhr\",\"run\",\"rw\",\"rwe\",\"ryukyu\",\"sa\",\"saarland\",\"safe\",\"safety\",\"sakura\",\"sale\",\"salon\",\"samsclub\",\"samsung\",\"sandvik\",\"sandvikcoromant\",\"sanofi\",\"sap\",\"sarl\",\"sas\",\"save\",\"saxo\",\"sb\",\"sbi\",\"sbs\",\"sc\",\"scb\",\"schaeffler\",\"schmidt\",\"scholarships\",\"school\",\"schule\",\"schwarz\",\"science\",\"scot\",\"sd\",\"se\",\"search\",\"seat\",\"secure\",\"security\",\"seek\",\"select\",\"sener\",\"services\",\"seven\",\"sew\",\"sex\",\"sexy\",\"sfr\",\"sg\",\"sh\",\"shangrila\",\"sharp\",\"shell\",\"shia\",\"shiksha\",\"shoes\",\"shop\",\"shopping\",\"shouji\",\"show\",\"si\",\"silk\",\"sina\",\"singles\",\"site\",\"sj\",\"sk\",\"ski\",\"skin\",\"sky\",\"skype\",\"sl\",\"sling\",\"sm\",\"smart\",\"smile\",\"sn\",\"sncf\",\"so\",\"soccer\",\"social\",\"softbank\",\"software\",\"sohu\",\"solar\",\"solutions\",\"song\",\"sony\",\"soy\",\"spa\",\"space\",\"sport\",\"spot\",\"sr\",\"srl\",\"ss\",\"st\",\"stada\",\"staples\",\"star\",\"statebank\",\"statefarm\",\"stc\",\"stcgroup\",\"stockholm\",\"storage\",\"store\",\"stream\",\"studio\",\"study\",\"style\",\"su\",\"sucks\",\"supplies\",\"supply\",\"support\",\"surf\",\"surgery\",\"suzuki\",\"sv\",\"swatch\",\"swiss\",\"sx\",\"sy\",\"sydney\",\"systems\",\"sz\",\"tab\",\"taipei\",\"talk\",\"taobao\",\"target\",\"tatamotors\",\"tatar\",\"tattoo\",\"tax\",\"taxi\",\"tc\",\"tci\",\"td\",\"tdk\",\"team\",\"tech\",\"technology\",\"tel\",\"temasek\",\"tennis\",\"teva\",\"tf\",\"tg\",\"th\",\"thd\",\"theater\",\"theatre\",\"tiaa\",\"tickets\",\"tienda\",\"tips\",\"tires\",\"tirol\",\"tj\",\"tjmaxx\",\"tjx\",\"tk\",\"tkmaxx\",\"tl\",\"tm\",\"tmall\",\"tn\",\"to\",\"today\",\"tokyo\",\"tools\",\"top\",\"toray\",\"toshiba\",\"total\",\"tours\",\"town\",\"toyota\",\"toys\",\"tr\",\"trade\",\"trading\",\"training\",\"travel\",\"travelers\",\"travelersinsurance\",\"trust\",\"trv\",\"tt\",\"tube\",\"tui\",\"tunes\",\"tushu\",\"tv\",\"tvs\",\"tw\",\"tz\",\"ua\",\"ubank\",\"ubs\",\"ug\",\"uk\",\"unicom\",\"university\",\"uno\",\"uol\",\"ups\",\"us\",\"uy\",\"uz\",\"va\",\"vacations\",\"vana\",\"vanguard\",\"vc\",\"ve\",\"vegas\",\"ventures\",\"verisign\",\"vermgensberater\",\"vermgensberatung\",\"versicherung\",\"vet\",\"vg\",\"vi\",\"viajes\",\"video\",\"vig\",\"viking\",\"villas\",\"vin\",\"vip\",\"virgin\",\"visa\",\"vision\",\"viva\",\"vivo\",\"vlaanderen\",\"vn\",\"vodka\",\"volvo\",\"vote\",\"voting\",\"voto\",\"voyage\",\"vu\",\"wales\",\"walmart\",\"walter\",\"wang\",\"wanggou\",\"watch\",\"watches\",\"weather\",\"weatherchannel\",\"webcam\",\"weber\",\"website\",\"wed\",\"wedding\",\"weibo\",\"weir\",\"wf\",\"whoswho\",\"wien\",\"wiki\",\"williamhill\",\"win\",\"windows\",\"wine\",\"winners\",\"wme\",\"wolterskluwer\",\"woodside\",\"work\",\"works\",\"world\",\"wow\",\"ws\",\"wtc\",\"wtf\",\"xbox\",\"xerox\",\"xihuan\",\"xin\",\"xxx\",\"xyz\",\"yachts\",\"yahoo\",\"yamaxun\",\"yandex\",\"ye\",\"yodobashi\",\"yoga\",\"yokohama\",\"you\",\"youtube\",\"yt\",\"yun\",\"za\",\"zappos\",\"zara\",\"zero\",\"zip\",\"zm\",\"zone\",\"zuerich\",\"zw\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]"));}}),
"[project]/node_modules/await-lock/build/AwaitLock.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AwaitLock_acquired, _AwaitLock_waitingResolvers;
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * A mutex lock for coordination across async functions
 */ class AwaitLock {
    constructor(){
        _AwaitLock_acquired.set(this, false);
        _AwaitLock_waitingResolvers.set(this, new Set());
    }
    /**
     * Whether the lock is currently acquired or not. Accessing this property does not affect the
     * status of the lock.
     */ get acquired() {
        return __classPrivateFieldGet(this, _AwaitLock_acquired, "f");
    }
    /**
     * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
     * returned promise is fulfilled once the lock is acquired.
     *
     * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
     * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
     * timeout values depends on how `setTimeout` handles those values.
     *
     * After acquiring the lock, you **must** call `release` when you are done with it.
     */ acquireAsync({ timeout } = {}) {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
            __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
            return Promise.resolve();
        }
        if (timeout == null) {
            return new Promise((resolve)=>{
                __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolve);
            });
        }
        let resolver;
        let timer;
        return Promise.race([
            new Promise((resolve)=>{
                resolver = ()=>{
                    clearTimeout(timer);
                    resolve();
                };
                __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolver);
            }),
            new Promise((_, reject)=>{
                timer = setTimeout(()=>{
                    __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolver);
                    reject(new Error(`Timed out waiting for lock`));
                }, timeout);
            })
        ]);
    }
    /**
     * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
     * `true` if the lock was free and is now acquired, and `false` otherwise.
     *
     * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
     * synchronously without waiting for the JavaScript task queue.
     */ tryAcquire() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
            __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
            return true;
        }
        return false;
    }
    /**
     * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
     * must release the lock exactly once.
     */ release() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
            throw new Error(`Cannot release an unacquired lock`);
        }
        if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").size > 0) {
            // Sets preserve insertion order like a queue
            const [resolve] = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f");
            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolve);
            resolve();
        } else {
            __classPrivateFieldSet(this, _AwaitLock_acquired, false, "f");
        }
    }
}
exports.default = AwaitLock;
_AwaitLock_acquired = new WeakMap(), _AwaitLock_waitingResolvers = new WeakMap(); //# sourceMappingURL=AwaitLock.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/disposable-polyfill/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// Code compiled with tsc supports "using" and "await using" syntax. This
// features is supported by downleveling the code to ES2017. The downleveling
// relies on `Symbol.dispose` and `Symbol.asyncDispose` symbols. These symbols
// might not be available in all environments. This package provides a polyfill
// for these symbols.
// @ts-expect-error
Symbol.dispose ?? (Symbol.dispose = Symbol('@@dispose'));
// @ts-expect-error
Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol('@@asyncDispose')); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleRequest = handleRequest;
exports.promisify = promisify;
function handleRequest(request, onSuccess, onError) {
    const cleanup = ()=>{
        request.removeEventListener('success', success);
        request.removeEventListener('error', error);
    };
    const success = ()=>{
        onSuccess(request.result);
        cleanup();
    };
    const error = ()=>{
        onError(request.error || new Error('Unknown error'));
        cleanup();
    };
    request.addEventListener('success', success);
    request.addEventListener('error', error);
}
function promisify(request) {
    return new Promise((resolve, reject)=>{
        handleRequest(request, resolve, reject);
    });
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DBIndex = void 0;
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/util.js [app-ssr] (ecmascript)");
class DBIndex {
    constructor(idbIndex){
        Object.defineProperty(this, "idbIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: idbIndex
        });
    }
    count(query) {
        return (0, util_js_1.promisify)(this.idbIndex.count(query));
    }
    get(query) {
        return (0, util_js_1.promisify)(this.idbIndex.get(query));
    }
    getKey(query) {
        return (0, util_js_1.promisify)(this.idbIndex.getKey(query));
    }
    getAll(query, count) {
        return (0, util_js_1.promisify)(this.idbIndex.getAll(query, count));
    }
    getAllKeys(query, count) {
        return (0, util_js_1.promisify)(this.idbIndex.getAllKeys(query, count));
    }
    deleteAll(query) {
        return new Promise((resolve, reject)=>{
            const result = this.idbIndex.openCursor(query);
            result.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    cursor.delete();
                    cursor.continue();
                } else {
                    resolve();
                }
            };
            result.onerror = function(event) {
                reject(event.target?.error || new Error('Unexpected error'));
            };
        });
    }
}
exports.DBIndex = DBIndex; //# sourceMappingURL=db-index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-object-store.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DBObjectStore = void 0;
const db_index_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/util.js [app-ssr] (ecmascript)");
class DBObjectStore {
    constructor(idbObjStore){
        Object.defineProperty(this, "idbObjStore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: idbObjStore
        });
    }
    get name() {
        return this.idbObjStore.name;
    }
    index(name) {
        return new db_index_js_1.DBIndex(this.idbObjStore.index(name));
    }
    get(key) {
        return (0, util_js_1.promisify)(this.idbObjStore.get(key));
    }
    getKey(query) {
        return (0, util_js_1.promisify)(this.idbObjStore.getKey(query));
    }
    getAll(query, count) {
        return (0, util_js_1.promisify)(this.idbObjStore.getAll(query, count));
    }
    getAllKeys(query, count) {
        return (0, util_js_1.promisify)(this.idbObjStore.getAllKeys(query, count));
    }
    add(value, key) {
        return (0, util_js_1.promisify)(this.idbObjStore.add(value, key));
    }
    put(value, key) {
        return (0, util_js_1.promisify)(this.idbObjStore.put(value, key));
    }
    delete(key) {
        return (0, util_js_1.promisify)(this.idbObjStore.delete(key));
    }
    clear() {
        return (0, util_js_1.promisify)(this.idbObjStore.clear());
    }
}
exports.DBObjectStore = DBObjectStore; //# sourceMappingURL=db-object-store.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-transaction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DBTransaction_tx;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DBTransaction = void 0;
const db_object_store_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-object-store.js [app-ssr] (ecmascript)");
class DBTransaction {
    constructor(tx){
        _DBTransaction_tx.set(this, void 0);
        __classPrivateFieldSet(this, _DBTransaction_tx, tx, "f");
        const onAbort = ()=>{
            cleanup();
        };
        const onComplete = ()=>{
            cleanup();
        };
        const cleanup = ()=>{
            __classPrivateFieldSet(this, _DBTransaction_tx, null, "f");
            tx.removeEventListener('abort', onAbort);
            tx.removeEventListener('complete', onComplete);
        };
        tx.addEventListener('abort', onAbort);
        tx.addEventListener('complete', onComplete);
    }
    get tx() {
        if (!__classPrivateFieldGet(this, _DBTransaction_tx, "f")) throw new Error('Transaction already ended');
        return __classPrivateFieldGet(this, _DBTransaction_tx, "f");
    }
    async abort() {
        const { tx } = this;
        __classPrivateFieldSet(this, _DBTransaction_tx, null, "f");
        tx.abort();
    }
    async commit() {
        const { tx } = this;
        __classPrivateFieldSet(this, _DBTransaction_tx, null, "f");
        tx.commit?.();
    }
    objectStore(name) {
        const store = this.tx.objectStore(name);
        return new db_object_store_js_1.DBObjectStore(store);
    }
    [(_DBTransaction_tx = new WeakMap(), Symbol.dispose)]() {
        if (__classPrivateFieldGet(this, _DBTransaction_tx, "f")) this.commit();
    }
}
exports.DBTransaction = DBTransaction; //# sourceMappingURL=db-transaction.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DB_db;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DB = void 0;
const db_transaction_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-transaction.js [app-ssr] (ecmascript)");
class DB {
    static async open(dbName, migrations, txOptions) {
        const db = await new Promise((resolve, reject)=>{
            const request = indexedDB.open(dbName, migrations.length);
            request.onerror = ()=>reject(request.error);
            request.onsuccess = ()=>resolve(request.result);
            request.onupgradeneeded = ({ oldVersion, newVersion })=>{
                const db = request.result;
                try {
                    for(let version = oldVersion; version < (newVersion ?? migrations.length); ++version){
                        const migration = migrations[version];
                        if (migration) migration(db);
                        else throw new Error(`Missing migration for version ${version}`);
                    }
                } catch (err) {
                    db.close();
                    reject(err);
                }
            };
        });
        return new DB(db, txOptions);
    }
    constructor(db, txOptions){
        Object.defineProperty(this, "txOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: txOptions
        });
        _DB_db.set(this, void 0);
        __classPrivateFieldSet(this, _DB_db, db, "f");
        const cleanup = ()=>{
            __classPrivateFieldSet(this, _DB_db, null, "f");
            db.removeEventListener('versionchange', cleanup);
            db.removeEventListener('close', cleanup);
            db.close(); // Can we call close on a "closed" database?
        };
        db.addEventListener('versionchange', cleanup);
        db.addEventListener('close', cleanup);
    }
    get db() {
        if (!__classPrivateFieldGet(this, _DB_db, "f")) throw new Error('Database closed');
        return __classPrivateFieldGet(this, _DB_db, "f");
    }
    get name() {
        return this.db.name;
    }
    get objectStoreNames() {
        return this.db.objectStoreNames;
    }
    get version() {
        return this.db.version;
    }
    async transaction(storeNames, mode, run) {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject)=>{
            try {
                const tx = this.db.transaction(storeNames, mode, this.txOptions);
                let result = {
                    done: false
                };
                tx.oncomplete = ()=>{
                    if (result.done) resolve(result.value);
                    else reject(new Error('Transaction completed without result'));
                };
                tx.onerror = ()=>reject(tx.error);
                tx.onabort = ()=>reject(tx.error || new Error('Transaction aborted'));
                try {
                    const value = await run(new db_transaction_js_1.DBTransaction(tx));
                    result = {
                        done: true,
                        value
                    };
                    tx.commit();
                } catch (err) {
                    tx.abort();
                    throw err;
                }
            } catch (err) {
                reject(err);
            }
        });
    }
    close() {
        const { db } = this;
        __classPrivateFieldSet(this, _DB_db, null, "f");
        db.close();
    }
    [(_DB_db = new WeakMap(), Symbol.dispose)]() {
        if (__classPrivateFieldGet(this, _DB_db, "f")) return this.close();
    }
}
exports.DB = DB; //# sourceMappingURL=db.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/disposable-polyfill/index.js [app-ssr] (ecmascript)");
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-object-store.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/db-transaction.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-database.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BrowserOAuthDatabase_dbPromise, _BrowserOAuthDatabase_cleanupInterval;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserOAuthDatabase = void 0;
const jwk_webcrypto_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)");
const index_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/indexed-db/index.js [app-ssr] (ecmascript)");
function encodeKey(key) {
    if (!(key instanceof jwk_webcrypto_1.WebcryptoKey) || !key.kid) {
        throw new Error('Invalid key object');
    }
    return {
        keyId: key.kid,
        keyPair: key.cryptoKeyPair
    };
}
async function decodeKey(encoded) {
    return jwk_webcrypto_1.WebcryptoKey.fromKeypair(encoded.keyPair, encoded.keyId);
}
const STORES = [
    'state',
    'session',
    'didCache',
    'dpopNonceCache',
    'handleCache',
    'authorizationServerMetadataCache',
    'protectedResourceMetadataCache'
];
class BrowserOAuthDatabase {
    constructor(options){
        _BrowserOAuthDatabase_dbPromise.set(this, void 0);
        _BrowserOAuthDatabase_cleanupInterval.set(this, void 0);
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_dbPromise, index_js_1.DB.open(options?.name ?? '@atproto-oauth-client', [
            (db)=>{
                for (const name of STORES){
                    const store = db.createObjectStore(name, {
                        autoIncrement: true
                    });
                    store.createIndex('expiresAt', 'expiresAt', {
                        unique: false
                    });
                }
            }
        ], {
            durability: options?.durability ?? 'strict'
        }), "f");
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_cleanupInterval, setInterval(()=>{
            void this.cleanup();
        }, options?.cleanupInterval ?? 30e3), "f");
    }
    async run(storeName, mode, fn) {
        const db = await __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f");
        return await db.transaction([
            storeName
        ], mode, (tx)=>fn(tx.objectStore(storeName)));
    }
    createStore(name, { encode, decode, expiresAt }) {
        return {
            get: async (key)=>{
                // Find item in store
                const item = await this.run(name, 'readonly', (store)=>store.get(key));
                // Not found
                if (item === undefined) return undefined;
                // Too old (delete)
                if (item.expiresAt != null && new Date(item.expiresAt) < new Date()) {
                    await this.run(name, 'readwrite', (store)=>store.delete(key));
                    return undefined;
                }
                // Item found and valid. Decode
                return decode(item.value);
            },
            set: async (key, value)=>{
                // Create encoded item record
                const item = {
                    value: await encode(value),
                    expiresAt: expiresAt(value)?.toISOString()
                };
                // Store item record
                await this.run(name, 'readwrite', (store)=>store.put(item, key));
            },
            del: async (key)=>{
                // Delete
                await this.run(name, 'readwrite', (store)=>store.delete(key));
            }
        };
    }
    getSessionStore() {
        return this.createStore('session', {
            expiresAt: ({ tokenSet })=>tokenSet.refresh_token || tokenSet.expires_at == null ? null : new Date(tokenSet.expires_at),
            encode: ({ dpopKey, ...session })=>({
                    ...session,
                    dpopKey: encodeKey(dpopKey)
                }),
            decode: async ({ dpopKey, ...encoded })=>({
                    ...encoded,
                    dpopKey: await decodeKey(dpopKey)
                })
        });
    }
    getStateStore() {
        return this.createStore('state', {
            expiresAt: (_value)=>new Date(Date.now() + 10 * 60e3),
            encode: ({ dpopKey, ...session })=>({
                    ...session,
                    dpopKey: encodeKey(dpopKey)
                }),
            decode: async ({ dpopKey, ...encoded })=>({
                    ...encoded,
                    dpopKey: await decodeKey(dpopKey)
                })
        });
    }
    getDpopNonceCache() {
        return this.createStore('dpopNonceCache', {
            expiresAt: (_value)=>new Date(Date.now() + 600e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getDidCache() {
        return this.createStore('didCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getHandleCache() {
        return this.createStore('handleCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getAuthorizationServerMetadataCache() {
        return this.createStore('authorizationServerMetadataCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    getProtectedResourceMetadataCache() {
        return this.createStore('protectedResourceMetadataCache', {
            expiresAt: (_value)=>new Date(Date.now() + 60e3),
            encode: (value)=>value,
            decode: (encoded)=>encoded
        });
    }
    async cleanup() {
        const db = await __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f");
        for (const name of STORES){
            await db.transaction([
                name
            ], 'readwrite', (tx)=>tx.objectStore(name).index('expiresAt').deleteAll(IDBKeyRange.upperBound(Date.now())));
        }
    }
    async [(_BrowserOAuthDatabase_dbPromise = new WeakMap(), _BrowserOAuthDatabase_cleanupInterval = new WeakMap(), Symbol.asyncDispose)]() {
        clearInterval(__classPrivateFieldGet(this, _BrowserOAuthDatabase_cleanupInterval, "f"));
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_cleanupInterval, undefined, "f");
        const dbPromise = __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f");
        __classPrivateFieldSet(this, _BrowserOAuthDatabase_dbPromise, Promise.reject(new Error('Database has been disposed')), "f");
        // Avoid "unhandled promise rejection"
        __classPrivateFieldGet(this, _BrowserOAuthDatabase_dbPromise, "f").catch(()=>null);
        // Spec recommends not to throw errors in dispose
        const db = await dbPromise.catch(()=>null);
        if (db) await (db[Symbol.asyncDispose] || db[Symbol.dispose]).call(db);
    }
}
exports.BrowserOAuthDatabase = BrowserOAuthDatabase; //# sourceMappingURL=browser-oauth-database.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/browser-runtime-implementation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserRuntimeImplementation = void 0;
const jwk_webcrypto_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)");
/**
 * @see {@link // https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request}
 */ const nativeRequestLock = navigator.locks?.request ? (name, fn)=>navigator.locks.request(name, {
        mode: 'exclusive'
    }, async ()=>fn()) : undefined;
class BrowserRuntimeImplementation {
    constructor(){
        Object.defineProperty(this, "requestLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: nativeRequestLock
        });
        if (typeof crypto !== 'object' || !crypto?.subtle) {
            throw new Error('Crypto with CryptoSubtle is required. If running in a browser, make sure the current page is loaded over HTTPS.');
        }
        if (!this.requestLock) {
            // There is no real need to polyfill this on older browsers. Indeed, the
            // oauth-client library will try and recover from concurrency issues when
            // refreshing tokens.
            console.warn('Locks API not available. You should consider using a more recent browser.');
        }
    }
    async createKey(algs) {
        return jwk_webcrypto_1.WebcryptoKey.generate(algs);
    }
    getRandomValues(byteLength) {
        return crypto.getRandomValues(new Uint8Array(byteLength));
    }
    async digest(data, { name }) {
        switch(name){
            case 'sha256':
            case 'sha384':
            case 'sha512':
                {
                    const buf = await crypto.subtle.digest(`SHA-${name.slice(3)}`, data);
                    return new Uint8Array(buf);
                }
            default:
                throw new Error(`Unsupported digest algorithm: ${name}`);
        }
    }
}
exports.BrowserRuntimeImplementation = BrowserRuntimeImplementation; //# sourceMappingURL=browser-runtime-implementation.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoginContinuedInParentWindowError = void 0;
/**
 * Special error class destined to be thrown when the login process was
 * performed in a popup and should be continued in the parent/initiating window.
 */ class LoginContinuedInParentWindowError extends Error {
    constructor(){
        super('Login complete, please close the popup window.');
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'LOGIN_CONTINUED_IN_PARENT_WINDOW'
        });
    }
}
exports.LoginContinuedInParentWindowError = LoginContinuedInParentWindowError; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildLoopbackClientId = buildLoopbackClientId;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
/**
 * @example
 * ```ts
 * const clientId = buildLoopbackClientId(window.location)
 * ```
 */ function buildLoopbackClientId(location, localhost = '127.0.0.1') {
    if (!(0, oauth_types_1.isLoopbackHost)(location.hostname)) {
        throw new TypeError(`Expected a loopback host, got ${location.hostname}`);
    }
    const redirectUri = `http://${location.hostname === 'localhost' ? localhost : location.hostname}${location.port && !location.port.startsWith(':') ? `:${location.port}` : location.port}${location.pathname}`;
    return `http://localhost${location.pathname === '/' ? '' : location.pathname}?redirect_uri=${encodeURIComponent(redirectUri)}`;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserOAuthClient = void 0;
const oauth_client_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const browser_oauth_database_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-database.js [app-ssr] (ecmascript)");
const browser_runtime_implementation_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/browser-runtime-implementation.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/errors.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/util.js [app-ssr] (ecmascript)");
const NAMESPACE = `@@atproto/oauth-client-browser`;
//- Popup channel
const POPUP_CHANNEL_NAME = `${NAMESPACE}(popup-channel)`;
const POPUP_STATE_PREFIX = `${NAMESPACE}(popup-state):`;
const syncChannel = new BroadcastChannel(`${NAMESPACE}(synchronization-channel)`);
class BrowserOAuthClient extends oauth_client_1.OAuthClient {
    static async load({ clientId, ...options }) {
        if (clientId.startsWith('http:')) {
            const clientMetadata = (0, oauth_types_1.atprotoLoopbackClientMetadata)(clientId);
            return new BrowserOAuthClient({
                clientMetadata,
                ...options
            });
        } else if (clientId.startsWith('https:')) {
            (0, oauth_types_1.assertOAuthDiscoverableClientId)(clientId);
            const clientMetadata = await oauth_client_1.OAuthClient.fetchMetadata({
                clientId,
                ...options
            });
            return new BrowserOAuthClient({
                clientMetadata,
                ...options
            });
        } else {
            throw new TypeError(`Invalid client id: ${clientId}`);
        }
    }
    constructor({ clientMetadata = (0, oauth_types_1.atprotoLoopbackClientMetadata)((0, util_js_1.buildLoopbackClientId)(window.location)), // "fragment" is a safer default as the query params will not be sent to the server
    responseMode = 'fragment', ...options }){
        if (!globalThis.crypto?.subtle) {
            throw new Error('WebCrypto API is required');
        }
        if (![
            'query',
            'fragment'
        ].includes(responseMode)) {
            // Make sure "form_post" is not used as it is not supported in the browser
            throw new TypeError(`Invalid response mode: ${responseMode}`);
        }
        const database = new browser_oauth_database_js_1.BrowserOAuthDatabase();
        super({
            ...options,
            clientMetadata,
            responseMode,
            keyset: undefined,
            runtimeImplementation: new browser_runtime_implementation_js_1.BrowserRuntimeImplementation(),
            sessionStore: database.getSessionStore(),
            stateStore: database.getStateStore(),
            didCache: database.getDidCache(),
            handleCache: database.getHandleCache(),
            dpopNonceCache: database.getDpopNonceCache(),
            authorizationServerMetadataCache: database.getAuthorizationServerMetadataCache(),
            protectedResourceMetadataCache: database.getProtectedResourceMetadataCache()
        });
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // TODO: replace with AsyncDisposableStack once they are standardized
        const ac = new AbortController();
        const { signal } = ac;
        this[Symbol.dispose] = ()=>ac.abort();
        signal.addEventListener('abort', ()=>database[Symbol.asyncDispose](), {
            once: true
        });
        // Keep track of the current session
        this.addEventListener('deleted', ({ detail: { sub } })=>{
            if (localStorage.getItem(`${NAMESPACE}(sub)`) === sub) {
                localStorage.removeItem(`${NAMESPACE}(sub)`);
            }
        });
        // Session synchronization across tabs
        for (const type of [
            'deleted',
            'updated'
        ]){
            this.sessionGetter.addEventListener(type, ({ detail })=>{
                // Notify other tabs when a session is deleted or updated
                syncChannel.postMessage([
                    type,
                    detail
                ]);
            });
        }
        syncChannel.addEventListener('message', (event)=>{
            if (event.source !== window) {
                // Trigger listeners when an event is received from another tab
                const [type, detail] = event.data;
                this.dispatchCustomEvent(type, detail);
            }
        }, // Remove the listener when the client is disposed
        {
            signal
        });
    }
    async init(refresh) {
        await fixLocation(this.clientMetadata);
        const signInResult = await this.signInCallback();
        if (signInResult) {
            localStorage.setItem(`${NAMESPACE}(sub)`, signInResult.session.sub);
            return signInResult;
        }
        const sub = localStorage.getItem(`${NAMESPACE}(sub)`);
        if (sub) {
            try {
                const session = await this.restore(sub, refresh);
                return {
                    session
                };
            } catch (err) {
                localStorage.removeItem(`${NAMESPACE}(sub)`);
                throw err;
            }
        }
    }
    async restore(sub, refresh) {
        const session = await super.restore(sub, refresh);
        localStorage.setItem(`${NAMESPACE}(sub)`, session.sub);
        return session;
    }
    async revoke(sub) {
        localStorage.removeItem(`${NAMESPACE}(sub)`);
        return super.revoke(sub);
    }
    async signIn(input, options) {
        if (options?.display === 'popup') {
            return this.signInPopup(input, options);
        } else {
            return this.signInRedirect(input, options);
        }
    }
    async signInRedirect(input, options) {
        const url = await this.authorize(input, options);
        window.location.href = url.href;
        // back-forward cache
        return new Promise((resolve, reject)=>{
            setTimeout((err)=>{
                // Take the opportunity to proactively cancel the pending request
                this.abortRequest(url).then(()=>reject(err), (reason)=>reject(new AggregateError([
                        err,
                        reason
                    ])));
            }, 5e3, new Error('User navigated back'));
        });
    }
    async signInPopup(input, options) {
        // Open new window asap to prevent popup busting by browsers
        const popupFeatures = 'width=600,height=600,menubar=no,toolbar=no';
        let popup = window.open('about:blank', '_blank', popupFeatures);
        const stateKey = `${Math.random().toString(36).slice(2)}`;
        const url = await this.authorize(input, {
            ...options,
            state: `${POPUP_STATE_PREFIX}${stateKey}`,
            display: options?.display ?? 'popup'
        });
        options?.signal?.throwIfAborted();
        if (popup) {
            popup.window.location.href = url.href;
        } else {
            popup = window.open(url.href, '_blank', popupFeatures);
        }
        popup?.focus();
        return new Promise((resolve, reject)=>{
            const popupChannel = new BroadcastChannel(POPUP_CHANNEL_NAME);
            const cleanup = ()=>{
                clearTimeout(timeout);
                popupChannel.removeEventListener('message', onMessage);
                popupChannel.close();
                options?.signal?.removeEventListener('abort', cancel);
                popup?.close();
            };
            const cancel = ()=>{
                // @TODO: Store fact that the request was cancelled, allowing any
                // callback (e.g. in the popup) to revoke the session or credentials.
                reject(new Error(options?.signal?.aborted ? 'Aborted' : 'Timeout'));
                cleanup();
            };
            options?.signal?.addEventListener('abort', cancel);
            const timeout = setTimeout(cancel, 5 * 60e3);
            const onMessage = async ({ data })=>{
                if (data.key !== stateKey) return;
                if (!('result' in data)) return;
                // Send acknowledgment to popup window
                popupChannel.postMessage({
                    key: stateKey,
                    ack: true
                });
                cleanup();
                const { result } = data;
                if (result.status === 'fulfilled') {
                    const sub = result.value;
                    try {
                        options?.signal?.throwIfAborted();
                        resolve(await this.restore(sub, false));
                    } catch (err) {
                        reject(err);
                        void this.revoke(sub);
                    }
                } else {
                    const { message, params } = result.reason;
                    reject(new oauth_client_1.OAuthCallbackError(new URLSearchParams(params), message));
                }
            };
            popupChannel.addEventListener('message', onMessage);
        });
    }
    readCallbackParams() {
        const params = this.responseMode === 'fragment' ? new URLSearchParams(location.hash.slice(1)) : new URLSearchParams(location.search);
        // Only if the current URL contains a valid oauth response params
        if (!params.has('state') || !(params.has('code') || params.has('error'))) {
            return null;
        }
        const matchesLocation = (url)=>location.origin === url.origin && location.pathname === url.pathname;
        const redirectUrls = this.clientMetadata.redirect_uris.map((uri)=>new URL(uri));
        // Only if the current URL is one of the redirect_uris
        if (!redirectUrls.some(matchesLocation)) return null;
        return params;
    }
    async signInCallback() {
        const params = this.readCallbackParams();
        // Not a (valid) OAuth redirect
        if (!params) return null;
        // Replace the current history entry without the params (this will prevent
        // the following code to run again if the user refreshes the page)
        if (this.responseMode === 'fragment') {
            history.replaceState(null, '', location.pathname + location.search);
        } else if (this.responseMode === 'query') {
            history.replaceState(null, '', location.pathname);
        }
        // Utility function to send the result of the popup to the parent window
        const sendPopupResult = (message)=>{
            const popupChannel = new BroadcastChannel(POPUP_CHANNEL_NAME);
            return new Promise((resolve)=>{
                const cleanup = (result)=>{
                    clearTimeout(timer);
                    popupChannel.removeEventListener('message', onMessage);
                    popupChannel.close();
                    resolve(result);
                };
                const onMessage = ({ data })=>{
                    if ('ack' in data && message.key === data.key) cleanup(true);
                };
                popupChannel.addEventListener('message', onMessage);
                popupChannel.postMessage(message);
                // Receiving of "ack" should be very fast, giving it 500 ms anyway
                const timer = setTimeout(cleanup, 500, false);
            });
        };
        return this.callback(params).then(async (result)=>{
            if (result.state?.startsWith(POPUP_STATE_PREFIX)) {
                const receivedByParent = await sendPopupResult({
                    key: result.state.slice(POPUP_STATE_PREFIX.length),
                    result: {
                        status: 'fulfilled',
                        value: result.session.sub
                    }
                });
                // Revoke the credentials if the parent window was closed
                if (!receivedByParent) await result.session.signOut();
                throw new errors_js_1.LoginContinuedInParentWindowError(); // signInPopup
            }
            return result;
        }).catch(async (err)=>{
            if (err instanceof oauth_client_1.OAuthCallbackError && err.state?.startsWith(POPUP_STATE_PREFIX)) {
                await sendPopupResult({
                    key: err.state.slice(POPUP_STATE_PREFIX.length),
                    result: {
                        status: 'rejected',
                        reason: {
                            message: err.message,
                            params: Array.from(err.params.entries())
                        }
                    }
                });
                throw new errors_js_1.LoginContinuedInParentWindowError(); // signInPopup
            }
            // Most probable cause at this point is that the "state" parameter is
            // invalid.
            throw err;
        }).catch((err)=>{
            if (err instanceof errors_js_1.LoginContinuedInParentWindowError) {
                // parent will also try to close the popup
                window.close();
            }
            throw err;
        });
    }
    dispose() {
        this[Symbol.dispose]();
    }
}
exports.BrowserOAuthClient = BrowserOAuthClient;
_a = Symbol.dispose;
/**
 * Since "localhost" is often used either in IP mode or in hostname mode,
 * and because the redirect uris must use the IP mode, we need to make sure
 * that the current location url is not using "localhost".
 *
 * This is required for the IndexedDB to work properly. Indeed, the IndexedDB
 * is shared by origin, so we must ensure to be on the same origin as the
 * redirect uris.
 */ function fixLocation(clientMetadata) {
    if (!(0, oauth_types_1.isOAuthClientIdLoopback)(clientMetadata.client_id)) return;
    if (window.location.hostname !== 'localhost') return;
    const locationUrl = new URL(window.location.href);
    for (const uri of clientMetadata.redirect_uris){
        const url = new URL(uri);
        if ((url.hostname === '127.0.0.1' || url.hostname === '[::1]') && (!url.port || url.port === locationUrl.port) && url.protocol === locationUrl.protocol && url.pathname === locationUrl.pathname) {
            url.port = locationUrl.port;
            window.location.href = url.href;
            // Prevent init() on the wrong origin
            throw new Error('Redirecting to loopback IP...');
        }
    }
    throw new Error(`Please use the loopback IP address instead of ${locationUrl}`);
} //# sourceMappingURL=browser-oauth-client.js.map
}}),
"[project]/node_modules/@atproto/oauth-client-browser/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildLoopbackClientId = void 0;
__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/disposable-polyfill/index.js [app-ssr] (ecmascript)");
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/browser-oauth-client.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/errors.js [app-ssr] (ecmascript)"), exports);
var util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client-browser/dist/util.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "buildLoopbackClientId", {
    enumerable: true,
    get: function() {
        return util_js_1.buildLoopbackClientId;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JwtVerifyError = exports.JwtCreateError = exports.JwkError = exports.ERR_JWT_VERIFY = exports.ERR_JWT_CREATE = exports.ERR_JWT_INVALID = exports.ERR_JWK_NOT_FOUND = exports.ERR_JWK_INVALID = exports.ERR_JWKS_NO_MATCHING_KEY = void 0;
exports.ERR_JWKS_NO_MATCHING_KEY = 'ERR_JWKS_NO_MATCHING_KEY';
exports.ERR_JWK_INVALID = 'ERR_JWK_INVALID';
exports.ERR_JWK_NOT_FOUND = 'ERR_JWK_NOT_FOUND';
exports.ERR_JWT_INVALID = 'ERR_JWT_INVALID';
exports.ERR_JWT_CREATE = 'ERR_JWT_CREATE';
exports.ERR_JWT_VERIFY = 'ERR_JWT_VERIFY';
class JwkError extends TypeError {
    constructor(message = 'JWK error', code = exports.ERR_JWK_INVALID, options){
        super(message, options);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
}
exports.JwkError = JwkError;
class JwtCreateError extends Error {
    constructor(message = 'Unable to create JWT', code = exports.ERR_JWT_CREATE, options){
        super(message, options);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
    static from(cause, code, message) {
        if (cause instanceof JwtCreateError) return cause;
        if (cause instanceof JwkError) {
            return new JwtCreateError(message, cause.code, {
                cause
            });
        }
        return new JwtCreateError(message, code, {
            cause
        });
    }
}
exports.JwtCreateError = JwtCreateError;
class JwtVerifyError extends Error {
    constructor(message = 'Invalid JWT', code = exports.ERR_JWT_VERIFY, options){
        super(message, options);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
    static from(cause, code, message) {
        if (cause instanceof JwtVerifyError) return cause;
        if (cause instanceof JwkError) {
            return new JwtVerifyError(message, cause.code, {
                cause
            });
        }
        return new JwtVerifyError(message, code, {
            cause
        });
    }
}
exports.JwtVerifyError = JwtVerifyError; //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/alg.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwkAlgorithms = jwkAlgorithms;
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
// Copy variable to prevent bundlers from automatically polyfilling "process" (e.g. parcel)
const { process } = globalThis;
const IS_NODE_RUNTIME = typeof process !== 'undefined' && typeof process?.versions?.node === 'string';
function* jwkAlgorithms(jwk) {
    // Ed25519, Ed448, and secp256k1 always have "alg"
    // OKP always has "use"
    if (jwk.alg) {
        yield jwk.alg;
        return;
    }
    switch(jwk.kty){
        case 'EC':
            {
                if (jwk.use === 'enc' || jwk.use === undefined) {
                    yield 'ECDH-ES';
                    yield 'ECDH-ES+A128KW';
                    yield 'ECDH-ES+A192KW';
                    yield 'ECDH-ES+A256KW';
                }
                if (jwk.use === 'sig' || jwk.use === undefined) {
                    const crv = 'crv' in jwk ? jwk.crv : undefined;
                    switch(crv){
                        case 'P-256':
                        case 'P-384':
                            yield `ES${crv.slice(-3)}`;
                            break;
                        case 'P-521':
                            yield 'ES512';
                            break;
                        case 'secp256k1':
                            if (IS_NODE_RUNTIME) yield 'ES256K';
                            break;
                        default:
                            throw new errors_js_1.JwkError(`Unsupported crv "${crv}"`);
                    }
                }
                return;
            }
        case 'OKP':
            {
                if (!jwk.use) throw new errors_js_1.JwkError('Missing "use" Parameter value');
                yield 'ECDH-ES';
                yield 'ECDH-ES+A128KW';
                yield 'ECDH-ES+A192KW';
                yield 'ECDH-ES+A256KW';
                return;
            }
        case 'RSA':
            {
                if (jwk.use === 'enc' || jwk.use === undefined) {
                    yield 'RSA-OAEP';
                    yield 'RSA-OAEP-256';
                    yield 'RSA-OAEP-384';
                    yield 'RSA-OAEP-512';
                    if (IS_NODE_RUNTIME) yield 'RSA1_5';
                }
                if (jwk.use === 'sig' || jwk.use === undefined) {
                    yield 'PS256';
                    yield 'PS384';
                    yield 'PS512';
                    yield 'RS256';
                    yield 'RS384';
                    yield 'RS512';
                }
                return;
            }
        case 'oct':
            {
                if (jwk.use === 'enc' || jwk.use === undefined) {
                    yield 'A128GCMKW';
                    yield 'A192GCMKW';
                    yield 'A256GCMKW';
                    yield 'A128KW';
                    yield 'A192KW';
                    yield 'A256KW';
                }
                if (jwk.use === 'sig' || jwk.use === undefined) {
                    yield 'HS256';
                    yield 'HS384';
                    yield 'HS512';
                }
                return;
            }
        default:
            throw new errors_js_1.JwkError(`Unsupported kty "${jwk.kty}"`);
    }
} //# sourceMappingURL=alg.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwkPubSchema = exports.jwkValidator = exports.jwkSchema = exports.jwkUnknownKeySchema = exports.jwkSymKeySchema = exports.jwkOkpKeySchema = exports.jwkEcSecp256k1KeySchema = exports.jwkEcKeySchema = exports.jwkRsaKeySchema = exports.jwkBaseSchema = exports.keyUsageSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.keyUsageSchema = zod_1.z.enum([
    'sign',
    'verify',
    'encrypt',
    'decrypt',
    'wrapKey',
    'unwrapKey',
    'deriveKey',
    'deriveBits'
]);
/**
 * The "use" and "key_ops" JWK members SHOULD NOT be used together;
 * however, if both are used, the information they convey MUST be
 * consistent.  Applications should specify which of these members they
 * use, if either is to be used by the application.
 *
 * @todo Actually check that "use" and "key_ops" are consistent when both are present.
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7517#section-4.3}
 */ exports.jwkBaseSchema = zod_1.z.object({
    kty: zod_1.z.string().min(1),
    alg: zod_1.z.string().min(1).optional(),
    kid: zod_1.z.string().min(1).optional(),
    ext: zod_1.z.boolean().optional(),
    use: zod_1.z.enum([
        'sig',
        'enc'
    ]).optional(),
    key_ops: zod_1.z.array(exports.keyUsageSchema).optional(),
    x5c: zod_1.z.array(zod_1.z.string()).optional(),
    x5t: zod_1.z.string().min(1).optional(),
    'x5t#S256': zod_1.z.string().min(1).optional(),
    x5u: zod_1.z.string().url().optional()
});
/**
 * @todo: properly implement this
 */ exports.jwkRsaKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('RSA'),
    alg: zod_1.z.enum([
        'RS256',
        'RS384',
        'RS512',
        'PS256',
        'PS384',
        'PS512'
    ]).optional(),
    n: zod_1.z.string().min(1),
    e: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional(),
    p: zod_1.z.string().min(1).optional(),
    q: zod_1.z.string().min(1).optional(),
    dp: zod_1.z.string().min(1).optional(),
    dq: zod_1.z.string().min(1).optional(),
    qi: zod_1.z.string().min(1).optional(),
    oth: zod_1.z.array(zod_1.z.object({
        r: zod_1.z.string().optional(),
        d: zod_1.z.string().optional(),
        t: zod_1.z.string().optional()
    })).nonempty().optional()
});
exports.jwkEcKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('EC'),
    alg: zod_1.z.enum([
        'ES256',
        'ES384',
        'ES512'
    ]).optional(),
    crv: zod_1.z.enum([
        'P-256',
        'P-384',
        'P-521'
    ]),
    x: zod_1.z.string().min(1),
    y: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional()
});
exports.jwkEcSecp256k1KeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('EC'),
    alg: zod_1.z.enum([
        'ES256K'
    ]).optional(),
    crv: zod_1.z.enum([
        'secp256k1'
    ]),
    x: zod_1.z.string().min(1),
    y: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional()
});
exports.jwkOkpKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('OKP'),
    alg: zod_1.z.enum([
        'EdDSA'
    ]).optional(),
    crv: zod_1.z.enum([
        'Ed25519',
        'Ed448'
    ]),
    x: zod_1.z.string().min(1),
    d: zod_1.z.string().min(1).optional()
});
exports.jwkSymKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.literal('oct'),
    alg: zod_1.z.enum([
        'HS256',
        'HS384',
        'HS512'
    ]).optional(),
    k: zod_1.z.string()
});
exports.jwkUnknownKeySchema = exports.jwkBaseSchema.extend({
    kty: zod_1.z.string().refine((v)=>v !== 'RSA' && v !== 'EC' && v !== 'OKP' && v !== 'oct')
});
exports.jwkSchema = zod_1.z.union([
    exports.jwkUnknownKeySchema,
    exports.jwkRsaKeySchema,
    exports.jwkEcKeySchema,
    exports.jwkEcSecp256k1KeySchema,
    exports.jwkOkpKeySchema,
    exports.jwkSymKeySchema
]);
exports.jwkValidator = exports.jwkSchema.refine((k)=>k.use != null || k.key_ops != null, 'use or key_ops required').refine((k)=>!k.use || !k.key_ops || k.key_ops.every((o)=>k.use === 'sig' ? o === 'sign' || o === 'verify' : o === 'encrypt' || o === 'decrypt'), 'use and key_ops must be consistent');
exports.jwkPubSchema = exports.jwkValidator.refine((k)=>k.kid != null, 'kid is required').refine((k)=>!('k' in k) && !('d' in k), 'private key not allowed'); //# sourceMappingURL=jwk.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwks.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwksPubSchema = exports.jwksSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const jwk_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)");
exports.jwksSchema = zod_1.z.object({
    keys: zod_1.z.array(jwk_js_1.jwkSchema)
});
exports.jwksPubSchema = zod_1.z.object({
    keys: zod_1.z.array(jwk_js_1.jwkPubSchema)
}); //# sourceMappingURL=jwks.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.segmentedStringRefinementFactory = exports.jwtCharsRefinement = exports.cachedGetter = exports.preferredOrderCmp = exports.isDefined = void 0;
exports.matchesAny = matchesAny;
exports.parseB64uJson = parseB64uJson;
const base64_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const isDefined = (i)=>i !== undefined;
exports.isDefined = isDefined;
const preferredOrderCmp = (order)=>(a, b)=>{
        const aIdx = order.indexOf(a);
        const bIdx = order.indexOf(b);
        if (aIdx === bIdx) return 0;
        if (aIdx === -1) return 1;
        if (bIdx === -1) return -1;
        return aIdx - bIdx;
    };
exports.preferredOrderCmp = preferredOrderCmp;
function matchesAny(value) {
    return value == null ? (v)=>true : Array.isArray(value) ? (v)=>value.includes(v) : (v)=>v === value;
}
/**
 * Decorator to cache the result of a getter on a class instance.
 */ const cachedGetter = (target, _context)=>{
    return function() {
        const value = target.call(this);
        Object.defineProperty(this, target.name, {
            get: ()=>value,
            enumerable: true,
            configurable: true
        });
        return value;
    };
};
exports.cachedGetter = cachedGetter;
const decoder = new TextDecoder();
function parseB64uJson(input) {
    const inputBytes = base64_1.base64url.baseDecode(input);
    const json = decoder.decode(inputBytes);
    return JSON.parse(json);
}
/**
 * @example
 * ```ts
 * // jwtSchema will only allow base64url chars & "." (dot)
 * const jwtSchema = z.string().superRefine(jwtCharsRefinement)
 * ```
 */ const jwtCharsRefinement = (data, ctx)=>{
    // Note: this is a hot path, let's avoid using a RegExp
    let char;
    for(let i = 0; i < data.length; i++){
        char = data.charCodeAt(i);
        if (// Base64 URL encoding (most frequent)
        65 <= char && char <= 90 || 97 <= char && char <= 122 || 48 <= char && char <= 57 || // 0-9
        char === 45 || // -
        char === 95 || // _
        // Boundary (least frequent, check last)
        char === 46 // .
        ) {
        // continue
        } else {
            // Invalid char might be a surrogate pair
            const invalidChar = String.fromCodePoint(data.codePointAt(i));
            return ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `Invalid character "${invalidChar}" in JWT at position ${i}`
            });
        }
    }
};
exports.jwtCharsRefinement = jwtCharsRefinement;
/**
 * @example
 * ```ts
 * const jwtSchema = z.string().superRefine(segmentedStringRefinementFactory(3))
 * type Jwt = z.infer<typeof jwtSchema> // `${string}.${string}.${string}`
 * ```
 */ const segmentedStringRefinementFactory = (count, minPartLength = 2)=>{
    if (!Number.isFinite(count) || count < 1 || (count | 0) !== count) {
        throw new TypeError(`Count must be a natural number (got ${count})`);
    }
    const minTotalLength = count * minPartLength + (count - 1);
    const errorPrefix = `Invalid JWT format`;
    return (data, ctx)=>{
        if (data.length < minTotalLength) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `${errorPrefix}: too short`
            });
            return false;
        }
        let currentStart = 0;
        for(let i = 0; i < count - 1; i++){
            const nextDot = data.indexOf('.', currentStart);
            if (nextDot === -1) {
                ctx.addIssue({
                    code: zod_1.ZodIssueCode.custom,
                    message: `${errorPrefix}: expected ${count} segments, got ${i + 1}`
                });
                return false;
            }
            if (nextDot - currentStart < minPartLength) {
                ctx.addIssue({
                    code: zod_1.ZodIssueCode.custom,
                    message: `${errorPrefix}: segment ${i + 1} is too short`
                });
                return false;
            }
            currentStart = nextDot + 1;
        }
        if (data.indexOf('.', currentStart) !== -1) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `${errorPrefix}: too many segments`
            });
            return false;
        }
        if (data.length - currentStart < minPartLength) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: `${errorPrefix}: last segment is too short`
            });
            return false;
        }
        return true;
    };
};
exports.segmentedStringRefinementFactory = segmentedStringRefinementFactory; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwtPayloadSchema = exports.jwtHeaderSchema = exports.isUnsignedJwt = exports.unsignedJwtSchema = exports.isSignedJwt = exports.signedJwtSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const jwk_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
exports.signedJwtSchema = zod_1.z.string().superRefine(util_js_1.jwtCharsRefinement).superRefine((0, util_js_1.segmentedStringRefinementFactory)(3));
const isSignedJwt = (data)=>exports.signedJwtSchema.safeParse(data).success;
exports.isSignedJwt = isSignedJwt;
exports.unsignedJwtSchema = zod_1.z.string().superRefine(util_js_1.jwtCharsRefinement).superRefine((0, util_js_1.segmentedStringRefinementFactory)(2));
const isUnsignedJwt = (data)=>exports.unsignedJwtSchema.safeParse(data).success;
exports.isUnsignedJwt = isUnsignedJwt;
/**
 * @see {@link https://www.rfc-editor.org/rfc/rfc7515.html#section-4}
 */ exports.jwtHeaderSchema = zod_1.z.object({
    /** "alg" (Algorithm) Header Parameter */ alg: zod_1.z.string(),
    /** "jku" (JWK Set URL) Header Parameter */ jku: zod_1.z.string().url().optional(),
    /** "jwk" (JSON Web Key) Header Parameter */ jwk: zod_1.z.object({
        kty: zod_1.z.string(),
        crv: zod_1.z.string().optional(),
        x: zod_1.z.string().optional(),
        y: zod_1.z.string().optional(),
        e: zod_1.z.string().optional(),
        n: zod_1.z.string().optional()
    }).optional(),
    /** "kid" (Key ID) Header Parameter */ kid: zod_1.z.string().optional(),
    /** "x5u" (X.509 URL) Header Parameter */ x5u: zod_1.z.string().optional(),
    /** "x5c" (X.509 Certificate Chain) Header Parameter */ x5c: zod_1.z.array(zod_1.z.string()).optional(),
    /** "x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter */ x5t: zod_1.z.string().optional(),
    /** "x5t#S256" (X.509 Certificate SHA-256 Thumbprint) Header Parameter */ 'x5t#S256': zod_1.z.string().optional(),
    /** "typ" (Type) Header Parameter */ typ: zod_1.z.string().optional(),
    /** "cty" (Content Type) Header Parameter */ cty: zod_1.z.string().optional(),
    /** "crit" (Critical) Header Parameter */ crit: zod_1.z.array(zod_1.z.string()).optional()
}).passthrough();
// https://www.iana.org/assignments/jwt/jwt.xhtml
exports.jwtPayloadSchema = zod_1.z.object({
    iss: zod_1.z.string().optional(),
    aud: zod_1.z.union([
        zod_1.z.string(),
        zod_1.z.array(zod_1.z.string()).nonempty()
    ]).optional(),
    sub: zod_1.z.string().optional(),
    exp: zod_1.z.number().int().optional(),
    nbf: zod_1.z.number().int().optional(),
    iat: zod_1.z.number().int().optional(),
    jti: zod_1.z.string().optional(),
    htm: zod_1.z.string().optional(),
    htu: zod_1.z.string().optional(),
    ath: zod_1.z.string().optional(),
    acr: zod_1.z.string().optional(),
    azp: zod_1.z.string().optional(),
    amr: zod_1.z.array(zod_1.z.string()).optional(),
    // https://datatracker.ietf.org/doc/html/rfc7800
    cnf: zod_1.z.object({
        kid: zod_1.z.string().optional(),
        jwk: jwk_js_1.jwkPubSchema.optional(),
        jwe: zod_1.z.string().optional(),
        jku: zod_1.z.string().url().optional(),
        // https://datatracker.ietf.org/doc/html/rfc9449#section-6.1
        jkt: zod_1.z.string().optional(),
        // https://datatracker.ietf.org/doc/html/rfc8705
        'x5t#S256': zod_1.z.string().optional(),
        // https://datatracker.ietf.org/doc/html/rfc9203
        osc: zod_1.z.string().optional()
    }).optional(),
    client_id: zod_1.z.string().optional(),
    scope: zod_1.z.string().optional(),
    nonce: zod_1.z.string().optional(),
    at_hash: zod_1.z.string().optional(),
    c_hash: zod_1.z.string().optional(),
    s_hash: zod_1.z.string().optional(),
    auth_time: zod_1.z.number().int().optional(),
    // https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
    // OpenID: "profile" scope
    name: zod_1.z.string().optional(),
    family_name: zod_1.z.string().optional(),
    given_name: zod_1.z.string().optional(),
    middle_name: zod_1.z.string().optional(),
    nickname: zod_1.z.string().optional(),
    preferred_username: zod_1.z.string().optional(),
    gender: zod_1.z.string().optional(),
    picture: zod_1.z.string().url().optional(),
    profile: zod_1.z.string().url().optional(),
    website: zod_1.z.string().url().optional(),
    birthdate: zod_1.z.string().regex(/\d{4}-\d{2}-\d{2}/) // YYYY-MM-DD
    .optional(),
    zoneinfo: zod_1.z.string().regex(/^[A-Za-z0-9_/]+$/).optional(),
    locale: zod_1.z.string().regex(/^[a-z]{2}(-[A-Z]{2})?$/).optional(),
    updated_at: zod_1.z.number().int().optional(),
    // OpenID: "email" scope
    email: zod_1.z.string().optional(),
    email_verified: zod_1.z.boolean().optional(),
    // OpenID: "phone" scope
    phone_number: zod_1.z.string().optional(),
    phone_number_verified: zod_1.z.boolean().optional(),
    // OpenID: "address" scope
    // https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim
    address: zod_1.z.object({
        formatted: zod_1.z.string().optional(),
        street_address: zod_1.z.string().optional(),
        locality: zod_1.z.string().optional(),
        region: zod_1.z.string().optional(),
        postal_code: zod_1.z.string().optional(),
        country: zod_1.z.string().optional()
    }).optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396#section-14.2
    authorization_details: zod_1.z.array(zod_1.z.object({
        type: zod_1.z.string(),
        // https://datatracker.ietf.org/doc/html/rfc9396#section-2.2
        locations: zod_1.z.array(zod_1.z.string()).optional(),
        actions: zod_1.z.array(zod_1.z.string()).optional(),
        datatypes: zod_1.z.array(zod_1.z.string()).optional(),
        identifier: zod_1.z.string().optional(),
        privileges: zod_1.z.array(zod_1.z.string()).optional()
    }).passthrough()).optional()
}).passthrough(); //# sourceMappingURL=jwt.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwt-decode.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unsafeDecodeJwt = unsafeDecodeJwt;
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
const jwt_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
function unsafeDecodeJwt(jwt) {
    const { 0: headerEnc, 1: payloadEnc, length } = jwt.split('.');
    if (length > 3 || length < 2) {
        throw new errors_js_1.JwtVerifyError(undefined, errors_js_1.ERR_JWT_INVALID);
    }
    const header = jwt_js_1.jwtHeaderSchema.parse((0, util_js_1.parseB64uJson)(headerEnc));
    if (length === 2 && header?.alg !== 'none') {
        throw new errors_js_1.JwtVerifyError(undefined, errors_js_1.ERR_JWT_INVALID);
    }
    const payload = jwt_js_1.jwtPayloadSchema.parse((0, util_js_1.parseB64uJson)(payloadEnc));
    return {
        header,
        payload
    };
} //# sourceMappingURL=jwt-decode.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/jwt-verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=jwt-verify.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __runInitializers = this && this.__runInitializers || function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = this && this.__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Key = void 0;
const alg_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/alg.js [app-ssr] (ecmascript)");
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
const jwk_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
const jwkSchemaReadonly = jwk_js_1.jwkSchema.readonly();
let Key = (()=>{
    var _a;
    let _instanceExtraInitializers = [];
    let _get_publicJwk_decorators;
    let _get_bareJwk_decorators;
    let _get_algorithms_decorators;
    return _a = class Key {
        constructor(jwk){
            Object.defineProperty(this, "jwk", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: (__runInitializers(this, _instanceExtraInitializers), jwk)
            });
            // A key should always be used either for signing or encryption.
            if (!jwk.use) throw new errors_js_1.JwkError('Missing "use" Parameter value');
        }
        get isPrivate() {
            const { jwk } = this;
            if ('d' in jwk && jwk.d !== undefined) return true;
            if ('k' in jwk && jwk.k !== undefined) return true;
            return false;
        }
        get isSymetric() {
            const { jwk } = this;
            if ('k' in jwk && jwk.k !== undefined) return true;
            return false;
        }
        get privateJwk() {
            return this.isPrivate ? this.jwk : undefined;
        }
        get publicJwk() {
            if (this.isSymetric) return undefined;
            return jwkSchemaReadonly.parse({
                ...this.jwk,
                d: undefined,
                k: undefined
            });
        }
        get bareJwk() {
            if (this.isSymetric) return undefined;
            const { kty, crv, e, n, x, y } = this.jwk;
            return jwkSchemaReadonly.parse({
                crv,
                e,
                kty,
                n,
                x,
                y
            });
        }
        get use() {
            return this.jwk.use;
        }
        /**
             * The (forced) algorithm to use. If not provided, the key will be usable with
             * any of the algorithms in {@link algorithms}.
             *
             * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1 | "alg" (Algorithm) Header Parameter Values for JWS}
             */ get alg() {
            return this.jwk.alg;
        }
        get kid() {
            return this.jwk.kid;
        }
        get crv() {
            return this.jwk.crv;
        }
        /**
             * All the algorithms that this key can be used with. If `alg` is provided,
             * this set will only contain that algorithm.
             */ get algorithms() {
            return Object.freeze(Array.from((0, alg_js_1.jwkAlgorithms)(this.jwk)));
        }
    }, (()=>{
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        _get_publicJwk_decorators = [
            util_js_1.cachedGetter
        ];
        _get_bareJwk_decorators = [
            util_js_1.cachedGetter
        ];
        _get_algorithms_decorators = [
            util_js_1.cachedGetter
        ];
        __esDecorate(_a, null, _get_publicJwk_decorators, {
            kind: "getter",
            name: "publicJwk",
            static: false,
            private: false,
            access: {
                has: (obj)=>"publicJwk" in obj,
                get: (obj)=>obj.publicJwk
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_bareJwk_decorators, {
            kind: "getter",
            name: "bareJwk",
            static: false,
            private: false,
            access: {
                has: (obj)=>"bareJwk" in obj,
                get: (obj)=>obj.bareJwk
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_algorithms_decorators, {
            kind: "getter",
            name: "algorithms",
            static: false,
            private: false,
            access: {
                has: (obj)=>"algorithms" in obj,
                get: (obj)=>obj.algorithms
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        if (_metadata) Object.defineProperty(_a, Symbol.metadata, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _metadata
        });
    })(), _a;
})();
exports.Key = Key; //# sourceMappingURL=key.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/keyset.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __runInitializers = this && this.__runInitializers || function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = this && this.__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Keyset = void 0;
const errors_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)");
const jwt_decode_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt-decode.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)");
const extractPrivateJwk = (key)=>key.privateJwk;
const extractPublicJwk = (key)=>key.publicJwk;
let Keyset = (()=>{
    var _a;
    let _instanceExtraInitializers = [];
    let _get_signAlgorithms_decorators;
    let _get_publicJwks_decorators;
    let _get_privateJwks_decorators;
    return _a = class Keyset {
        constructor(iterable, /**
             * The preferred algorithms to use when signing a JWT using this keyset.
             *
             * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1}
             */ preferredSigningAlgorithms = iterable instanceof _a ? [
            ...iterable.preferredSigningAlgorithms
        ] : [
            // Prefer elliptic curve algorithms
            'EdDSA',
            'ES256K',
            'ES256',
            // https://datatracker.ietf.org/doc/html/rfc7518#section-3.5
            'PS256',
            'PS384',
            'PS512',
            'HS256',
            'HS384',
            'HS512'
        ]){
            Object.defineProperty(this, "preferredSigningAlgorithms", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: (__runInitializers(this, _instanceExtraInitializers), preferredSigningAlgorithms)
            });
            Object.defineProperty(this, "keys", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            const keys = [];
            const kids = new Set();
            for (const key of iterable){
                if (!key) continue;
                keys.push(key);
                if (key.kid) {
                    if (kids.has(key.kid)) throw new errors_js_1.JwkError(`Duplicate key: ${key.kid}`);
                    else kids.add(key.kid);
                }
            }
            this.keys = Object.freeze(keys);
        }
        get size() {
            return this.keys.length;
        }
        get signAlgorithms() {
            const algorithms = new Set();
            for (const key of this){
                if (key.use !== 'sig') continue;
                for (const alg of key.algorithms){
                    algorithms.add(alg);
                }
            }
            return Object.freeze([
                ...algorithms
            ].sort((0, util_js_1.preferredOrderCmp)(this.preferredSigningAlgorithms)));
        }
        get publicJwks() {
            return {
                keys: Array.from(this, extractPublicJwk).filter(util_js_1.isDefined)
            };
        }
        get privateJwks() {
            return {
                keys: Array.from(this, extractPrivateJwk).filter(util_js_1.isDefined)
            };
        }
        has(kid) {
            return this.keys.some((key)=>key.kid === kid);
        }
        get(search) {
            for (const key of this.list(search)){
                return key;
            }
            throw new errors_js_1.JwkError(`Key not found ${search.kid || search.alg || '<unknown>'}`, errors_js_1.ERR_JWK_NOT_FOUND);
        }
        *list(search) {
            // Optimization: Empty string or empty array will not match any key
            if (search.kid?.length === 0) return;
            if (search.alg?.length === 0) return;
            for (const key of this){
                if (search.use && key.use !== search.use) continue;
                if (Array.isArray(search.kid)) {
                    if (!key.kid || !search.kid.includes(key.kid)) continue;
                } else if (search.kid) {
                    if (key.kid !== search.kid) continue;
                }
                if (Array.isArray(search.alg)) {
                    if (!search.alg.some((a)=>key.algorithms.includes(a))) continue;
                } else if (typeof search.alg === 'string') {
                    if (!key.algorithms.includes(search.alg)) continue;
                }
                yield key;
            }
        }
        findKey({ kid, alg, use }) {
            const matchingKeys = [];
            for (const key of this.list({
                kid,
                alg,
                use
            })){
                // Not a signing key
                if (!key.isPrivate) continue;
                // Skip negotiation if a specific "alg" was provided
                if (typeof alg === 'string') return [
                    key,
                    alg
                ];
                matchingKeys.push(key);
            }
            const isAllowedAlg = (0, util_js_1.matchesAny)(alg);
            const candidates = matchingKeys.map((key)=>[
                    key,
                    key.algorithms.filter(isAllowedAlg)
                ]);
            // Return the first candidates that matches the preferred algorithms
            for (const prefAlg of this.preferredSigningAlgorithms){
                for (const [matchingKey, matchingAlgs] of candidates){
                    if (matchingAlgs.includes(prefAlg)) return [
                        matchingKey,
                        prefAlg
                    ];
                }
            }
            // Return any candidate
            for (const [matchingKey, matchingAlgs] of candidates){
                for (const alg of matchingAlgs){
                    return [
                        matchingKey,
                        alg
                    ];
                }
            }
            throw new errors_js_1.JwkError(`No singing key found for ${kid || alg || use || '<unknown>'}`, errors_js_1.ERR_JWK_NOT_FOUND);
        }
        [(_get_signAlgorithms_decorators = [
            util_js_1.cachedGetter
        ], _get_publicJwks_decorators = [
            util_js_1.cachedGetter
        ], _get_privateJwks_decorators = [
            util_js_1.cachedGetter
        ], Symbol.iterator)]() {
            return this.keys.values();
        }
        async createJwt({ alg: sAlg, kid: sKid, ...header }, payload) {
            try {
                const [key, alg] = this.findKey({
                    alg: sAlg,
                    kid: sKid,
                    use: 'sig'
                });
                const protectedHeader = {
                    ...header,
                    alg,
                    kid: key.kid
                };
                if (typeof payload === 'function') {
                    payload = await payload(protectedHeader, key);
                }
                return await key.createJwt(protectedHeader, payload);
            } catch (err) {
                throw errors_js_1.JwtCreateError.from(err);
            }
        }
        async verifyJwt(token, options) {
            const { header } = (0, jwt_decode_js_1.unsafeDecodeJwt)(token);
            const { kid, alg } = header;
            const errors = [];
            for (const key of this.list({
                kid,
                alg
            })){
                try {
                    const result = await key.verifyJwt(token, options);
                    return {
                        ...result,
                        key
                    };
                } catch (err) {
                    errors.push(err);
                }
            }
            switch(errors.length){
                case 0:
                    throw new errors_js_1.JwtVerifyError('No key matched', errors_js_1.ERR_JWKS_NO_MATCHING_KEY);
                case 1:
                    throw errors_js_1.JwtVerifyError.from(errors[0], errors_js_1.ERR_JWT_INVALID);
                default:
                    throw errors_js_1.JwtVerifyError.from(errors, errors_js_1.ERR_JWT_INVALID);
            }
        }
        toJSON() {
            // Make a copy to prevent mutation of the original keyset
            return structuredClone(this.publicJwks);
        }
    }, (()=>{
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        __esDecorate(_a, null, _get_signAlgorithms_decorators, {
            kind: "getter",
            name: "signAlgorithms",
            static: false,
            private: false,
            access: {
                has: (obj)=>"signAlgorithms" in obj,
                get: (obj)=>obj.signAlgorithms
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_publicJwks_decorators, {
            kind: "getter",
            name: "publicJwks",
            static: false,
            private: false,
            access: {
                has: (obj)=>"publicJwks" in obj,
                get: (obj)=>obj.publicJwks
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        __esDecorate(_a, null, _get_privateJwks_decorators, {
            kind: "getter",
            name: "privateJwks",
            static: false,
            private: false,
            access: {
                has: (obj)=>"privateJwks" in obj,
                get: (obj)=>obj.privateJwks
            },
            metadata: _metadata
        }, null, _instanceExtraInitializers);
        if (_metadata) Object.defineProperty(_a, Symbol.metadata, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _metadata
        });
    })(), _a;
})();
exports.Keyset = Keyset; //# sourceMappingURL=keyset.js.map
}}),
"[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidationError = void 0;
// Since we expose zod schemas, let's expose ZodError (under a generic name) so
// that dependents can catch schema parsing errors without requiring an explicit
// dependency on zod, or risking a conflict in case of mismatching zob versions.
var zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ValidationError", {
    enumerable: true,
    get: function() {
        return zod_1.ZodError;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/alg.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/errors.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwk.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwks.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt-decode.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt-verify.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/jwt.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/key.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/keyset.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk/dist/util.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/jwk-jose/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.either = either;
function either(a, b) {
    if (a != null && b != null && a !== b) {
        throw new TypeError(`Expected "${b}", got "${a}"`);
    }
    return a ?? b ?? undefined;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/jwk-jose/dist/jose-key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JoseKey = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const jose_1 = __turbopack_require__("[project]/node_modules/jose/dist/node/cjs/index.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-jose/dist/util.js [app-ssr] (ecmascript)");
const { JOSEError } = jose_1.errors;
class JoseKey extends jwk_1.Key {
    /**
     * Some runtimes (e.g. Bun) require an `alg` second argument to be set when
     * invoking `importJWK`. In order to be compatible with these runtimes, we
     * provide the following method to ensure the `alg` is always set. We also
     * take the opportunity to ensure that the `alg` is compatible with this key.
     */ async getKeyObj(alg) {
        if (!this.algorithms.includes(alg)) {
            throw new jwk_1.JwkError(`Key cannot be used with algorithm "${alg}"`);
        }
        try {
            return await (0, jose_1.importJWK)(this.jwk, alg);
        } catch (cause) {
            throw new jwk_1.JwkError('Failed to import JWK', undefined, {
                cause
            });
        }
    }
    async createJwt(header, payload) {
        try {
            const { kid } = header;
            if (kid && kid !== this.kid) {
                throw new jwk_1.JwtCreateError(`Invalid "kid" (${kid}) used to sign with key "${this.kid}"`);
            }
            const { alg } = header;
            if (!alg) {
                throw new jwk_1.JwtCreateError('Missing "alg" in JWT header');
            }
            const keyObj = await this.getKeyObj(alg);
            const jwtBuilder = new jose_1.SignJWT(payload).setProtectedHeader({
                ...header,
                alg,
                kid: this.kid
            });
            const signedJwt = await jwtBuilder.sign(keyObj);
            return signedJwt;
        } catch (cause) {
            if (cause instanceof JOSEError) {
                throw new jwk_1.JwtCreateError(cause.message, cause.code, {
                    cause
                });
            } else {
                throw jwk_1.JwtCreateError.from(cause);
            }
        }
    }
    async verifyJwt(token, options) {
        try {
            const result = await (0, jose_1.jwtVerify)(token, async ({ alg })=>this.getKeyObj(alg), {
                ...options,
                algorithms: this.algorithms
            });
            // @NOTE if all tokens are signed exclusively through createJwt(), then
            // there should be no need to parse the payload and headers here. But
            // since the JWT could have been signed with the same key from somewhere
            // else, let's parse it to ensure the integrity (and type safety) of the
            // data.
            const headerParsed = jwk_1.jwtHeaderSchema.safeParse(result.protectedHeader);
            if (!headerParsed.success) {
                throw new jwk_1.JwtVerifyError('Invalid JWT header', undefined, {
                    cause: headerParsed.error
                });
            }
            const payloadParsed = jwk_1.jwtPayloadSchema.safeParse(result.payload);
            if (!payloadParsed.success) {
                throw new jwk_1.JwtVerifyError('Invalid JWT payload', undefined, {
                    cause: payloadParsed.error
                });
            }
            return {
                protectedHeader: headerParsed.data,
                // "requiredClaims" enforced by jwtVerify()
                payload: payloadParsed.data
            };
        } catch (cause) {
            if (cause instanceof JOSEError) {
                throw new jwk_1.JwtVerifyError(cause.message, cause.code, {
                    cause
                });
            } else {
                throw jwk_1.JwtVerifyError.from(cause);
            }
        }
    }
    static async generateKeyPair(allowedAlgos = [
        'ES256'
    ], options) {
        if (!allowedAlgos.length) {
            throw new jwk_1.JwkError('No algorithms provided for key generation');
        }
        const errors = [];
        for (const alg of allowedAlgos){
            try {
                return await (0, jose_1.generateKeyPair)(alg, options);
            } catch (err) {
                errors.push(err);
            }
        }
        throw new jwk_1.JwkError('Failed to generate key pair', undefined, {
            cause: new AggregateError(errors, 'None of the algorithms worked')
        });
    }
    static async generate(allowedAlgos = [
        'ES256'
    ], kid, options) {
        const kp = await this.generateKeyPair(allowedAlgos, {
            ...options,
            extractable: true
        });
        return this.fromImportable(kp.privateKey, kid);
    }
    static async fromImportable(input, kid) {
        if (typeof input === 'string') {
            // PKCS8
            if (input.startsWith('-----')) {
                // The "alg" is only needed in WebCrypto (NodeJS will be fine)
                return this.fromPKCS8(input, '', kid);
            }
            // Jwk (string)
            if (input.startsWith('{')) {
                return this.fromJWK(input, kid);
            }
            throw new jwk_1.JwkError('Invalid input');
        }
        if (typeof input === 'object') {
            // Jwk
            if ('kty' in input || 'alg' in input) {
                return this.fromJWK(input, kid);
            }
            // KeyLike
            return this.fromKeyLike(input, kid);
        }
        throw new jwk_1.JwkError('Invalid input');
    }
    /**
     * @see {@link exportJWK}
     */ static async fromKeyLike(keyLike, kid, alg) {
        const jwk = await (0, jose_1.exportJWK)(keyLike);
        if (alg) {
            if (!jwk.alg) jwk.alg = alg;
            else if (jwk.alg !== alg) throw new jwk_1.JwkError('Invalid "alg" in JWK');
        }
        return this.fromJWK(jwk, kid);
    }
    /**
     * @see {@link importPKCS8}
     */ static async fromPKCS8(pem, alg, kid) {
        const keyLike = await (0, jose_1.importPKCS8)(pem, alg, {
            extractable: true
        });
        return this.fromKeyLike(keyLike, kid);
    }
    static async fromJWK(input, inputKid) {
        const jwk = typeof input === 'string' ? JSON.parse(input) : input;
        if (!jwk || typeof jwk !== 'object') throw new jwk_1.JwkError('Invalid JWK');
        const kid = (0, util_1.either)(jwk.kid, inputKid);
        const use = jwk.use || 'sig';
        return new JoseKey(jwk_1.jwkValidator.parse({
            ...jwk,
            kid,
            use
        }));
    }
}
exports.JoseKey = JoseKey; //# sourceMappingURL=jose-key.js.map
}}),
"[project]/node_modules/@atproto/jwk-jose/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk-jose/dist/jose-key.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/jwk-webcrypto/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toSubtleAlgorithm = toSubtleAlgorithm;
exports.fromSubtleAlgorithm = fromSubtleAlgorithm;
exports.isCryptoKeyPair = isCryptoKeyPair;
function toSubtleAlgorithm(alg, crv, options) {
    switch(alg){
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                name: 'RSA-PSS',
                hash: `SHA-${alg.slice(-3)}`,
                modulusLength: options?.modulusLength ?? 2048,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ])
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.slice(-3)}`,
                modulusLength: options?.modulusLength ?? 2048,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ])
            };
        case 'ES256':
        case 'ES384':
            return {
                name: 'ECDSA',
                namedCurve: `P-${alg.slice(-3)}`
            };
        case 'ES512':
            return {
                name: 'ECDSA',
                namedCurve: 'P-521'
            };
        default:
            // https://github.com/w3c/webcrypto/issues/82#issuecomment-849856773
            throw new TypeError(`Unsupported alg "${alg}"`);
    }
}
function fromSubtleAlgorithm(algorithm) {
    switch(algorithm.name){
        case 'RSA-PSS':
        case 'RSASSA-PKCS1-v1_5':
            {
                const hash = algorithm.hash.name;
                switch(hash){
                    case 'SHA-256':
                    case 'SHA-384':
                    case 'SHA-512':
                        {
                            const prefix = algorithm.name === 'RSA-PSS' ? 'PS' : 'RS';
                            return `${prefix}${hash.slice(-3)}`;
                        }
                    default:
                        throw new TypeError('unsupported RsaHashedKeyAlgorithm hash');
                }
            }
        case 'ECDSA':
            {
                const namedCurve = algorithm.namedCurve;
                switch(namedCurve){
                    case 'P-256':
                    case 'P-384':
                    case 'P-512':
                        return `ES${namedCurve.slice(-3)}`;
                    case 'P-521':
                        return 'ES512';
                    default:
                        throw new TypeError('unsupported EcKeyAlgorithm namedCurve');
                }
            }
        case 'Ed448':
        case 'Ed25519':
            return 'EdDSA';
        default:
            // https://github.com/w3c/webcrypto/issues/82#issuecomment-849856773
            throw new TypeError(`Unexpected algorithm "${algorithm.name}"`);
    }
}
function isCryptoKeyPair(v, extractable) {
    return typeof v === 'object' && v !== null && 'privateKey' in v && v.privateKey instanceof CryptoKey && v.privateKey.type === 'private' && (extractable == null || v.privateKey.extractable === extractable) && v.privateKey.usages.includes('sign') && 'publicKey' in v && v.publicKey instanceof CryptoKey && v.publicKey.type === 'public' && v.publicKey.extractable === true && v.publicKey.usages.includes('verify');
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/jwk-webcrypto/dist/webcrypto-key.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebcryptoKey = exports.jwkWithAlgSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const jwk_jose_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-jose/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __importDefault(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)"));
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/util.js [app-ssr] (ecmascript)");
// Webcrypto keys are bound to a single algorithm
exports.jwkWithAlgSchema = zod_1.default.intersection(jwk_1.jwkSchema, zod_1.default.object({
    alg: zod_1.default.string()
}));
class WebcryptoKey extends jwk_jose_1.JoseKey {
    // We need to override the static method generate from JoseKey because
    // the browser needs both the private and public keys
    static async generate(allowedAlgos = [
        'ES256'
    ], kid = crypto.randomUUID(), options) {
        const keyPair = await this.generateKeyPair(allowedAlgos, options);
        // Type safety only: in the browser, 'jose' always generates a CryptoKeyPair
        if (!(0, util_js_1.isCryptoKeyPair)(keyPair)) {
            throw new TypeError('Invalid CryptoKeyPair');
        }
        return this.fromKeypair(keyPair, kid);
    }
    static async fromKeypair(cryptoKeyPair, kid) {
        // https://datatracker.ietf.org/doc/html/rfc7517
        // > The "use" and "key_ops" JWK members SHOULD NOT be used together; [...]
        // > Applications should specify which of these members they use.
        const { key_ops, use, alg = (0, util_js_1.fromSubtleAlgorithm)(cryptoKeyPair.privateKey.algorithm), ...jwk } = await crypto.subtle.exportKey('jwk', cryptoKeyPair.privateKey.extractable ? cryptoKeyPair.privateKey : cryptoKeyPair.publicKey);
        if (use && use !== 'sig') {
            throw new TypeError(`Unsupported JWK use "${use}"`);
        }
        if (key_ops && !key_ops.some((o)=>o === 'sign' || o === 'verify')) {
            // Make sure that "key_ops", if present, is compatible with "use"
            throw new TypeError(`Invalid key_ops "${key_ops}" for "sig" use`);
        }
        return new WebcryptoKey(exports.jwkWithAlgSchema.parse({
            ...jwk,
            kid,
            alg,
            use: 'sig'
        }), cryptoKeyPair);
    }
    constructor(jwk, cryptoKeyPair){
        super(jwk);
        Object.defineProperty(this, "cryptoKeyPair", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cryptoKeyPair
        });
    }
    get isPrivate() {
        return true;
    }
    get privateJwk() {
        if (super.isPrivate) return this.jwk;
        throw new Error('Private Webcrypto Key not exportable');
    }
    async getKeyObj(alg) {
        if (this.jwk.alg !== alg) {
            throw new jwk_1.JwkError(`Key cannot be used with algorithm "${alg}"`);
        }
        return this.cryptoKeyPair.privateKey;
    }
}
exports.WebcryptoKey = WebcryptoKey; //# sourceMappingURL=webcrypto-key.js.map
}}),
"[project]/node_modules/@atproto/jwk-webcrypto/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/jwk-webcrypto/dist/webcrypto-key.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidDidError = exports.DidError = void 0;
class DidError extends Error {
    constructor(did, message, code, status = 400, cause){
        super(message, {
            cause
        });
        Object.defineProperty(this, "did", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: did
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: status
        });
    }
    /**
     * For compatibility with error handlers in common HTTP frameworks.
     */ get statusCode() {
        return this.status;
    }
    toString() {
        return `${this.constructor.name} ${this.code} (${this.did}): ${this.message}`;
    }
    static from(cause, did) {
        if (cause instanceof DidError) {
            return cause;
        }
        const message = cause instanceof Error ? cause.message : typeof cause === 'string' ? cause : 'An unknown error occurred';
        const status = (typeof cause?.['statusCode'] === 'number' ? cause['statusCode'] : undefined) ?? (typeof cause?.['status'] === 'number' ? cause['status'] : undefined);
        return new DidError(did, message, 'did-unknown-error', status, cause);
    }
}
exports.DidError = DidError;
class InvalidDidError extends DidError {
    constructor(did, message, cause){
        super(did, message, 'did-invalid', 400, cause);
    }
}
exports.InvalidDidError = InvalidDidError; //# sourceMappingURL=did-error.js.map
}}),
"[project]/node_modules/@atproto/did/dist/methods/plc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DID_PLC_PREFIX = void 0;
exports.isDidPlc = isDidPlc;
exports.asDidPlc = asDidPlc;
exports.assertDidPlc = assertDidPlc;
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const DID_PLC_PREFIX = `did:plc:`;
exports.DID_PLC_PREFIX = DID_PLC_PREFIX;
const DID_PLC_PREFIX_LENGTH = DID_PLC_PREFIX.length;
const DID_PLC_LENGTH = 32;
function isDidPlc(input) {
    // Optimization: equivalent to try/catch around "assertDidPlc"
    if (typeof input !== 'string') return false;
    if (input.length !== DID_PLC_LENGTH) return false;
    if (!input.startsWith(DID_PLC_PREFIX)) return false;
    for(let i = DID_PLC_PREFIX_LENGTH; i < DID_PLC_LENGTH; i++){
        if (!isBase32Char(input.charCodeAt(i))) return false;
    }
    return true;
}
function asDidPlc(input) {
    assertDidPlc(input);
    return input;
}
function assertDidPlc(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    }
    if (input.length !== DID_PLC_LENGTH) {
        throw new did_error_js_1.InvalidDidError(input, `did:plc must be ${DID_PLC_LENGTH} characters long`);
    }
    if (!input.startsWith(DID_PLC_PREFIX)) {
        throw new did_error_js_1.InvalidDidError(input, `Invalid did:plc prefix`);
    }
    // The following check is not necessary, as the check below is more strict:
    // assertDidMsid(input, DID_PLC_PREFIX.length)
    for(let i = DID_PLC_PREFIX_LENGTH; i < DID_PLC_LENGTH; i++){
        if (!isBase32Char(input.charCodeAt(i))) {
            throw new did_error_js_1.InvalidDidError(input, `Invalid character at position ${i}`);
        }
    }
}
const isBase32Char = (c)=>c >= 0x61 && c <= 0x7a || c >= 0x32 && c <= 0x37; // [a-z2-7]
 //# sourceMappingURL=plc.js.map
}}),
"[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didSchema = exports.DID_PREFIX = void 0;
exports.assertDidMethod = assertDidMethod;
exports.extractDidMethod = extractDidMethod;
exports.assertDidMsid = assertDidMsid;
exports.assertDid = assertDid;
exports.isDid = isDid;
exports.asDid = asDid;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const DID_PREFIX = 'did:';
exports.DID_PREFIX = DID_PREFIX;
const DID_PREFIX_LENGTH = DID_PREFIX.length;
/**
 * DID Method-name check function.
 *
 * Check if the input is a valid DID method name, at the position between
 * `start` (inclusive) and `end` (exclusive).
 */ function assertDidMethod(input, start = 0, end = input.length) {
    if (!Number.isFinite(end) || !Number.isFinite(start) || end < start || end > input.length) {
        throw new TypeError('Invalid start or end position');
    }
    if (end === start) {
        throw new did_error_js_1.InvalidDidError(input, `Empty method name`);
    }
    let c;
    for(let i = start; i < end; i++){
        c = input.charCodeAt(i);
        if ((c < 0x61 || c > 0x7a) && // a-z
        (c < 0x30 || c > 0x39) // 0-9
        ) {
            throw new did_error_js_1.InvalidDidError(input, `Invalid character at position ${i} in DID method name`);
        }
    }
}
/**
 * This method assumes the input is a valid Did
 */ function extractDidMethod(did) {
    const msidSep = did.indexOf(':', DID_PREFIX_LENGTH);
    const method = did.slice(DID_PREFIX_LENGTH, msidSep);
    return method;
}
/**
 * DID Method-specific identifier check function.
 *
 * Check if the input is a valid DID method-specific identifier, at the position
 * between `start` (inclusive) and `end` (exclusive).
 */ function assertDidMsid(input, start = 0, end = input.length) {
    if (!Number.isFinite(end) || !Number.isFinite(start) || end < start || end > input.length) {
        throw new TypeError('Invalid start or end position');
    }
    if (end === start) {
        throw new did_error_js_1.InvalidDidError(input, `DID method-specific id must not be empty`);
    }
    let c;
    for(let i = start; i < end; i++){
        c = input.charCodeAt(i);
        // Check for frequent chars first
        if ((c < 0x61 || c > 0x7a) && // a-z
        (c < 0x41 || c > 0x5a) && // A-Z
        (c < 0x30 || c > 0x39) && // 0-9
        c !== 0x2e && // .
        c !== 0x2d && // -
        c !== 0x5f // _
        ) {
            // Less frequent chars are checked here
            // ":"
            if (c === 0x3a) {
                if (i === end - 1) {
                    throw new did_error_js_1.InvalidDidError(input, `DID cannot end with ":"`);
                }
                continue;
            }
            // pct-encoded
            if (c === 0x25) {
                c = input.charCodeAt(++i);
                if ((c < 0x30 || c > 0x39) && (c < 0x41 || c > 0x46)) {
                    throw new did_error_js_1.InvalidDidError(input, `Invalid pct-encoded character at position ${i}`);
                }
                c = input.charCodeAt(++i);
                if ((c < 0x30 || c > 0x39) && (c < 0x41 || c > 0x46)) {
                    throw new did_error_js_1.InvalidDidError(input, `Invalid pct-encoded character at position ${i}`);
                }
                // There must always be 2 HEXDIG after a "%"
                if (i >= end) {
                    throw new did_error_js_1.InvalidDidError(input, `Incomplete pct-encoded character at position ${i - 2}`);
                }
                continue;
            }
            throw new did_error_js_1.InvalidDidError(input, `Disallowed character in DID at position ${i}`);
        }
    }
}
function assertDid(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    }
    const { length } = input;
    if (length > 2048) {
        throw new did_error_js_1.InvalidDidError(input, `DID is too long (2048 chars max)`);
    }
    if (!input.startsWith(DID_PREFIX)) {
        throw new did_error_js_1.InvalidDidError(input, `DID requires "${DID_PREFIX}" prefix`);
    }
    const idSep = input.indexOf(':', DID_PREFIX_LENGTH);
    if (idSep === -1) {
        throw new did_error_js_1.InvalidDidError(input, `Missing colon after method name`);
    }
    assertDidMethod(input, DID_PREFIX_LENGTH, idSep);
    assertDidMsid(input, idSep + 1, length);
}
function isDid(input) {
    try {
        assertDid(input);
        return true;
    } catch (err) {
        if (err instanceof did_error_js_1.DidError) {
            return false;
        }
        // Unexpected TypeError (should never happen)
        throw err;
    }
}
function asDid(input) {
    assertDid(input);
    return input;
}
exports.didSchema = zod_1.z.string().superRefine((value, ctx)=>{
    try {
        assertDid(value);
        return true;
    } catch (err) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: err instanceof Error ? err.message : 'Unexpected error'
        });
        return false;
    }
}); //# sourceMappingURL=did.js.map
}}),
"[project]/node_modules/@atproto/did/dist/methods/web.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DID_WEB_PREFIX = void 0;
exports.isDidWeb = isDidWeb;
exports.asDidWeb = asDidWeb;
exports.assertDidWeb = assertDidWeb;
exports.didWebToUrl = didWebToUrl;
exports.urlToDidWeb = urlToDidWeb;
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const did_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)");
exports.DID_WEB_PREFIX = `did:web:`;
/**
 * This function checks if the input is a valid Web DID, as per DID spec.
 */ function isDidWeb(input) {
    // Optimization: make cheap checks first
    if (typeof input !== 'string') return false;
    try {
        assertDidWeb(input);
        return true;
    } catch  {
        return false;
    }
}
function asDidWeb(input) {
    assertDidWeb(input);
    return input;
}
function assertDidWeb(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    }
    void didWebToUrl(input);
}
function didWebToUrl(did) {
    if (!did.startsWith(exports.DID_WEB_PREFIX)) {
        throw new did_error_js_1.InvalidDidError(did, `did:web must start with ${exports.DID_WEB_PREFIX}`);
    }
    if (did.charAt(exports.DID_WEB_PREFIX.length) === ':') {
        throw new did_error_js_1.InvalidDidError(did, 'did:web MSID must not start with a colon');
    }
    // Make sure every char is valid (per DID spec)
    (0, did_js_1.assertDidMsid)(did, exports.DID_WEB_PREFIX.length);
    try {
        const msid = did.slice(exports.DID_WEB_PREFIX.length);
        const parts = msid.split(':').map(decodeURIComponent);
        const url = new URL(`https://${parts.join('/')}`);
        if (url.hostname === 'localhost') {
            url.protocol = 'http:';
        }
        return url;
    } catch (cause) {
        throw new did_error_js_1.InvalidDidError(did, 'Invalid Web DID', cause);
    }
}
function urlToDidWeb(url) {
    const path = url.pathname === '/' ? '' : url.pathname.slice(1).split('/').map(encodeURIComponent).join(':');
    return `did:web:${encodeURIComponent(url.host)}${path ? `:${path}` : ''}`;
} //# sourceMappingURL=web.js.map
}}),
"[project]/node_modules/@atproto/did/dist/methods.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/methods/plc.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/methods/web.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=methods.js.map
}}),
"[project]/node_modules/@atproto/did/dist/atproto.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atprotoDidSchema = void 0;
exports.isAtprotoDid = isAtprotoDid;
exports.asAtprotoDid = asAtprotoDid;
exports.assertAtprotoDid = assertAtprotoDid;
exports.assertAtprotoDidWeb = assertAtprotoDidWeb;
exports.isAtprotoDidWeb = isAtprotoDidWeb;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const did_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)");
const methods_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/methods.js [app-ssr] (ecmascript)");
exports.atprotoDidSchema = zod_1.z.string().refine(isAtprotoDid, `Atproto only allows "plc" and "web" DID methods`);
function isAtprotoDid(input) {
    // Optimized equivalent of:
    // return isDidPlc(input) || isAtprotoDidWeb(input)
    if (typeof input !== 'string') {
        return false;
    } else if (input.startsWith(methods_js_1.DID_PLC_PREFIX)) {
        return (0, methods_js_1.isDidPlc)(input);
    } else if (input.startsWith(methods_js_1.DID_WEB_PREFIX)) {
        return isAtprotoDidWeb(input);
    } else {
        return false;
    }
}
function asAtprotoDid(input) {
    assertAtprotoDid(input);
    return input;
}
function assertAtprotoDid(input) {
    if (typeof input !== 'string') {
        throw new did_error_js_1.InvalidDidError(typeof input, `DID must be a string`);
    } else if (input.startsWith(methods_js_1.DID_PLC_PREFIX)) {
        (0, methods_js_1.assertDidPlc)(input);
    } else if (input.startsWith(methods_js_1.DID_WEB_PREFIX)) {
        assertAtprotoDidWeb(input);
    } else {
        throw new did_error_js_1.InvalidDidError(input, `Atproto only allows "plc" and "web" DID methods`);
    }
}
function assertAtprotoDidWeb(input) {
    (0, methods_js_1.assertDidWeb)(input);
    if (input.includes(':', methods_js_1.DID_WEB_PREFIX.length)) {
        throw new did_error_js_1.InvalidDidError(input, `Atproto does not allow path components in Web DIDs`);
    }
    if (input.includes('%3A', methods_js_1.DID_WEB_PREFIX.length) && !input.startsWith('did:web:localhost%3A')) {
        throw new did_error_js_1.InvalidDidError(input, `Atproto does not allow port numbers in Web DIDs, except for localhost`);
    }
}
/**
 * @see {@link https://atproto.com/specs/did#blessed-did-methods}
 */ function isAtprotoDidWeb(input) {
    try {
        assertAtprotoDidWeb(input);
        return true;
    } catch  {
        return false;
    }
} //# sourceMappingURL=atproto.js.map
}}),
"[project]/node_modules/@atproto/did/dist/did-document.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didDocumentValidator = exports.didDocumentSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const did_js_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)");
/**
 * RFC3968 compliant URI
 *
 * @see {@link https://www.rfc-editor.org/rfc/rfc3986}
 */ const rfc3968UriSchema = zod_1.z.string().refine((data)=>{
    try {
        new URL(data);
        return true;
    } catch  {
        return false;
    }
}, 'RFC3968 compliant URI');
const didControllerSchema = zod_1.z.union([
    did_js_1.didSchema,
    zod_1.z.array(did_js_1.didSchema)
]);
/**
 * @note this schema might be too permissive
 */ const didRelativeUriSchema = zod_1.z.union([
    rfc3968UriSchema,
    zod_1.z.string().regex(/^#[^#]+$/)
]);
const didVerificationMethodSchema = zod_1.z.object({
    id: didRelativeUriSchema,
    type: zod_1.z.string().min(1),
    controller: didControllerSchema,
    publicKeyJwk: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
    publicKeyMultibase: zod_1.z.string().optional()
});
/**
 * The value of the id property MUST be a URI conforming to [RFC3986]. A
 * conforming producer MUST NOT produce multiple service entries with the same
 * id. A conforming consumer MUST produce an error if it detects multiple
 * service entries with the same id.
 *
 * @note Normally, only rfc3968UriSchema should be allowed here. However, the
 *   did:plc uses relative URI. For this reason, we also allow relative URIs
 *   here.
 */ const didServiceIdSchema = didRelativeUriSchema;
/**
 * The value of the type property MUST be a string or a set of strings. In order
 * to maximize interoperability, the service type and its associated properties
 * SHOULD be registered in the DID Specification Registries
 * [DID-SPEC-REGISTRIES].
 */ const didServiceTypeSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.array(zod_1.z.string())
]);
/**
 * The value of the serviceEndpoint property MUST be a string, a map, or a set
 * composed of one or more strings and/or maps. All string values MUST be valid
 * URIs conforming to [RFC3986] and normalized according to the Normalization
 * and Comparison rules in RFC3986 and to any normalization rules in its
 * applicable URI scheme specification.
 */ const didServiceEndpointSchema = zod_1.z.union([
    rfc3968UriSchema,
    zod_1.z.record(zod_1.z.string(), rfc3968UriSchema),
    zod_1.z.array(zod_1.z.union([
        rfc3968UriSchema,
        zod_1.z.record(zod_1.z.string(), rfc3968UriSchema)
    ])).nonempty()
]);
/**
 * Each service map MUST contain id, type, and serviceEndpoint properties.
 * @see {@link https://www.w3.org/TR/did-core/#services}
 */ const didServiceSchema = zod_1.z.object({
    id: didServiceIdSchema,
    type: didServiceTypeSchema,
    serviceEndpoint: didServiceEndpointSchema
});
const didAuthenticationSchema = zod_1.z.union([
    //
    didRelativeUriSchema,
    didVerificationMethodSchema
]);
/**
 * @note This schema is incomplete
 * @see {@link https://www.w3.org/TR/did-core/#production-0}
 */ exports.didDocumentSchema = zod_1.z.object({
    '@context': zod_1.z.union([
        zod_1.z.literal('https://www.w3.org/ns/did/v1'),
        zod_1.z.array(zod_1.z.string().url()).nonempty().refine((data)=>data[0] === 'https://www.w3.org/ns/did/v1', {
            message: 'First @context must be https://www.w3.org/ns/did/v1'
        })
    ]),
    id: did_js_1.didSchema,
    controller: didControllerSchema.optional(),
    alsoKnownAs: zod_1.z.array(rfc3968UriSchema).optional(),
    service: zod_1.z.array(didServiceSchema).optional(),
    authentication: zod_1.z.array(didAuthenticationSchema).optional(),
    verificationMethod: zod_1.z.array(zod_1.z.union([
        didVerificationMethodSchema,
        didRelativeUriSchema
    ])).optional()
});
// @TODO: add other refinements ?
exports.didDocumentValidator = exports.didDocumentSchema// Ensure that every service id is unique
.superRefine(({ id: did, service }, ctx)=>{
    if (service) {
        const visited = new Set();
        for(let i = 0; i < service.length; i++){
            const current = service[i];
            const serviceId = current.id.startsWith('#') ? `${did}${current.id}` : current.id;
            if (!visited.has(serviceId)) {
                visited.add(serviceId);
            } else {
                ctx.addIssue({
                    code: zod_1.z.ZodIssueCode.custom,
                    message: `Duplicate service id (${current.id}) found in the document`,
                    path: [
                        'service',
                        i,
                        'id'
                    ]
                });
            }
        }
    }
}); //# sourceMappingURL=did-document.js.map
}}),
"[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/atproto.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/did-document.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/did-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/did.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/methods.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/lru-cache/dist/commonjs/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
/**
 * @module LRUCache
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LRUCache = void 0;
const perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;
const warned = new Set();
/* c8 ignore start */ const PROCESS = typeof process === 'object' && !!process ? process : {};
/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{
    typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */ if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor(){
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted) return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort){
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = ()=>{
        if (!printACPolyfillWarning) return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */ // This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
/* c8 ignore stop */ class ZeroArray extends Array {
    constructor(size){
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls) return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls){
        /* c8 ignore start */ if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */ this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */ class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */ ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */ ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */ ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */ updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */ updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */ allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */ noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */ noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */ maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */ sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */ noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */ noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */ allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */ allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */ ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */ static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head () {
                return c.#head;
            },
            get tail () {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),
            moveToTail: (index)=>c.#moveToTail(index),
            indexes: (options)=>c.#indexes(options),
            rindexes: (options)=>c.#rindexes(options),
            isStale: (index)=>c.#isStale(index)
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */ get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */ get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */ get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */ get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */ get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */ get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */ get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options){
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined && typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        } else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */ getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now())=>{
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(()=>{
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
        };
        this.#updateItemAge = (index)=>{
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index)=>{
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */ if (!ttl || !start) return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = ()=>{
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
            return n;
        };
        this.getRemainingTTL = (key)=>{
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = (index)=>{
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = ()=>{};
    #statusTTL = ()=>{};
    #setItemTTL = ()=>{};
    /* c8 ignore stop */ #isStale = ()=>false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index)=>{
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation)=>{
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                } else {
                    throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status)=>{
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while(this.#calculatedSize > maxSize){
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = (_i)=>{};
    #addItemSize = (_i, _s, _st)=>{};
    #requireSize = (_k, _v, size, sizeCalculation)=>{
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for(let i = this.#tail; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                } else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for(let i = this.#head; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                } else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */ *entries() {
        for (const i of this.#indexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */ *rentries() {
        for (const i of this.#rindexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */ *keys() {
        for (const i of this.#indexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */ *rkeys() {
        for (const i of this.#rindexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */ *values() {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */ *rvalues() {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */ [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */ find(fn, getOptions = {}) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */ forEach(fn, thisp = this) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */ rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */ purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({
            allowStale: true
        })){
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */ info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined) return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined) return undefined;
        const entry = {
            value
        };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */ dump() {
        const arr = [];
        for (const i of this.#indexes({
            allowStale: true
        })){
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined || key === undefined) continue;
            const entry = {
                value
            };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([
                key,
                entry
            ]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */ load(arr) {
        this.clear();
        for (const [key, entry] of arr){
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */ set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status) status.set = 'add';
            noUpdateTTL = false;
        } else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                s,
                                k,
                                'set'
                            ]);
                        }
                    }
                } else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([
                            oldVal,
                            k,
                            'set'
                        ]);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== undefined) status.oldValue = oldValue;
                }
            } else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status) this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */ pop() {
        try {
            while(this.#size){
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                } else if (val !== undefined) {
                    return val;
                }
            }
        } finally{
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while(task = dt?.shift()){
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([
                    v,
                    k,
                    'evict'
                ]);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        } else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */ has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            } else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        } else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */ peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined || !allowStale && this.#isStale(index)) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', ()=>ac.abort(signal.reason), {
            signal: ac.signal
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context
        };
        const cb = (v, updateCache = false)=>{
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort) options.status.fetchAbortIgnored = true;
                } else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    } else {
                        this.#delete(k, 'fetch');
                    }
                } else {
                    if (options.status) options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er)=>{
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er)=>{
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                } else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            } else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej)=>{
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then((v)=>res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', ()=>{
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = (v)=>cb(v, true);
                    }
                }
            });
        };
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, {
                ...fetchOpts.options,
                status: undefined
            });
            index = this.#keyMap.get(k);
        } else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod) return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
        const { // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status) status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status) status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return p.__returned = p;
        } else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale) status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : v.__returned = v;
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status) status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status) this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined) throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined) return v;
        const vv = memoMethod(k, v, {
            options,
            context
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */ get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status) this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status) status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale) status.returnedStale = true;
                    return allowStale ? value : undefined;
                } else {
                    if (status && allowStale && value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            } else {
                if (status) status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        } else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            } else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */ delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                } else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    } else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                v,
                                k,
                                reason
                            ]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    } else if (index === this.#head) {
                        this.#head = this.#next[index];
                    } else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */ clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({
            allowStale: true
        })){
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            } else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([
                        v,
                        k,
                        reason
                    ]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
    }
}
exports.LRUCache = LRUCache; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store-memory/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.roughSizeOfObject = void 0;
const knownSizes = new WeakMap();
/**
 * @see {@link https://stackoverflow.com/a/11900218/356537}
 */ function roughSizeOfObject(value) {
    const objectList = new Set();
    const stack = [
        value
    ]; // This would be more efficient using a circular buffer
    let bytes = 0;
    while(stack.length){
        const value = stack.pop();
        // > All objects on the heap start with a shape descriptor, which takes one
        // > pointer size (usually 4 bytes these days, thanks to "pointer
        // > compression" on 64-bit platforms).
        switch(typeof value){
            // Types are ordered by frequency
            case 'string':
                // https://stackoverflow.com/a/68791382/356537
                bytes += 12 + 4 * Math.ceil(value.length / 4);
                break;
            case 'number':
                bytes += 12; // Shape descriptor + double
                break;
            case 'boolean':
                bytes += 4; // Shape descriptor
                break;
            case 'object':
                bytes += 4; // Shape descriptor
                if (value === null) {
                    break;
                }
                if (knownSizes.has(value)) {
                    bytes += knownSizes.get(value);
                    break;
                }
                if (objectList.has(value)) continue;
                objectList.add(value);
                if (Array.isArray(value)) {
                    bytes += 4;
                    stack.push(...value);
                } else {
                    bytes += 8;
                    const keys = Object.getOwnPropertyNames(value);
                    for(let i = 0; i < keys.length; i++){
                        bytes += 4;
                        const key = keys[i];
                        const val = value[key];
                        if (val !== undefined) stack.push(val);
                        stack.push(key);
                    }
                }
                break;
            case 'function':
                bytes += 8; // Shape descriptor + pointer (assuming functions are shared)
                break;
            case 'symbol':
                bytes += 8; // Shape descriptor + pointer
                break;
            case 'bigint':
                bytes += 16; // Shape descriptor + BigInt
                break;
        }
    }
    if (typeof value === 'object' && value !== null) {
        knownSizes.set(value, bytes);
    }
    return bytes;
}
exports.roughSizeOfObject = roughSizeOfObject; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SimpleStoreMemory_cache;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SimpleStoreMemory = void 0;
const lru_cache_1 = __turbopack_require__("[project]/node_modules/lru-cache/dist/commonjs/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/util.js [app-ssr] (ecmascript)");
// LRUCache does not allow storing "null", so we use a symbol to represent it.
const nullSymbol = Symbol('nullItem');
const toLruValue = (value)=>value === null ? nullSymbol : value;
const fromLruValue = (value)=>value === nullSymbol ? null : value;
class SimpleStoreMemory {
    constructor({ sizeCalculation, ...options }){
        _SimpleStoreMemory_cache.set(this, void 0);
        __classPrivateFieldSet(this, _SimpleStoreMemory_cache, new lru_cache_1.LRUCache({
            ...options,
            allowStale: false,
            updateAgeOnGet: false,
            updateAgeOnHas: false,
            sizeCalculation: sizeCalculation ? (value, key)=>sizeCalculation(fromLruValue(value), key) : options.maxEntrySize != null || options.maxSize != null ? util_js_1.roughSizeOfObject : undefined
        }), "f");
    }
    get(key) {
        const value = __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").get(key);
        if (value === undefined) return undefined;
        return fromLruValue(value);
    }
    set(key, value) {
        __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").set(key, toLruValue(value));
    }
    del(key) {
        __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").delete(key);
    }
    clear() {
        __classPrivateFieldGet(this, _SimpleStoreMemory_cache, "f").clear();
    }
}
exports.SimpleStoreMemory = SimpleStoreMemory;
_SimpleStoreMemory_cache = new WeakMap(); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache-memory.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidCacheMemory = void 0;
const simple_store_memory_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)");
const DEFAULT_TTL = 3600 * 1000; // 1 hour
const DEFAULT_MAX_SIZE = 50 * 1024 * 1024; // ~50MB
class DidCacheMemory extends simple_store_memory_1.SimpleStoreMemory {
    constructor(options){
        super(options?.max == null ? {
            ttl: DEFAULT_TTL,
            maxSize: DEFAULT_MAX_SIZE,
            ...options
        } : {
            ttl: DEFAULT_TTL,
            ...options
        });
    }
}
exports.DidCacheMemory = DidCacheMemory; //# sourceMappingURL=did-cache-memory.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidResolverCached = void 0;
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const did_cache_memory_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache-memory.js [app-ssr] (ecmascript)");
class DidResolverCached {
    constructor(resolver, cache = new did_cache_memory_js_1.DidCacheMemory()){
        Object.defineProperty(this, "getter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.getter = new simple_store_1.CachedGetter((did, options)=>resolver.resolve(did, options), cache);
    }
    async resolve(did, options) {
        return this.getter.get(did, options);
    }
}
exports.DidResolverCached = DidResolverCached; //# sourceMappingURL=did-cache.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-method.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=did-method.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidResolverBase = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
class DidResolverBase {
    constructor(methods){
        Object.defineProperty(this, "methods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.methods = new Map(Object.entries(methods));
    }
    async resolve(did, options) {
        options?.signal?.throwIfAborted();
        const method = (0, did_1.extractDidMethod)(did);
        const resolver = this.methods.get(method);
        if (!resolver) {
            throw new did_1.DidError(did, `Unsupported DID method`, 'did-method-invalid', 400);
        }
        try {
            const document = await resolver.resolve(did, options);
            if (document.id !== did) {
                throw new did_1.DidError(did, `DID document id (${document.id}) does not match DID`, 'did-document-id-mismatch', 400);
            }
            return document;
        } catch (err) {
            if (err instanceof fetch_1.FetchRequestError) {
                throw new did_1.DidError(did, err.message, 'did-fetch-error', 400, err);
            }
            if (err instanceof zod_1.ZodError) {
                throw new did_1.DidError(did, err.message, 'did-document-format-error', 503, err);
            }
            throw did_1.DidError.from(err, did);
        }
    }
}
exports.DidResolverBase = DidResolverBase; //# sourceMappingURL=did-resolver-base.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/methods/plc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidPlcMethod = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const pipe_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const fetchSuccessHandler = (0, pipe_1.pipe)((0, fetch_1.fetchOkProcessor)(), (0, fetch_1.fetchJsonProcessor)(/^application\/(did\+ld\+)?json$/), (0, fetch_1.fetchJsonZodProcessor)(did_1.didDocumentValidator));
class DidPlcMethod {
    constructor(options){
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "plcDirectoryUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.plcDirectoryUrl = new URL(options?.plcDirectoryUrl || 'https://plc.directory/');
        this.fetch = (0, fetch_1.bindFetch)(options?.fetch);
    }
    async resolve(did, options) {
        // Although the did should start with `did:plc:` (thanks to typings), we
        // should still check if the msid is valid.
        (0, did_1.assertDidPlc)(did);
        const url = new URL(`/${encodeURIComponent(did)}`, this.plcDirectoryUrl);
        return this.fetch(url, {
            redirect: 'error',
            headers: {
                accept: 'application/did+ld+json,application/json'
            },
            signal: options?.signal
        }).then(fetchSuccessHandler);
    }
}
exports.DidPlcMethod = DidPlcMethod; //# sourceMappingURL=plc.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/methods/web.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidWebMethod = void 0;
exports.buildDidWebDocumentUrl = buildDidWebDocumentUrl;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const pipe_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)");
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const fetchSuccessHandler = (0, pipe_1.pipe)((0, fetch_1.fetchOkProcessor)(), (0, fetch_1.fetchJsonProcessor)(/^application\/(did\+ld\+)?json$/), (0, fetch_1.fetchJsonZodProcessor)(did_1.didDocumentValidator));
class DidWebMethod {
    constructor({ fetch = globalThis.fetch, allowHttp = true } = {}){
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttp = allowHttp;
    }
    async resolve(did, options) {
        const didDocumentUrl = buildDidWebDocumentUrl(did);
        if (!this.allowHttp && didDocumentUrl.protocol === 'http:') {
            throw new Error(`Cannot resolve DID document for localhost: ${didDocumentUrl}`);
        }
        // Note we do not explicitly check for "localhost" here. Instead, we rely on
        // the injected 'fetch' function to handle the URL. If the URL is
        // "localhost", or resolves to a private IP address, the fetch function is
        // responsible for handling it.
        return this.fetch(didDocumentUrl, {
            redirect: 'error',
            headers: {
                accept: 'application/did+ld+json,application/json'
            },
            signal: options?.signal
        }).then(fetchSuccessHandler);
    }
}
exports.DidWebMethod = DidWebMethod;
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8615}
 * @see {@link https://w3c-ccg.github.io/did-method-web/#create-register}
 */ function buildDidWebDocumentUrl(did) {
    const url = (0, did_1.didWebToUrl)(did); // Will throw if the DID is invalid
    // Note: DID cannot end with an `:`, so they cannot end with a `/`. This is
    // true unless when there is no path at all, in which case the URL constructor
    // will set the pathname to `/`.
    // https://w3c-ccg.github.io/did-method-web/#read-resolve
    if (url.pathname === '/') {
        return new URL(`/.well-known/did.json`, url);
    } else {
        return new URL(`${url.pathname}/did.json`, url);
    }
} //# sourceMappingURL=web.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-common.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidResolverCommon = void 0;
const did_resolver_base_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-base.js [app-ssr] (ecmascript)");
const plc_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/plc.js [app-ssr] (ecmascript)");
const web_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/web.js [app-ssr] (ecmascript)");
class DidResolverCommon extends did_resolver_base_js_1.DidResolverBase {
    constructor(options){
        super({
            plc: new plc_js_1.DidPlcMethod(options),
            web: new web_js_1.DidWebMethod(options)
        });
    }
}
exports.DidResolverCommon = DidResolverCommon; //# sourceMappingURL=did-resolver-common.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=did-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/methods.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/plc.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods/web.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=methods.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto-labs/did-resolver/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache-memory.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-cache.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-method.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver-common.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/did-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/methods.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/util.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store/dist/cached-getter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CachedGetter = void 0;
const returnTrue = ()=>true;
const returnFalse = ()=>false;
/**
 * Wrapper utility that uses a store to speed up the retrieval of values from an
 * (expensive) getter function.
 */ class CachedGetter {
    constructor(getter, store, options){
        Object.defineProperty(this, "getter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: getter
        });
        Object.defineProperty(this, "store", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: store
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "pending", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    async get(key, options) {
        options?.signal?.throwIfAborted();
        const isStale = this.options?.isStale;
        const allowStored = options?.noCache ? returnFalse // Never allow stored values to be returned
         : options?.allowStale || isStale == null ? returnTrue // Always allow stored values to be returned
         : async (value)=>!await isStale(key, value);
        // As long as concurrent requests are made for the same key, only one
        // request will be made to the cache & getter function at a time. This works
        // because there is no async operation between the while() loop and the
        // pending.set() call. Because of the "single threaded" nature of
        // JavaScript, the pending item will be set before the next iteration of the
        // while loop.
        let previousExecutionFlow;
        while(previousExecutionFlow = this.pending.get(key)){
            try {
                const { isFresh, value } = await previousExecutionFlow;
                if (isFresh) return value;
                if (await allowStored(value)) return value;
            } catch  {
            // Ignore errors from previous execution flows (they will have been
            // propagated by that flow).
            }
            options?.signal?.throwIfAborted();
        }
        const currentExecutionFlow = Promise.resolve().then(async ()=>{
            const storedValue = await this.getStored(key, options);
            if (storedValue !== undefined && await allowStored(storedValue)) {
                // Use the stored value as return value for the current execution
                // flow. Notify other concurrent execution flows (that should be
                // "stuck" in the loop before until this promise resolves) that we got
                // a value, but that it came from the store (isFresh = false).
                return {
                    isFresh: false,
                    value: storedValue
                };
            }
            return Promise.resolve().then(async ()=>(0, this.getter)(key, options, storedValue)).catch(async (err)=>{
                if (storedValue !== undefined) {
                    try {
                        const deleteOnError = this.options?.deleteOnError;
                        if (await deleteOnError?.(err, key, storedValue)) {
                            await this.delStored(key, err);
                        }
                    } catch (error) {
                        throw new AggregateError([
                            err,
                            error
                        ], 'Error while deleting stored value');
                    }
                }
                throw err;
            }).then(async (value)=>{
                // The value should be stored even is the signal was aborted.
                await this.setStored(key, value);
                return {
                    isFresh: true,
                    value
                };
            });
        }).finally(()=>{
            this.pending.delete(key);
        });
        if (this.pending.has(key)) {
            // This should never happen. Indeed, there must not be any 'await'
            // statement between this and the loop iteration check meaning that
            // this.pending.get returned undefined. It is there to catch bugs that
            // would occur in future changes to the code.
            throw new Error('Concurrent request for the same key');
        }
        this.pending.set(key, currentExecutionFlow);
        const { value } = await currentExecutionFlow;
        return value;
    }
    bind(key) {
        return async (options)=>this.get(key, options);
    }
    async getStored(key, options) {
        try {
            return await this.store.get(key, options);
        } catch (err) {
            return undefined;
        }
    }
    async setStored(key, value) {
        try {
            await this.store.set(key, value);
        } catch (err) {
            const onStoreError = this.options?.onStoreError;
            await onStoreError?.(err, key, value);
        }
    }
    async delStored(key, _cause) {
        await this.store.del(key);
    }
}
exports.CachedGetter = CachedGetter; //# sourceMappingURL=cached-getter.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store/dist/simple-store.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=simple-store.js.map
}}),
"[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/cached-getter.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/simple-store.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchError = void 0;
class FetchError extends Error {
    constructor(statusCode, message, options){
        super(message, options);
        Object.defineProperty(this, "statusCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: statusCode
        });
    }
    get expose() {
        return true;
    }
}
exports.FetchError = FetchError; //# sourceMappingURL=fetch-error.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toRequestTransformer = toRequestTransformer;
exports.asRequest = asRequest;
function toRequestTransformer(requestTransformer) {
    return function(input, init) {
        return requestTransformer.call(this, asRequest(input, init));
    };
}
function asRequest(input, init) {
    if (!init && input instanceof Request) return input;
    return new Request(input, init);
} //# sourceMappingURL=fetch.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
// @TODO: Move some of these to a shared package ?
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractUrl = exports.MaxBytesTransformStream = exports.ifString = exports.ifObject = void 0;
exports.isIp = isIp;
exports.padLines = padLines;
exports.cancelBody = cancelBody;
exports.logCancellationError = logCancellationError;
exports.stringifyMessage = stringifyMessage;
function isIp(hostname) {
    // IPv4
    if (hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) return true;
    // IPv6
    if (hostname.startsWith('[') && hostname.endsWith(']')) return true;
    return false;
}
const plainObjectProto = Object.prototype;
const ifObject = (v)=>{
    if (typeof v === 'object' && v != null && !Array.isArray(v)) {
        const proto = Object.getPrototypeOf(v);
        if (proto === null || proto === plainObjectProto) {
            // eslint-disable-next-line @typescript-eslint/ban-types
            return v;
        }
    }
    return undefined;
};
exports.ifObject = ifObject;
const ifString = (v)=>typeof v === 'string' ? v : undefined;
exports.ifString = ifString;
class MaxBytesTransformStream extends TransformStream {
    constructor(maxBytes){
        // Note: negation accounts for invalid value types (NaN, non numbers)
        if (!(maxBytes >= 0)) {
            throw new TypeError('maxBytes must be a non-negative number');
        }
        let bytesRead = 0;
        super({
            transform: (chunk, ctrl)=>{
                if ((bytesRead += chunk.length) <= maxBytes) {
                    ctrl.enqueue(chunk);
                } else {
                    ctrl.error(new Error('Response too large'));
                }
            }
        });
    }
}
exports.MaxBytesTransformStream = MaxBytesTransformStream;
const LINE_BREAK = /\r?\n/g;
function padLines(input, pad) {
    if (!input) return input;
    return pad + input.replace(LINE_BREAK, `$&${pad}`);
}
/**
 * @param [onCancellationError] - Callback that will trigger to asynchronously
 * handle any error that occurs while cancelling the response body. Providing
 * this will speed up the process and avoid potential deadlocks. Defaults to
 * awaiting the cancellation operation. use `"log"` to log the error.
 * @see {@link https://undici.nodejs.org/#/?id=garbage-collection}
 * @note awaiting this function's result, when no `onCancellationError` is
 * provided, might result in a dead lock. Indeed, if the response was cloned(),
 * the response.body.cancel() method will not resolve until the other response's
 * body is consumed/cancelled.
 *
 * @example
 * ```ts
 * // Make sure response was not cloned, or that every cloned response was
 * // consumed/cancelled before awaiting this function's result.
 * await cancelBody(response)
 * ```
 * @example
 * ```ts
 * await cancelBody(response, (err) => {
 *   // No biggie, let's just log the error
 *   console.warn('Failed to cancel response body', err)
 * })
 * ```
 * @example
 * ```ts
 * // Will generate an "unhandledRejection" if an error occurs while cancelling
 * // the response body. This will likely crash the process.
 * await cancelBody(response, (err) => { throw err })
 * ```
 */ async function cancelBody(body, onCancellationError) {
    if (body.body && !body.bodyUsed && !body.body.locked && // Support for alternative fetch implementations
    typeof body.body.cancel === 'function') {
        if (typeof onCancellationError === 'function') {
            void body.body.cancel().catch(onCancellationError);
        } else if (onCancellationError === 'log') {
            void body.body.cancel().catch(logCancellationError);
        } else {
            await body.body.cancel();
        }
    }
}
function logCancellationError(err) {
    console.warn('Failed to cancel response body', err);
}
async function stringifyMessage(input) {
    try {
        const headers = stringifyHeaders(input.headers);
        const payload = await stringifyBody(input);
        return headers && payload ? `${headers}\n${payload}` : headers || payload;
    } finally{
        void cancelBody(input, 'log');
    }
}
function stringifyHeaders(headers) {
    return Array.from(headers).map(([name, value])=>`${name}: ${value}`).join('\n');
}
async function stringifyBody(body) {
    try {
        const blob = await body.blob();
        if (blob.type?.startsWith('text/')) {
            const text = await blob.text();
            return JSON.stringify(text);
        }
        if (/application\/(?:\w+\+)?json/.test(blob.type)) {
            const text = await blob.text();
            return text.includes('\n') ? JSON.stringify(JSON.parse(text)) : text;
        }
        return `[Body size: ${blob.size}, type: ${JSON.stringify(blob.type)} ]`;
    } catch  {
        return '[Body could not be read]';
    }
}
const extractUrl = (input)=>typeof input === 'string' ? new URL(input) : input instanceof URL ? input : new URL(input.url);
exports.extractUrl = extractUrl; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_FORBIDDEN_DOMAIN_NAMES = exports.FetchRequestError = void 0;
exports.protocolCheckRequestTransform = protocolCheckRequestTransform;
exports.redirectCheckRequestTransform = redirectCheckRequestTransform;
exports.requireHostHeaderTransform = requireHostHeaderTransform;
exports.forbiddenDomainNameRequestTransform = forbiddenDomainNameRequestTransform;
const fetch_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)");
const fetch_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)");
class FetchRequestError extends fetch_error_js_1.FetchError {
    constructor(request, statusCode, message, options){
        if (statusCode == null || !message) {
            const info = extractInfo(extractRootCause(options?.cause));
            statusCode ?? (statusCode = info[0]);
            message || (message = info[1]);
        }
        super(statusCode, message, options);
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: request
        });
    }
    get expose() {
        // A 500 request error means that the request was not made due to an infra,
        // programming or server side issue. The message should no be exposed to
        // downstream clients.
        return this.statusCode !== 500;
    }
    static from(request, cause) {
        if (cause instanceof FetchRequestError) return cause;
        return new FetchRequestError(request, undefined, undefined, {
            cause
        });
    }
}
exports.FetchRequestError = FetchRequestError;
function extractRootCause(err) {
    // Unwrap the Network error from undici (i.e. Node's internal fetch() implementation)
    // https://github.com/nodejs/undici/blob/3274c975947ce11a08508743df026f73598bfead/lib/web/fetch/index.js#L223-L228
    if (err instanceof TypeError && err.message === 'fetch failed' && err.cause !== undefined) {
        return err.cause;
    }
    return err;
}
function extractInfo(err) {
    if (typeof err === 'string' && err.length > 0) {
        return [
            500,
            err
        ];
    }
    if (!(err instanceof Error)) {
        return [
            500,
            'Failed to fetch'
        ];
    }
    // Undici fetch() "network" errors
    switch(err.message){
        case 'failed to fetch the data URL':
            return [
                400,
                err.message
            ];
        case 'unexpected redirect':
        case 'cors failure':
        case 'blocked':
        case 'proxy authentication required':
            // These cases could be represented either as a 4xx user error (invalid
            // URL provided), or as a 5xx server error (server didn't behave as
            // expected).
            return [
                502,
                err.message
            ];
    }
    // NodeJS errors
    const code = err['code'];
    if (typeof code === 'string') {
        switch(true){
            case code === 'ENOTFOUND':
                return [
                    400,
                    'Invalid hostname'
                ];
            case code === 'ECONNREFUSED':
                return [
                    502,
                    'Connection refused'
                ];
            case code === 'DEPTH_ZERO_SELF_SIGNED_CERT':
                return [
                    502,
                    'Self-signed certificate'
                ];
            case code.startsWith('ERR_TLS'):
                return [
                    502,
                    'TLS error'
                ];
            case code.startsWith('ECONN'):
                return [
                    502,
                    'Connection error'
                ];
            default:
                return [
                    500,
                    `${code} error`
                ];
        }
    }
    return [
        500,
        err.message
    ];
}
function protocolCheckRequestTransform(protocols) {
    return (input, init)=>{
        const { protocol, port } = (0, util_js_1.extractUrl)(input);
        const request = (0, fetch_js_1.asRequest)(input, init);
        const config = Object.hasOwn(protocols, protocol) ? protocols[protocol] : undefined;
        if (!config) {
            throw new FetchRequestError(request, 400, `Forbidden protocol "${protocol}"`);
        } else if (config === true) {
        // Safe to proceed
        } else if (!config['allowCustomPort'] && port !== '') {
            throw new FetchRequestError(request, 400, `Custom ${protocol} ports not allowed`);
        }
        return request;
    };
}
function redirectCheckRequestTransform() {
    return (input, init)=>{
        const request = (0, fetch_js_1.asRequest)(input, init);
        if (request.redirect === 'follow') {
            throw new FetchRequestError(request, 500, 'Request redirect must be "error" or "manual"');
        }
        return request;
    };
}
function requireHostHeaderTransform() {
    return (input, init)=>{
        // Note that fetch() will automatically add the Host header from the URL and
        // discard any Host header manually set in the request.
        const { protocol, hostname } = (0, util_js_1.extractUrl)(input);
        const request = (0, fetch_js_1.asRequest)(input, init);
        // "Host" header only makes sense in the context of an HTTP request
        if (protocol !== 'http:' && protocol !== 'https:') {
            throw new FetchRequestError(request, 400, `"${protocol}" requests are not allowed`);
        }
        if (!hostname || (0, util_js_1.isIp)(hostname)) {
            throw new FetchRequestError(request, 400, 'Invalid hostname');
        }
        return request;
    };
}
exports.DEFAULT_FORBIDDEN_DOMAIN_NAMES = [
    'example.com',
    '*.example.com',
    'example.org',
    '*.example.org',
    'example.net',
    '*.example.net',
    'googleusercontent.com',
    '*.googleusercontent.com'
];
function forbiddenDomainNameRequestTransform(denyList = exports.DEFAULT_FORBIDDEN_DOMAIN_NAMES) {
    const denySet = new Set(denyList);
    // Optimization: if no forbidden domain names are provided, we can skip the
    // check entirely.
    if (denySet.size === 0) {
        return fetch_js_1.asRequest;
    }
    return async (input, init)=>{
        const { hostname } = (0, util_js_1.extractUrl)(input);
        const request = (0, fetch_js_1.asRequest)(input, init);
        // Full domain name check
        if (denySet.has(hostname)) {
            throw new FetchRequestError(request, 403, 'Forbidden hostname');
        }
        // Sub domain name check
        let curDot = hostname.indexOf('.');
        while(curDot !== -1){
            const subdomain = hostname.slice(curDot + 1);
            if (denySet.has(`*.${subdomain}`)) {
                throw new FetchRequestError(request, 403, 'Forbidden hostname');
            }
            curDot = hostname.indexOf('.', curDot + 1);
        }
        return request;
    };
} //# sourceMappingURL=fetch-request.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/transformed-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TransformedResponse_response;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransformedResponse = void 0;
class TransformedResponse extends Response {
    constructor(response, transform){
        if (!response.body) {
            throw new TypeError('Response body is not available');
        }
        if (response.bodyUsed) {
            throw new TypeError('Response body is already used');
        }
        super(response.body.pipeThrough(transform), {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers
        });
        _TransformedResponse_response.set(this, void 0);
        __classPrivateFieldSet(this, _TransformedResponse_response, response, "f");
    }
    /**
     * Some props can't be set through ResponseInit, so we need to proxy them
     */ get url() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").url;
    }
    get redirected() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").redirected;
    }
    get type() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").type;
    }
    get statusText() {
        return __classPrivateFieldGet(this, _TransformedResponse_response, "f").statusText;
    }
}
exports.TransformedResponse = TransformedResponse;
_TransformedResponse_response = new WeakMap(); //# sourceMappingURL=transformed-response.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchResponseError = void 0;
exports.peekJson = peekJson;
exports.checkLength = checkLength;
exports.extractLength = extractLength;
exports.extractMime = extractMime;
exports.cancelBodyOnError = cancelBodyOnError;
exports.fetchOkProcessor = fetchOkProcessor;
exports.fetchOkTransformer = fetchOkTransformer;
exports.fetchMaxSizeProcessor = fetchMaxSizeProcessor;
exports.fetchResponseMaxSizeChecker = fetchResponseMaxSizeChecker;
exports.fetchTypeProcessor = fetchTypeProcessor;
exports.fetchResponseTypeChecker = fetchResponseTypeChecker;
exports.fetchResponseJsonTransformer = fetchResponseJsonTransformer;
exports.fetchJsonProcessor = fetchJsonProcessor;
exports.fetchJsonZodProcessor = fetchJsonZodProcessor;
const pipe_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)");
const fetch_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)");
const transformed_response_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/transformed-response.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)");
/**
 * media-type     = type "/" subtype *( ";" parameter )
 * type           = token
 * subtype        = token
 * token          = 1*<any CHAR except CTLs or separators>
 * separators     = "(" | ")" | "<" | ">" | "@"
 *                | "," | ";" | ":" | "\" | <">
 *                | "/" | "[" | "]" | "?" | "="
 *                | "{" | "}" | SP | HT
 * CTL            = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * SP             = <US-ASCII SP, space (32)>
 * HT             = <US-ASCII HT, horizontal-tab (9)>
 * @note The type, subtype, and parameter attribute names are case-insensitive.
 * @see {@link https://datatracker.ietf.org/doc/html/rfc2616#autoid-23}
 */ const JSON_MIME = /^application\/(?:[^()<>@,;:/[\]\\?={} \t]+\+)?json$/i;
class FetchResponseError extends fetch_error_js_1.FetchError {
    constructor(response, statusCode = response.status, message = response.statusText, options){
        super(statusCode, message, options);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: response
        });
    }
    static async from(response, customMessage = extractResponseMessage, statusCode = response.status, options) {
        const message = typeof customMessage === 'string' ? customMessage : typeof customMessage === 'function' ? await customMessage(response) : undefined;
        return new FetchResponseError(response, statusCode, message, options);
    }
}
exports.FetchResponseError = FetchResponseError;
const extractResponseMessage = async (response)=>{
    const mimeType = extractMime(response);
    if (!mimeType) return undefined;
    try {
        if (mimeType === 'text/plain') {
            return await response.text();
        } else if (JSON_MIME.test(mimeType)) {
            const json = await response.json();
            if (typeof json === 'string') return json;
            const errorDescription = (0, util_js_1.ifString)((0, util_js_1.ifObject)(json)?.['error_description']);
            if (errorDescription) return errorDescription;
            const error = (0, util_js_1.ifString)((0, util_js_1.ifObject)(json)?.['error']);
            if (error) return error;
            const message = (0, util_js_1.ifString)((0, util_js_1.ifObject)(json)?.['message']);
            if (message) return message;
        }
    } catch  {
    // noop
    }
    return undefined;
};
async function peekJson(response, maxSize = Infinity) {
    const type = extractMime(response);
    if (type !== 'application/json') return undefined;
    checkLength(response, maxSize);
    // 1) Clone the request so we can consume the body
    const clonedResponse = response.clone();
    // 2) Make sure the request's body is not too large
    const limitedResponse = response.body && maxSize < Infinity ? new transformed_response_js_1.TransformedResponse(clonedResponse, new util_js_1.MaxBytesTransformStream(maxSize)) : clonedResponse;
    // 3) Parse the JSON
    return limitedResponse.json();
}
function checkLength(response, maxBytes) {
    // Note: negation accounts for invalid value types (NaN, non numbers)
    if (!(maxBytes >= 0)) {
        throw new TypeError('maxBytes must be a non-negative number');
    }
    const length = extractLength(response);
    if (length != null && length > maxBytes) {
        throw new FetchResponseError(response, 502, 'Response too large');
    }
    return length;
}
function extractLength(response) {
    const contentLength = response.headers.get('Content-Length');
    if (contentLength == null) return undefined;
    if (!/^\d+$/.test(contentLength)) {
        throw new FetchResponseError(response, 502, 'Invalid Content-Length');
    }
    const length = Number(contentLength);
    if (!Number.isSafeInteger(length)) {
        throw new FetchResponseError(response, 502, 'Content-Length too large');
    }
    return length;
}
function extractMime(response) {
    const contentType = response.headers.get('Content-Type');
    if (contentType == null) return undefined;
    return contentType.split(';', 1)[0].trim();
}
/**
 * If the transformer results in an error, ensure that the response body is
 * consumed as, in some environments (Node ), the response will not
 * automatically be GC'd.
 *
 * @see {@link https://undici.nodejs.org/#/?id=garbage-collection}
 * @param [onCancellationError] - Callback to handle any async body cancelling
 * error. Defaults to logging the error. Do not use `null` if the request is
 * cloned.
 */ function cancelBodyOnError(transformer, onCancellationError = util_js_1.logCancellationError) {
    return async (response)=>{
        try {
            return await transformer(response);
        } catch (err) {
            await (0, util_js_1.cancelBody)(response, onCancellationError ?? undefined);
            throw err;
        }
    };
}
function fetchOkProcessor(customMessage) {
    return cancelBodyOnError((response)=>{
        return fetchOkTransformer(response, customMessage);
    });
}
async function fetchOkTransformer(response, customMessage) {
    if (response.ok) return response;
    throw await FetchResponseError.from(response, customMessage);
}
function fetchMaxSizeProcessor(maxBytes) {
    if (maxBytes === Infinity) return (response)=>response;
    if (!Number.isFinite(maxBytes) || maxBytes < 0) {
        throw new TypeError('maxBytes must be a 0, Infinity or a positive number');
    }
    return cancelBodyOnError((response)=>{
        return fetchResponseMaxSizeChecker(response, maxBytes);
    });
}
function fetchResponseMaxSizeChecker(response, maxBytes) {
    if (maxBytes === Infinity) return response;
    checkLength(response, maxBytes);
    // Some engines (react-native ) don't expose a body property. In that case,
    // we will only rely on the Content-Length header.
    if (!response.body) return response;
    const transform = new util_js_1.MaxBytesTransformStream(maxBytes);
    return new transformed_response_js_1.TransformedResponse(response, transform);
}
function fetchTypeProcessor(expectedMime, contentTypeRequired = true) {
    const isExpected = typeof expectedMime === 'string' ? (mimeType)=>mimeType === expectedMime : expectedMime instanceof RegExp ? (mimeType)=>expectedMime.test(mimeType) : expectedMime;
    return cancelBodyOnError((response)=>{
        return fetchResponseTypeChecker(response, isExpected, contentTypeRequired);
    });
}
async function fetchResponseTypeChecker(response, isExpectedMime, contentTypeRequired = true) {
    const mimeType = extractMime(response);
    if (mimeType) {
        if (!isExpectedMime(mimeType.toLowerCase())) {
            throw await FetchResponseError.from(response, `Unexpected response Content-Type (${mimeType})`, 502);
        }
    } else if (contentTypeRequired) {
        throw await FetchResponseError.from(response, 'Missing response Content-Type header', 502);
    }
    return response;
}
async function fetchResponseJsonTransformer(response) {
    try {
        const json = await response.json();
        return {
            response,
            json
        };
    } catch (cause) {
        throw new FetchResponseError(response, 502, 'Unable to parse response as JSON', {
            cause
        });
    }
}
function fetchJsonProcessor(expectedMime = JSON_MIME, contentTypeRequired = true) {
    return (0, pipe_1.pipe)(fetchTypeProcessor(expectedMime, contentTypeRequired), cancelBodyOnError(fetchResponseJsonTransformer));
}
function fetchJsonZodProcessor(schema, params) {
    return async (jsonResponse)=>schema.parseAsync(jsonResponse.json, params);
} //# sourceMappingURL=fetch-response.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/fetch-wrap.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.timedFetch = void 0;
exports.loggedFetch = loggedFetch;
exports.bindFetch = bindFetch;
const fetch_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-request.js [app-ssr] (ecmascript)");
const fetch_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)");
const transformed_response_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/transformed-response.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)");
function loggedFetch({ fetch = globalThis.fetch, logRequest = true, logResponse = true, logError = true }) {
    const onRequest = logRequest === true ? async (request)=>{
        const requestMessage = await (0, util_js_1.stringifyMessage)(request);
        console.info(`> ${request.method} ${request.url}\n${(0, util_js_1.padLines)(requestMessage, '  ')}`);
    } : logRequest || undefined;
    const onResponse = logResponse === true ? async (response)=>{
        const responseMessage = await (0, util_js_1.stringifyMessage)(response.clone());
        console.info(`< HTTP/1.1 ${response.status} ${response.statusText}\n${(0, util_js_1.padLines)(responseMessage, '  ')}`);
    } : logResponse || undefined;
    const onError = logError === true ? async (error)=>{
        console.error(`< Error:`, error);
    } : logError || undefined;
    if (!onRequest && !onResponse && !onError) return fetch;
    return (0, fetch_js_1.toRequestTransformer)(async function(request) {
        if (onRequest) await onRequest(request);
        try {
            const response = await fetch.call(this, request);
            if (onResponse) await onResponse(response, request);
            return response;
        } catch (error) {
            if (onError) await onError(error, request);
            throw error;
        }
    });
}
const timedFetch = (timeout = 60e3, fetch = globalThis.fetch)=>{
    if (timeout === Infinity) return fetch;
    if (!Number.isFinite(timeout) || timeout <= 0) {
        throw new TypeError('Timeout must be positive');
    }
    return (0, fetch_js_1.toRequestTransformer)(async function(request) {
        const controller = new AbortController();
        const signal = controller.signal;
        const abort = ()=>{
            controller.abort();
        };
        const cleanup = ()=>{
            clearTimeout(timer);
            request.signal?.removeEventListener('abort', abort);
        };
        const timer = setTimeout(abort, timeout);
        if (typeof timer === 'object') timer.unref?.(); // only on node
        request.signal?.addEventListener('abort', abort);
        signal.addEventListener('abort', cleanup);
        const response = await fetch.call(this, request, {
            signal
        });
        if (!response.body) {
            cleanup();
            return response;
        } else {
            // Cleanup the timer & event listeners when the body stream is closed
            const transform = new TransformStream({
                flush: cleanup
            });
            return new transformed_response_js_1.TransformedResponse(response, transform);
        }
    });
};
exports.timedFetch = timedFetch;
/**
 * Wraps a fetch function to bind it to a specific context, and wrap any thrown
 * errors into a FetchRequestError.
 *
 * @example
 *
 * ```ts
 * class MyClient {
 *   constructor(private fetch = globalThis.fetch) {}
 *
 *   async get(url: string) {
 *     // This will generate an error, because the context used is not a
 *     // FetchContext (it's a MyClient instance).
 *     return this.fetch(url)
 *   }
 * }
 * ```
 *
 * @example
 *
 * ```ts
 * class MyClient {
 *   private fetch: Fetch<unknown>
 *
 *   constructor(fetch = globalThis.fetch) {
 *     this.fetch = bindFetch(fetch)
 *   }
 *
 *   async get(url: string) {
 *     return this.fetch(url) // no more error
 *   }
 * }
 * ```
 */ function bindFetch(fetch = globalThis.fetch, context = globalThis) {
    return (0, fetch_js_1.toRequestTransformer)(async (request)=>{
        try {
            return await fetch.call(context, request);
        } catch (err) {
            throw fetch_request_js_1.FetchRequestError.from(request, err);
        }
    });
} //# sourceMappingURL=fetch-wrap.js.map
}}),
"[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch-wrap.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/fetch.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/util.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/pipe/dist/pipe.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pipeTwo = exports.pipe = void 0;
function pipe(...pipeline) {
    return pipeline.reduce(pipeTwo);
}
exports.pipe = pipe;
function pipeTwo(first, second) {
    return async (input)=>second(await first(input));
}
exports.pipeTwo = pipeTwo; //# sourceMappingURL=pipe.js.map
}}),
"[project]/node_modules/@atproto-labs/pipe/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pipeTwo = exports.pipe = void 0;
var pipe_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/pipe/dist/pipe.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "pipe", {
    enumerable: true,
    get: function() {
        return pipe_js_1.pipe;
    }
});
Object.defineProperty(exports, "pipeTwo", {
    enumerable: true,
    get: function() {
        return pipe_js_1.pipeTwo;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isResolvedHandle = isResolvedHandle;
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://atproto.com/specs/did#blessed-did-methods}
 */ function isResolvedHandle(value) {
    return value === null || (0, did_1.isAtprotoDid)(value);
} //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/app-view-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppViewHandleResolver = exports.xrpcErrorSchema = void 0;
const zod_1 = __importDefault(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)"));
const types_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)");
exports.xrpcErrorSchema = zod_1.default.object({
    error: zod_1.default.string(),
    message: zod_1.default.string().optional()
});
class AppViewHandleResolver {
    static from(service, options) {
        if (typeof service === 'string' || service instanceof URL) {
            return new AppViewHandleResolver(service, options);
        }
        return service;
    }
    constructor(service, options){
        /**
         * URL of the atproto lexicon server. This is the base URL where the
         * `com.atproto.identity.resolveHandle` XRPC method is located.
         */ Object.defineProperty(this, "serviceUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serviceUrl = new URL(service);
        this.fetch = options?.fetch ?? globalThis.fetch;
    }
    async resolve(handle, options) {
        const url = new URL('/xrpc/com.atproto.identity.resolveHandle', this.serviceUrl);
        url.searchParams.set('handle', handle);
        const response = await this.fetch.call(null, url, {
            cache: options?.noCache ? 'no-cache' : undefined,
            signal: options?.signal,
            redirect: 'error'
        });
        const payload = await response.json();
        // The response should either be
        // - 400 Bad Request with { error: 'InvalidRequest', message: 'Unable to resolve handle' }
        // - 200 OK with { did: NonNullable<ResolvedHandle> }
        // Any other response is considered unexpected behavior an should throw an error.
        if (response.status === 400) {
            const data = exports.xrpcErrorSchema.parse(payload);
            if (data.error === 'InvalidRequest' && data.message === 'Unable to resolve handle') {
                return null;
            }
        }
        if (!response.ok) {
            throw new TypeError('Invalid response from resolveHandle method');
        }
        const value = payload?.did;
        if (!(0, types_js_1.isResolvedHandle)(value)) {
            throw new TypeError('Invalid DID returned from resolveHandle method');
        }
        return value;
    }
}
exports.AppViewHandleResolver = AppViewHandleResolver; //# sourceMappingURL=app-view-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/dns-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DnsHandleResolver = void 0;
const types_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)");
const SUBDOMAIN = '_atproto';
const PREFIX = 'did=';
class DnsHandleResolver {
    constructor(resolveTxt){
        Object.defineProperty(this, "resolveTxt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolveTxt
        });
    }
    async resolve(handle) {
        const results = await this.resolveTxt.call(null, `${SUBDOMAIN}.${handle}`);
        if (!results) return null;
        for(let i = 0; i < results.length; i++){
            // If the line does not start with "did=", skip it
            if (!results[i].startsWith(PREFIX)) continue;
            // Ensure no other entry starting with "did=" follows
            for(let j = i + 1; j < results.length; j++){
                if (results[j].startsWith(PREFIX)) return null;
            }
            // Note: No trimming (to be consistent with spec)
            const did = results[i].slice(PREFIX.length);
            // Invalid DBS record
            return (0, types_1.isResolvedHandle)(did) ? did : null;
        }
        return null;
    }
}
exports.DnsHandleResolver = DnsHandleResolver; //# sourceMappingURL=dns-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/well-known-handler-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WellKnownHandleResolver = void 0;
const types_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)");
class WellKnownHandleResolver {
    constructor(options){
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = options?.fetch ?? globalThis.fetch;
    }
    async resolve(handle, options) {
        const url = new URL('/.well-known/atproto-did', `https://${handle}`);
        try {
            const response = await this.fetch.call(null, url, {
                cache: options?.noCache ? 'no-cache' : undefined,
                signal: options?.signal,
                redirect: 'error'
            });
            const text = await response.text();
            const firstLine = text.split('\n')[0].trim();
            if ((0, types_js_1.isResolvedHandle)(firstLine)) return firstLine;
            return null;
        } catch (err) {
            // The the request failed, assume the handle does not resolve to a DID,
            // unless the failure was due to the signal being aborted.
            options?.signal?.throwIfAborted();
            return null;
        }
    }
}
exports.WellKnownHandleResolver = WellKnownHandleResolver; //# sourceMappingURL=well-known-handler-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtprotoHandleResolver = void 0;
const dns_handle_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/dns-handle-resolver.js [app-ssr] (ecmascript)");
const well_known_handler_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/internal-resolvers/well-known-handler-resolver.js [app-ssr] (ecmascript)");
const noop = ()=>{};
/**
 * Implementation of the official ATPROTO handle resolution strategy.
 * This implementation relies on two primitives:
 * - HTTP Well-Known URI resolution (requires a `fetch()` implementation)
 * - DNS TXT record resolution (requires a `resolveTxt()` function)
 */ class AtprotoHandleResolver {
    constructor(options){
        Object.defineProperty(this, "httpResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dnsResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dnsResolverFallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.httpResolver = new well_known_handler_resolver_js_1.WellKnownHandleResolver(options);
        this.dnsResolver = new dns_handle_resolver_js_1.DnsHandleResolver(options.resolveTxt);
        this.dnsResolverFallback = options.resolveTxtFallback ? new dns_handle_resolver_js_1.DnsHandleResolver(options.resolveTxtFallback) : undefined;
    }
    async resolve(handle, options) {
        options?.signal?.throwIfAborted();
        const abortController = new AbortController();
        const { signal } = abortController;
        options?.signal?.addEventListener('abort', ()=>abortController.abort(), {
            signal
        });
        const wrappedOptions = {
            ...options,
            signal
        };
        try {
            const dnsPromise = this.dnsResolver.resolve(handle, wrappedOptions);
            const httpPromise = this.httpResolver.resolve(handle, wrappedOptions);
            // Prevent uncaught promise rejection
            httpPromise.catch(noop);
            const dnsRes = await dnsPromise;
            if (dnsRes) return dnsRes;
            signal.throwIfAborted();
            const res = await httpPromise;
            if (res) return res;
            signal.throwIfAborted();
            return this.dnsResolverFallback?.resolve(handle, wrappedOptions) ?? null;
        } finally{
            // Cancel pending requests, and remove "abort" listener on incoming signal
            abortController.abort();
        }
    }
}
exports.AtprotoHandleResolver = AtprotoHandleResolver; //# sourceMappingURL=atproto-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-doh-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AtprotoDohHandleResolver = void 0;
const atproto_handle_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-handle-resolver.js [app-ssr] (ecmascript)");
class AtprotoDohHandleResolver extends atproto_handle_resolver_js_1.AtprotoHandleResolver {
    constructor(options){
        super({
            ...options,
            resolveTxt: dohResolveTxtFactory(options),
            resolveTxtFallback: undefined
        });
    }
}
exports.AtprotoDohHandleResolver = AtprotoDohHandleResolver;
/**
 * Resolver for DNS-over-HTTPS (DoH) handles. Only works with servers supporting
 * Google Flavoured "application/dns-json" queries.
 *
 * @see {@link https://developers.google.com/speed/public-dns/docs/doh/json}
 * @see {@link https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/}
 * @todo Add support for DoH using application/dns-message (?)
 */ function dohResolveTxtFactory({ dohEndpoint, fetch = globalThis.fetch }) {
    return async (hostname)=>{
        const url = new URL(dohEndpoint);
        url.searchParams.set('type', 'TXT');
        url.searchParams.set('name', hostname);
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                accept: 'application/dns-json'
            },
            redirect: 'follow'
        });
        try {
            const contentType = response.headers.get('content-type')?.trim();
            if (!response.ok) {
                const message = contentType?.startsWith('text/plain') ? await response.text() : `Failed to resolve ${hostname}`;
                throw new TypeError(message);
            } else if (contentType?.match(/application\/(dns-)?json/i) == null) {
                throw new TypeError('Unexpected response from DoH server');
            }
            const result = asResult(await response.json());
            return result.Answer?.filter(isAnswerTxt).map(extractTxtData) ?? null;
        } finally{
            // Make sure to always cancel the response body as some engines (Node )
            // do not do this automatically.
            // https://undici.nodejs.org/#/?id=garbage-collection
            if (response.bodyUsed === false) {
                // Handle rejection asynchronously
                void response.body?.cancel().catch(onCancelError);
            }
        }
    };
}
function onCancelError(err) {
    if (!(err instanceof DOMException) || err.name !== 'AbortError') {
        console.error('An error occurred while cancelling the response body:', err);
    }
}
function isResult(result) {
    if (typeof result !== 'object' || result === null) return false;
    if (!('Status' in result) || typeof result.Status !== 'number') return false;
    if ('Answer' in result && !isArrayOf(result.Answer, isAnswer)) return false;
    return true;
}
function asResult(result) {
    if (isResult(result)) return result;
    throw new TypeError('Invalid DoH response');
}
function isArrayOf(value, predicate) {
    return Array.isArray(value) && value.every(predicate);
}
function isAnswer(answer) {
    return typeof answer === 'object' && answer !== null && 'name' in answer && typeof answer.name === 'string' && 'type' in answer && typeof answer.type === 'number' && 'data' in answer && typeof answer.data === 'string' && 'TTL' in answer && typeof answer.TTL === 'number';
}
function isAnswerTxt(answer) {
    return answer.type === 16;
}
function extractTxtData(answer) {
    return answer.data.replace(/^"|"$/g, '').replace(/\\"/g, '"');
} //# sourceMappingURL=atproto-doh-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/cached-handle-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CachedHandleResolver = void 0;
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const simple_store_memory_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)");
class CachedHandleResolver {
    constructor(/**
     * The resolver that will be used to resolve handles.
     */ resolver, cache = new simple_store_memory_1.SimpleStoreMemory({
        max: 1000,
        ttl: 10 * 60e3
    })){
        Object.defineProperty(this, "getter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.getter = new simple_store_1.CachedGetter((handle, options)=>resolver.resolve(handle, options), cache);
    }
    async resolve(handle, options) {
        return this.getter.get(handle, options);
    }
}
exports.CachedHandleResolver = CachedHandleResolver; //# sourceMappingURL=cached-handle-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/types.js [app-ssr] (ecmascript)"), exports);
// Main Handle Resolvers strategies
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/app-view-handle-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-doh-handle-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/atproto-handle-resolver.js [app-ssr] (ecmascript)"), exports);
// Handle Resolver Caching utility
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/cached-handle-resolver.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CLIENT_ASSERTION_TYPE_JWT_BEARER = void 0;
exports.CLIENT_ASSERTION_TYPE_JWT_BEARER = 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isHostnameIP = isHostnameIP;
exports.isLoopbackHost = isLoopbackHost;
exports.isLoopbackUrl = isLoopbackUrl;
exports.safeUrl = safeUrl;
exports.extractUrlPath = extractUrlPath;
function isHostnameIP(hostname) {
    // IPv4
    if (hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) return true;
    // IPv6
    if (hostname.startsWith('[') && hostname.endsWith(']')) return true;
    return false;
}
function isLoopbackHost(host) {
    return host === 'localhost' || host === '127.0.0.1' || host === '[::1]';
}
function isLoopbackUrl(input) {
    const url = typeof input === 'string' ? new URL(input) : input;
    return isLoopbackHost(url.hostname);
}
function safeUrl(input) {
    try {
        return new URL(input);
    } catch  {
        return null;
    }
}
function extractUrlPath(url) {
    // Extracts the path from a URL, without relying on the URL constructor
    // (because it normalizes the URL)
    const endOfProtocol = url.startsWith('https://') ? 8 : url.startsWith('http://') ? 7 : -1;
    if (endOfProtocol === -1) {
        throw new TypeError('URL must use the "https:" or "http:" protocol');
    }
    const hashIdx = url.indexOf('#', endOfProtocol);
    const questionIdx = url.indexOf('?', endOfProtocol);
    const queryStrIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx) ? questionIdx : -1;
    const pathEnd = hashIdx === -1 ? queryStrIdx === -1 ? url.length : queryStrIdx : queryStrIdx === -1 ? hashIdx : Math.min(hashIdx, queryStrIdx);
    const slashIdx = url.indexOf('/', endOfProtocol);
    const pathStart = slashIdx === -1 || slashIdx > pathEnd ? pathEnd : slashIdx;
    if (endOfProtocol === pathStart) {
        throw new TypeError('URL must contain a host');
    }
    return url.substring(pathStart, pathEnd);
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.privateUseUriSchema = exports.webUriSchema = exports.httpsUriSchema = exports.loopbackUriSchema = exports.dangerousUriSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)");
/**
 * Valid, but potentially dangerous URL (`data:`, `file:`, `javascript:`, etc.).
 *
 * Any value that matches this schema is safe to parse using `new URL()`.
 */ exports.dangerousUriSchema = zod_1.z.string().refine((data)=>data.includes(':') && URL.canParse(data), {
    message: 'Invalid URL'
});
exports.loopbackUriSchema = exports.dangerousUriSchema.superRefine((value, ctx)=>{
    // Loopback url must use the "http:" protocol
    if (!value.startsWith('http://')) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'URL must use the "http:" protocol'
        });
        return false;
    }
    const url = new URL(value);
    if (!(0, util_js_1.isLoopbackHost)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'URL must use "localhost", "127.0.0.1" or "[::1]" as hostname'
        });
        return false;
    }
    return true;
});
exports.httpsUriSchema = exports.dangerousUriSchema.superRefine((value, ctx)=>{
    if (!value.startsWith('https://')) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'URL must use the "https:" protocol'
        });
        return false;
    }
    const url = new URL(value);
    // Disallow loopback URLs with the `https:` protocol
    if ((0, util_js_1.isLoopbackHost)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'https: URL must not use a loopback host'
        });
        return false;
    }
    if ((0, util_js_1.isHostnameIP)(url.hostname)) {
    // Hostname is an IP address
    } else {
        // Hostname is a domain name
        if (!url.hostname.includes('.')) {
            // we don't depend on PSL here, so we only check for a dot
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: 'Domain name must contain at least two segments'
            });
            return false;
        }
        if (url.hostname.endsWith('.local')) {
            ctx.addIssue({
                code: zod_1.ZodIssueCode.custom,
                message: 'Domain name must not end with ".local"'
            });
            return false;
        }
    }
    return true;
});
exports.webUriSchema = zod_1.z.string().superRefine((value, ctx)=>{
    // discriminated union of `loopbackUriSchema` and `httpsUriSchema`
    if (value.startsWith('http://')) {
        const result = exports.loopbackUriSchema.safeParse(value);
        if (!result.success) result.error.issues.forEach(ctx.addIssue, ctx);
        return result.success;
    }
    if (value.startsWith('https://')) {
        const result = exports.httpsUriSchema.safeParse(value);
        if (!result.success) result.error.issues.forEach(ctx.addIssue, ctx);
        return result.success;
    }
    ctx.addIssue({
        code: zod_1.ZodIssueCode.custom,
        message: 'URL must use the "http:" or "https:" protocol'
    });
    return false;
});
exports.privateUseUriSchema = exports.dangerousUriSchema.superRefine((value, ctx)=>{
    const dotIdx = value.indexOf('.');
    const colonIdx = value.indexOf(':');
    // Optimization: avoid parsing the URL if the protocol does not contain a "."
    if (dotIdx === -1 || colonIdx === -1 || dotIdx > colonIdx) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Private-use URI scheme requires a "." as part of the protocol'
        });
        return false;
    }
    const url = new URL(value);
    // Should be covered by the check before, but let's be extra sure
    if (!url.protocol.includes('.')) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Invalid private-use URI scheme'
        });
        return false;
    }
    if (url.hostname) {
        // https://datatracker.ietf.org/doc/html/rfc8252#section-7.1
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Private-use URI schemes must not include a hostname (only one "/" is allowed after the protocol, as per RFC 8252)'
        });
        return false;
    }
    return true;
}); //# sourceMappingURL=uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientIdSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthClientIdSchema = zod_1.z.string().min(1); //# sourceMappingURL=oauth-client-id.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRedirectUriSchema = exports.oauthPrivateUseRedirectURISchema = exports.oauthHttpsRedirectURISchema = exports.oauthLoopbackRedirectURISchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
exports.oauthLoopbackRedirectURISchema = uri_js_1.loopbackUriSchema.superRefine((value, ctx)=>{
    if (value.startsWith('http://localhost')) {
        // https://datatracker.ietf.org/doc/html/rfc8252#section-8.3
        //
        // > While redirect URIs using localhost (i.e.,
        // > "http://localhost:{port}/{path}") function similarly to loopback IP
        // > redirects described in Section 7.3, the use of localhost is NOT
        // > RECOMMENDED.  Specifying a redirect URI with the loopback IP literal
        // > rather than localhost avoids inadvertently listening on network
        // > interfaces other than the loopback interface.  It is also less
        // > susceptible to client-side firewalls and misconfigured host name
        // > resolution on the user's device.
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: 'Use of "localhost" hostname is not allowed (RFC 8252), use a loopback IP such as "127.0.0.1" instead'
        });
        return false;
    }
    return true;
});
exports.oauthHttpsRedirectURISchema = uri_js_1.httpsUriSchema;
exports.oauthPrivateUseRedirectURISchema = uri_js_1.privateUseUriSchema;
exports.oauthRedirectUriSchema = zod_1.z.union([
    exports.oauthLoopbackRedirectURISchema,
    exports.oauthHttpsRedirectURISchema,
    exports.oauthPrivateUseRedirectURISchema
], {
    message: `URL must use the "https:" or "http:" protocol, or a private-use URI scheme (RFC 8252)`
}); //# sourceMappingURL=oauth-redirect-uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthScopeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
/**
 * A space separated list of most non-control ASCII characters except backslash
 * and double quote.
 *
 * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-1.4.1}
 */ exports.oauthScopeSchema = zod_1.z.string()// scope       = scope-token *( SP scope-token )
// scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
.regex(/^[\x21\x23-\x5B\x5D-\x7E]+(?: [\x21\x23-\x5B\x5D-\x7E]+)*$/); //# sourceMappingURL=oauth-scope.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-loopback.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientIdLoopbackSchema = void 0;
exports.isOAuthClientIdLoopback = isOAuthClientIdLoopback;
exports.assertOAuthLoopbackClientId = assertOAuthLoopbackClientId;
exports.parseOAuthLoopbackClientId = parseOAuthLoopbackClientId;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
const oauth_scope_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)");
const PREFIX = 'http://localhost';
exports.oauthClientIdLoopbackSchema = oauth_client_id_js_1.oauthClientIdSchema.superRefine((value, ctx)=>{
    try {
        assertOAuthLoopbackClientId(value);
        return true;
    } catch (error) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: error instanceof TypeError ? error.message : 'Invalid loopback client ID'
        });
        return false;
    }
});
function isOAuthClientIdLoopback(clientId) {
    try {
        parseOAuthLoopbackClientId(clientId);
        return true;
    } catch  {
        return false;
    }
}
function assertOAuthLoopbackClientId(clientId) {
    void parseOAuthLoopbackClientId(clientId);
}
// @TODO: should we turn this into a zod schema? (more coherent error with other
// validation functions)
function parseOAuthLoopbackClientId(clientId) {
    if (!clientId.startsWith(PREFIX)) {
        throw new TypeError(`Loopback ClientID must start with "${PREFIX}"`);
    } else if (clientId.includes('#', PREFIX.length)) {
        throw new TypeError('Loopback ClientID must not contain a hash component');
    }
    const queryStringIdx = clientId.length > PREFIX.length && clientId[PREFIX.length] === '/' ? PREFIX.length + 1 : PREFIX.length;
    if (clientId.length === queryStringIdx) {
        return {}; // no query string to parse
    }
    if (clientId[queryStringIdx] !== '?') {
        throw new TypeError('Loopback ClientID must not contain a path component');
    }
    const searchParams = new URLSearchParams(clientId.slice(queryStringIdx + 1));
    for (const name of searchParams.keys()){
        if (name !== 'redirect_uri' && name !== 'scope') {
            throw new TypeError(`Invalid query parameter "${name}" in client ID`);
        }
    }
    const scope = searchParams.get('scope') ?? undefined;
    if (scope != null) {
        if (searchParams.getAll('scope').length > 1) {
            throw new TypeError('Loopback ClientID must contain at most one scope query parameter');
        } else if (!oauth_scope_js_1.oauthScopeSchema.safeParse(scope).success) {
            throw new TypeError('Invalid scope query parameter in client ID');
        }
    }
    const redirect_uris = searchParams.has('redirect_uri') ? searchParams.getAll('redirect_uri').map((value)=>oauth_redirect_uri_js_1.oauthLoopbackRedirectURISchema.parse(value)) : undefined;
    return {
        scope,
        redirect_uris
    };
} //# sourceMappingURL=oauth-client-id-loopback.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/atproto-loopback-client-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atprotoLoopbackClientMetadata = atprotoLoopbackClientMetadata;
const oauth_client_id_loopback_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-loopback.js [app-ssr] (ecmascript)");
function atprotoLoopbackClientMetadata(clientId) {
    const { scope = 'atproto', redirect_uris = [
        `http://127.0.0.1/`,
        `http://[::1]/`
    ] } = (0, oauth_client_id_loopback_js_1.parseOAuthLoopbackClientId)(clientId);
    return {
        client_id: clientId,
        scope,
        redirect_uris,
        client_name: 'Loopback client',
        response_types: [
            'code'
        ],
        grant_types: [
            'authorization_code',
            'refresh_token'
        ],
        token_endpoint_auth_method: 'none',
        application_type: 'native',
        dpop_bound_access_tokens: true
    };
} //# sourceMappingURL=atproto-loopback-client-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-access-token.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAccessTokenSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthAccessTokenSchema = zod_1.z.string().min(1); //# sourceMappingURL=oauth-access-token.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-code-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationCodeGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationCodeGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('authorization_code'),
    code: zod_1.z.string().min(1),
    redirect_uri: oauth_redirect_uri_js_1.oauthRedirectUriSchema,
    /** @see {@link https://datatracker.ietf.org/doc/html/rfc7636#section-4.1} */ code_verifier: zod_1.z.string().min(43).max(128).regex(/^[a-zA-Z0-9-._~]+$/).optional()
}); //# sourceMappingURL=oauth-authorization-code-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationDetailsSchema = exports.oauthAuthorizationDetailSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9396#section-2 | RFC 9396, Section 2}
 */ exports.oauthAuthorizationDetailSchema = zod_1.z.object({
    type: zod_1.z.string(),
    /**
     * An array of strings representing the location of the resource or RS. These
     * strings are typically URIs identifying the location of the RS.
     */ locations: zod_1.z.array(uri_js_1.dangerousUriSchema).optional(),
    /**
     * An array of strings representing the kinds of actions to be taken at the
     * resource.
     */ actions: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * An array of strings representing the kinds of data being requested from the
     * resource.
     */ datatypes: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * A string identifier indicating a specific resource available at the API.
     */ identifier: zod_1.z.string().optional(),
    /**
     * An array of strings representing the types or levels of privilege being
     * requested at the resource.
     */ privileges: zod_1.z.array(zod_1.z.string()).optional()
});
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9396#section-2 | RFC 9396, Section 2}
 */ exports.oauthAuthorizationDetailsSchema = zod_1.z.array(exports.oauthAuthorizationDetailSchema); //# sourceMappingURL=oauth-authorization-details.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestJarSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestJarSchema = zod_1.z.object({
    /**
     * AuthorizationRequest inside a JWT:
     * - "iat" is required and **MUST** be less than one minute
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc9101}
     */ request: zod_1.z.union([
        jwk_1.signedJwtSchema,
        jwk_1.unsignedJwtSchema
    ])
}); //# sourceMappingURL=oauth-authorization-request-jar.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-code-challenge-method.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthCodeChallengeMethodSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthCodeChallengeMethodSchema = zod_1.z.enum([
    'S256',
    'plain'
]); //# sourceMappingURL=oauth-code-challenge-method.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthResponseTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthResponseTypeSchema = zod_1.z.enum([
    // OAuth2 (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#section-4.1.1)
    'code',
    'token',
    // OIDC (https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html)
    'none',
    'code id_token token',
    'code id_token',
    'code token',
    'id_token token',
    'id_token'
]); //# sourceMappingURL=oauth-response-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-parameter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oidcClaimsParameterSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oidcClaimsParameterSchema = zod_1.z.enum([
    // https://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html#rfc.section.5.2
    // if client metadata "require_auth_time" is true, this *must* be provided
    'auth_time',
    // OIDC
    'nonce',
    'acr',
    // OpenID: "profile" scope
    'name',
    'family_name',
    'given_name',
    'middle_name',
    'nickname',
    'preferred_username',
    'gender',
    'picture',
    'profile',
    'website',
    'birthdate',
    'zoneinfo',
    'locale',
    'updated_at',
    // OpenID: "email" scope
    'email',
    'email_verified',
    // OpenID: "phone" scope
    'phone_number',
    'phone_number_verified',
    // OpenID: "address" scope
    'address'
]); //# sourceMappingURL=oidc-claims-parameter.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-properties.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oidcClaimsPropertiesSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oidcClaimsValueSchema = zod_1.z.union([
    zod_1.z.string(),
    zod_1.z.number(),
    zod_1.z.boolean()
]);
exports.oidcClaimsPropertiesSchema = zod_1.z.object({
    essential: zod_1.z.boolean().optional(),
    value: oidcClaimsValueSchema.optional(),
    values: zod_1.z.array(oidcClaimsValueSchema).optional()
}); //# sourceMappingURL=oidc-claims-properties.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oidc-entity-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oidcEntityTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oidcEntityTypeSchema = zod_1.z.enum([
    'userinfo',
    'id_token'
]); //# sourceMappingURL=oidc-entity-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestParametersSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_details_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const oauth_code_challenge_method_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-code-challenge-method.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
const oauth_response_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)");
const oauth_scope_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)");
const oidc_claims_parameter_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-parameter.js [app-ssr] (ecmascript)");
const oidc_claims_properties_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-properties.js [app-ssr] (ecmascript)");
const oidc_entity_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-entity-type.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest | OIDC}
 */ exports.oauthAuthorizationRequestParametersSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema,
    state: zod_1.z.string().optional(),
    redirect_uri: oauth_redirect_uri_js_1.oauthRedirectUriSchema.optional(),
    scope: oauth_scope_js_1.oauthScopeSchema.optional(),
    response_type: oauth_response_type_js_1.oauthResponseTypeSchema,
    // PKCE
    code_challenge: zod_1.z.string().optional(),
    code_challenge_method: oauth_code_challenge_method_js_1.oauthCodeChallengeMethodSchema.default('S256').optional(),
    // DPOP
    // https://datatracker.ietf.org/doc/html/rfc9449#section-12.3
    dpop_jkt: zod_1.z.string().optional(),
    // OIDC
    // Default depend on response_type
    response_mode: zod_1.z.enum([
        'query',
        'fragment',
        'form_post'
    ]).optional(),
    nonce: zod_1.z.string().optional(),
    // Specifies the allowable elapsed time in seconds since the last time the
    // End-User was actively authenticated by the OP. If the elapsed time is
    // greater than this value, the OP MUST attempt to actively re-authenticate
    // the End-User. (The max_age request parameter corresponds to the OpenID 2.0
    // PAPE [OpenID.PAPE] max_auth_age request parameter.) When max_age is used,
    // the ID Token returned MUST include an auth_time Claim Value. Note that
    // max_age=0 is equivalent to prompt=login.
    max_age: zod_1.z.number().int().min(0).optional(),
    claims: zod_1.z.record(oidc_entity_type_js_1.oidcEntityTypeSchema, zod_1.z.record(oidc_claims_parameter_js_1.oidcClaimsParameterSchema, zod_1.z.union([
        zod_1.z.literal(null),
        oidc_claims_properties_js_1.oidcClaimsPropertiesSchema
    ]))).optional(),
    // https://openid.net/specs/openid-connect-core-1_0.html#RegistrationParameter
    // Not supported by this library (yet?)
    // registration: clientMetadataSchema.optional(),
    login_hint: zod_1.z.string().min(1).optional(),
    ui_locales: zod_1.z.string().regex(/^[a-z]{2}(-[A-Z]{2})?( [a-z]{2}(-[A-Z]{2})?)*$/) // fr-CA fr en
    .optional(),
    // Previous ID Token, should be provided when prompt=none is used
    id_token_hint: jwk_1.signedJwtSchema.optional(),
    // Type of UI the AS is displayed on
    display: zod_1.z.enum([
        'page',
        'popup',
        'touch',
        'wap'
    ]).optional(),
    /**
     * - "none" will only be allowed if the user already allowed the client on the same device
     * - "login" will force the user to login again, unless he very recently logged in
     * - "consent" will force the user to consent again
     * - "select_account" will force the user to select an account
     */ prompt: zod_1.z.enum([
        'none',
        'login',
        'consent',
        'select_account'
    ]).optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396
    authorization_details: oauth_authorization_details_js_1.oauthAuthorizationDetailsSchema.optional()
}); //# sourceMappingURL=oauth-authorization-request-parameters.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-par.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestParSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_request_jar_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)");
const oauth_authorization_request_parameters_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestParSchema = zod_1.z.union([
    oauth_authorization_request_parameters_js_1.oauthAuthorizationRequestParametersSchema,
    oauth_authorization_request_jar_js_1.oauthAuthorizationRequestJarSchema
]); //# sourceMappingURL=oauth-authorization-request-par.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-request-uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRequestUriSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthRequestUriSchema = zod_1.z.string(); //# sourceMappingURL=oauth-request-uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-uri.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestUriSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_request_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-request-uri.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestUriSchema = zod_1.z.object({
    request_uri: oauth_request_uri_js_1.oauthRequestUriSchema
}); //# sourceMappingURL=oauth-authorization-request-uri.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-query.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationRequestQuerySchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_request_jar_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)");
const oauth_authorization_request_parameters_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)");
const oauth_authorization_request_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-uri.js [app-ssr] (ecmascript)");
exports.oauthAuthorizationRequestQuerySchema = zod_1.z.union([
    oauth_authorization_request_parameters_js_1.oauthAuthorizationRequestParametersSchema,
    oauth_authorization_request_jar_js_1.oauthAuthorizationRequestJarSchema,
    oauth_authorization_request_uri_js_1.oauthAuthorizationRequestUriSchema
]); //# sourceMappingURL=oauth-authorization-request-query.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthIssuerIdentifierSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
exports.oauthIssuerIdentifierSchema = uri_js_1.webUriSchema.superRefine((value, ctx)=>{
    // Validate the issuer (MIX-UP attacks)
    if (value.endsWith('/')) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must not end with a slash'
        });
        return false;
    }
    const url = new URL(value);
    if (url.username || url.password) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must not contain a username or password'
        });
        return false;
    }
    if (url.hash || url.search) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must not contain a query or fragment'
        });
        return false;
    }
    const canonicalValue = url.pathname === '/' ? url.origin : url.href;
    if (value !== canonicalValue) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'Issuer URL must be in the canonical form'
        });
        return false;
    }
    return true;
}); //# sourceMappingURL=oauth-issuer-identifier.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-server-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthAuthorizationServerMetadataValidator = exports.oauthAuthorizationServerMetadataSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_code_challenge_method_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-code-challenge-method.js [app-ssr] (ecmascript)");
const oauth_issuer_identifier_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8414}
 * @note we do not enforce https: scheme in URIs to support development
 * environments. Make sure to validate the URIs before using it in a production
 * environment.
 */ exports.oauthAuthorizationServerMetadataSchema = zod_1.z.object({
    issuer: oauth_issuer_identifier_js_1.oauthIssuerIdentifierSchema,
    claims_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    claims_parameter_supported: zod_1.z.boolean().optional(),
    request_parameter_supported: zod_1.z.boolean().optional(),
    request_uri_parameter_supported: zod_1.z.boolean().optional(),
    require_request_uri_registration: zod_1.z.boolean().optional(),
    scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    subject_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    code_challenge_methods_supported: zod_1.z.array(oauth_code_challenge_method_js_1.oauthCodeChallengeMethodSchema).min(1).optional(),
    ui_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
    id_token_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    display_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    authorization_response_iss_parameter_supported: zod_1.z.boolean().optional(),
    authorization_details_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    request_object_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    jwks_uri: uri_js_1.webUriSchema.optional(),
    authorization_endpoint: uri_js_1.webUriSchema,
    token_endpoint: uri_js_1.webUriSchema,
    token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    revocation_endpoint: uri_js_1.webUriSchema.optional(),
    introspection_endpoint: uri_js_1.webUriSchema.optional(),
    pushed_authorization_request_endpoint: uri_js_1.webUriSchema.optional(),
    require_pushed_authorization_requests: zod_1.z.boolean().optional(),
    userinfo_endpoint: uri_js_1.webUriSchema.optional(),
    end_session_endpoint: uri_js_1.webUriSchema.optional(),
    registration_endpoint: uri_js_1.webUriSchema.optional(),
    // https://datatracker.ietf.org/doc/html/rfc9449#section-5.1
    dpop_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-4
    protected_resources: zod_1.z.array(uri_js_1.webUriSchema).optional(),
    // https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html
    client_id_metadata_document_supported: zod_1.z.boolean().optional()
});
exports.oauthAuthorizationServerMetadataValidator = exports.oauthAuthorizationServerMetadataSchema.superRefine((data, ctx)=>{
    if (data.require_pushed_authorization_requests && !data.pushed_authorization_request_endpoint) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: '"pushed_authorization_request_endpoint" required when "require_pushed_authorization_requests" is true'
        });
    }
}).superRefine((data, ctx)=>{
    if (data.response_types_supported) {
        if (!data.response_types_supported.includes('code')) {
            ctx.addIssue({
                code: zod_1.z.ZodIssueCode.custom,
                message: 'Response type "code" is required'
            });
        }
    }
}); //# sourceMappingURL=oauth-authorization-server-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientCredentialsGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthClientCredentialsGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('client_credentials')
}); //# sourceMappingURL=oauth-client-credentials-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientCredentialsSchema = exports.oauthClientCredentialsNoneSchema = exports.oauthClientCredentialsSecretPostSchema = exports.oauthClientCredentialsJwtBearerSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const constants_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/constants.js [app-ssr] (ecmascript)");
exports.oauthClientCredentialsJwtBearerSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema,
    client_assertion_type: zod_1.z.literal(constants_js_1.CLIENT_ASSERTION_TYPE_JWT_BEARER),
    /**
     * - "sub" the subject MUST be the "client_id" of the OAuth client
     * - "iat" is required and MUST be less than one minute
     * - "aud" must containing a value that identifies the authorization server
     * - The JWT MAY contain a "jti" (JWT ID) claim that provides a unique identifier for the token.
     * - Note that the authorization server may reject JWTs with an "exp" claim value that is unreasonably far in the future.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7523#section-3}
     */ client_assertion: jwk_1.signedJwtSchema
});
exports.oauthClientCredentialsSecretPostSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema,
    client_secret: zod_1.z.string()
});
exports.oauthClientCredentialsNoneSchema = zod_1.z.object({
    client_id: oauth_client_id_js_1.oauthClientIdSchema
});
//
exports.oauthClientCredentialsSchema = zod_1.z.union([
    exports.oauthClientCredentialsJwtBearerSchema,
    exports.oauthClientCredentialsSecretPostSchema,
    // Must be last since it is less specific
    exports.oauthClientCredentialsNoneSchema
]); //# sourceMappingURL=oauth-client-credentials.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-discoverable.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientIdDiscoverableSchema = void 0;
exports.isOAuthClientIdDiscoverable = isOAuthClientIdDiscoverable;
exports.assertOAuthDiscoverableClientId = assertOAuthDiscoverableClientId;
exports.parseOAuthDiscoverableClientId = parseOAuthDiscoverableClientId;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html}
 */ exports.oauthClientIdDiscoverableSchema = zod_1.z.intersection(oauth_client_id_js_1.oauthClientIdSchema, uri_js_1.httpsUriSchema).superRefine((value, ctx)=>{
    const url = new URL(value);
    if (url.username || url.password) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must not contain credentials'
        });
        return false;
    }
    if (url.hash) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must not contain a fragment'
        });
        return false;
    }
    if (url.pathname === '/') {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must contain a path component (e.g. "/client-metadata.json")'
        });
        return false;
    }
    if (url.pathname.endsWith('/')) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID path must not end with a trailing slash'
        });
        return false;
    }
    if ((0, util_js_1.isHostnameIP)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID hostname must not be an IP address'
        });
        return false;
    }
    // URL constructor normalizes the URL, so we extract the path manually to
    // avoid normalization, then compare it to the normalized path to ensure
    // that the URL does not contain path traversal or other unexpected characters
    if ((0, util_js_1.extractUrlPath)(value) !== url.pathname) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `ClientID must be in canonical form ("${url.href}", got "${value}")`
        });
        return false;
    }
    return true;
});
function isOAuthClientIdDiscoverable(clientId) {
    return exports.oauthClientIdDiscoverableSchema.safeParse(clientId).success;
}
function assertOAuthDiscoverableClientId(value) {
    void exports.oauthClientIdDiscoverableSchema.parse(value);
}
function parseOAuthDiscoverableClientId(clientId) {
    return new URL(exports.oauthClientIdDiscoverableSchema.parse(clientId));
} //# sourceMappingURL=oauth-client-id-discoverable.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-auth-method.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthEndpointAuthMethod = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthEndpointAuthMethod = zod_1.z.enum([
    'client_secret_basic',
    'client_secret_jwt',
    'client_secret_post',
    'none',
    'private_key_jwt',
    'self_signed_tls_client_auth',
    'tls_client_auth'
]); //# sourceMappingURL=oauth-endpoint-auth-method.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-grant-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthGrantTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthGrantTypeSchema = zod_1.z.enum([
    'authorization_code',
    'implicit',
    'refresh_token',
    'password',
    'client_credentials',
    'urn:ietf:params:oauth:grant-type:jwt-bearer',
    'urn:ietf:params:oauth:grant-type:saml2-bearer'
]); //# sourceMappingURL=oauth-grant-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-client-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthClientMetadataSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_client_id_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)");
const oauth_endpoint_auth_method_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-auth-method.js [app-ssr] (ecmascript)");
const oauth_grant_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-grant-type.js [app-ssr] (ecmascript)");
const oauth_redirect_uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)");
const oauth_response_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)");
const oauth_scope_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://openid.net/specs/openid-connect-registration-1_0.html}
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7591}
 * @note we do not enforce https: scheme in URIs to support development
 * environments. Make sure to validate the URIs before using it in a production
 * environment.
 */ exports.oauthClientMetadataSchema = zod_1.z.object({
    /**
     * @note redirect_uris require additional validation
     */ redirect_uris: zod_1.z.array(oauth_redirect_uri_js_1.oauthRedirectUriSchema).nonempty(),
    response_types: zod_1.z.array(oauth_response_type_js_1.oauthResponseTypeSchema).nonempty()// > If omitted, the default is that the client will use only the "code"
    // > response type.
    .default([
        'code'
    ]),
    grant_types: zod_1.z.array(oauth_grant_type_js_1.oauthGrantTypeSchema).nonempty()// > If omitted, the default behavior is that the client will use only the
    // > "authorization_code" Grant Type.
    .default([
        'authorization_code'
    ]),
    scope: oauth_scope_js_1.oauthScopeSchema.optional(),
    token_endpoint_auth_method: oauth_endpoint_auth_method_js_1.oauthEndpointAuthMethod.default('none').optional(),
    token_endpoint_auth_signing_alg: zod_1.z.string().optional(),
    userinfo_signed_response_alg: zod_1.z.string().optional(),
    userinfo_encrypted_response_alg: zod_1.z.string().optional(),
    jwks_uri: uri_js_1.webUriSchema.optional(),
    jwks: jwk_1.jwksPubSchema.optional(),
    application_type: zod_1.z.enum([
        'web',
        'native'
    ]).default('web').optional(),
    subject_type: zod_1.z.enum([
        'public',
        'pairwise'
    ]).default('public').optional(),
    request_object_signing_alg: zod_1.z.string().optional(),
    id_token_signed_response_alg: zod_1.z.string().optional(),
    authorization_signed_response_alg: zod_1.z.string().default('RS256').optional(),
    authorization_encrypted_response_enc: zod_1.z.enum([
        'A128CBC-HS256'
    ]).optional(),
    authorization_encrypted_response_alg: zod_1.z.string().optional(),
    client_id: oauth_client_id_js_1.oauthClientIdSchema.optional(),
    client_name: zod_1.z.string().optional(),
    client_uri: uri_js_1.webUriSchema.optional(),
    policy_uri: uri_js_1.webUriSchema.optional(),
    tos_uri: uri_js_1.webUriSchema.optional(),
    logo_uri: uri_js_1.webUriSchema.optional(),
    /**
     * Default Maximum Authentication Age. Specifies that the End-User MUST be
     * actively authenticated if the End-User was authenticated longer ago than
     * the specified number of seconds. The max_age request parameter overrides
     * this default value. If omitted, no default Maximum Authentication Age is
     * specified.
     */ default_max_age: zod_1.z.number().optional(),
    require_auth_time: zod_1.z.boolean().optional(),
    contacts: zod_1.z.array(zod_1.z.string().email()).optional(),
    tls_client_certificate_bound_access_tokens: zod_1.z.boolean().optional(),
    // https://datatracker.ietf.org/doc/html/rfc9449#section-5.2
    dpop_bound_access_tokens: zod_1.z.boolean().optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396#section-14.5
    authorization_details_types: zod_1.z.array(zod_1.z.string()).optional()
}); //# sourceMappingURL=oauth-client-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-name.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAUTH_ENDPOINT_NAMES = void 0;
exports.OAUTH_ENDPOINT_NAMES = [
    'token',
    'revocation',
    'introspection',
    'pushed_authorization_request'
]; //# sourceMappingURL=oauth-endpoint-name.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-introspection-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=oauth-introspection-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-par-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthParResponseSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthParResponseSchema = zod_1.z.object({
    request_uri: zod_1.z.string(),
    expires_in: zod_1.z.number().int().positive()
}); //# sourceMappingURL=oauth-par-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-password-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthPasswordGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthPasswordGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('password'),
    username: zod_1.z.string(),
    password: zod_1.z.string()
}); //# sourceMappingURL=oauth-password-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-protected-resource-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthProtectedResourceMetadataSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_issuer_identifier_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)");
const uri_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#name-protected-resource-metadata-r}
 */ exports.oauthProtectedResourceMetadataSchema = zod_1.z.object({
    /**
     * REQUIRED. The protected resource's resource identifier, which is a URL that
     * uses the https scheme and has no query or fragment components. Using these
     * well-known resources is described in Section 3.
     *
     * @note This schema allows non https URLs for testing & development purposes.
     * Make sure to validate the URL before using it in a production environment.
     */ resource: uri_js_1.webUriSchema.refine((url)=>!url.includes('?'), {
        message: 'Resource URL must not contain query parameters'
    }).refine((url)=>!url.includes('#'), {
        message: 'Resource URL must not contain a fragment'
    }),
    /**
     * OPTIONAL. JSON array containing a list of OAuth authorization server issuer
     * identifiers, as defined in [RFC8414], for authorization servers that can be
     * used with this protected resource. Protected resources MAY choose not to
     * advertise some supported authorization servers even when this parameter is
     * used. In some use cases, the set of authorization servers will not be
     * enumerable, in which case this metadata parameter would not be used.
     */ authorization_servers: zod_1.z.array(oauth_issuer_identifier_js_1.oauthIssuerIdentifierSchema).optional(),
    /**
     * OPTIONAL. URL of the protected resource's JWK Set [JWK] document. This
     * contains public keys belonging to the protected resource, such as signing
     * key(s) that the resource server uses to sign resource responses. This URL
     * MUST use the https scheme. When both signing and encryption keys are made
     * available, a use (public key use) parameter value is REQUIRED for all keys
     * in the referenced JWK Set to indicate each key's intended usage.
     */ jwks_uri: uri_js_1.webUriSchema.optional(),
    /**
     * RECOMMENDED. JSON array containing a list of the OAuth 2.0 [RFC6749] scope
     * values that are used in authorization requests to request access to this
     * protected resource. Protected resources MAY choose not to advertise some
     * scope values supported even when this parameter is used.
     */ scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * OPTIONAL. JSON array containing a list of the supported methods of sending
     * an OAuth 2.0 Bearer Token [RFC6750] to the protected resource. Defined
     * values are ["header", "body", "query"], corresponding to Sections 2.1, 2.2,
     * and 2.3 of RFC 6750.
     */ bearer_methods_supported: zod_1.z.array(zod_1.z.enum([
        'header',
        'body',
        'query'
    ])).optional(),
    /**
     * OPTIONAL. JSON array containing a list of the JWS [JWS] signing algorithms
     * (alg values) [JWA] supported by the protected resource for signing resource
     * responses, for instance, as described in [FAPI.MessageSigning]. No default
     * algorithms are implied if this entry is omitted. The value none MUST NOT be
     * used.
     */ resource_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * OPTIONAL. URL of a page containing human-readable information that
     * developers might want or need to know when using the protected resource
     */ resource_documentation: uri_js_1.webUriSchema.optional(),
    /**
     * OPTIONAL. URL that the protected resource provides to read about the
     * protected resource's requirements on how the client can use the data
     * provided by the protected resource
     */ resource_policy_uri: uri_js_1.webUriSchema.optional(),
    /**
     * OPTIONAL. URL that the protected resource provides to read about the
     * protected resource's terms of service
     */ resource_tos_uri: uri_js_1.webUriSchema.optional()
}); //# sourceMappingURL=oauth-protected-resource-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRefreshTokenSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthRefreshTokenSchema = zod_1.z.string().min(1); //# sourceMappingURL=oauth-refresh-token.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token-grant-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthRefreshTokenGrantTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_refresh_token_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)");
exports.oauthRefreshTokenGrantTokenRequestSchema = zod_1.z.object({
    grant_type: zod_1.z.literal('refresh_token'),
    refresh_token: oauth_refresh_token_js_1.oauthRefreshTokenSchema
}); //# sourceMappingURL=oauth-refresh-token-grant-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-response-mode.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthResponseModeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.oauthResponseModeSchema = zod_1.z.enum([
    'query',
    'fragment',
    'form_post'
]); //# sourceMappingURL=oauth-response-mode.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-identification.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenIdentificationSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_access_token_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-access-token.js [app-ssr] (ecmascript)");
const oauth_refresh_token_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)");
exports.oauthTokenIdentificationSchema = zod_1.z.object({
    token: zod_1.z.union([
        oauth_access_token_js_1.oauthAccessTokenSchema,
        oauth_refresh_token_js_1.oauthRefreshTokenSchema
    ]),
    token_type_hint: zod_1.z.enum([
        'access_token',
        'refresh_token'
    ]).optional()
}); //# sourceMappingURL=oauth-token-identification.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-request.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenRequestSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_code_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-code-grant-token-request.js [app-ssr] (ecmascript)");
const oauth_client_credentials_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials-grant-token-request.js [app-ssr] (ecmascript)");
const oauth_password_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-password-grant-token-request.js [app-ssr] (ecmascript)");
const oauth_refresh_token_grant_token_request_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token-grant-token-request.js [app-ssr] (ecmascript)");
exports.oauthTokenRequestSchema = zod_1.z.discriminatedUnion('grant_type', [
    oauth_authorization_code_grant_token_request_js_1.oauthAuthorizationCodeGrantTokenRequestSchema,
    oauth_refresh_token_grant_token_request_js_1.oauthRefreshTokenGrantTokenRequestSchema,
    oauth_password_grant_token_request_js_1.oauthPasswordGrantTokenRequestSchema,
    oauth_client_credentials_grant_token_request_js_1.oauthClientCredentialsGrantTokenRequestSchema
]); //# sourceMappingURL=oauth-token-request.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-type.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenTypeSchema = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
// Case insensitive input, normalized output
exports.oauthTokenTypeSchema = zod_1.z.union([
    zod_1.z.string().regex(/^DPoP$/i).transform(()=>'DPoP'),
    zod_1.z.string().regex(/^Bearer$/i).transform(()=>'Bearer')
]); //# sourceMappingURL=oauth-token-type.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/oauth-token-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oauthTokenResponseSchema = void 0;
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const oauth_authorization_details_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)");
const oauth_token_type_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-type.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://www.rfc-editor.org/rfc/rfc6749.html#section-5.1 | RFC 6749 (OAuth2), Section 5.1}
 */ exports.oauthTokenResponseSchema = zod_1.z.object({
    // https://www.rfc-editor.org/rfc/rfc6749.html#section-5.1
    access_token: zod_1.z.string(),
    token_type: oauth_token_type_js_1.oauthTokenTypeSchema,
    scope: zod_1.z.string().optional(),
    refresh_token: zod_1.z.string().optional(),
    expires_in: zod_1.z.number().optional(),
    // https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse
    id_token: jwk_1.signedJwtSchema.optional(),
    // https://datatracker.ietf.org/doc/html/rfc9396#name-enriched-authorization-deta
    authorization_details: oauth_authorization_details_js_1.oauthAuthorizationDetailsSchema.optional()
})// https://www.rfc-editor.org/rfc/rfc6749.html#section-5.1
// > The client MUST ignore unrecognized value names in the response.
.passthrough(); //# sourceMappingURL=oauth-token-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/constants.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/util.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/atproto-loopback-client-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-access-token.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-code-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-details.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-jar.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-par.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-parameters.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-query.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-request-uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-authorization-server-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-credentials.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-discoverable.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id-loopback.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-id.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-client-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-auth-method.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-endpoint-name.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-grant-type.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-introspection-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-issuer-identifier.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-par-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-password-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-protected-resource-metadata.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-redirect-uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token-grant-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-refresh-token.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-request-uri.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-mode.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-response-type.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-scope.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-identification.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-request.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-response.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oauth-token-type.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-parameter.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-claims-properties.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/oidc-entity-type.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.includesSpaceSeparatedValue = exports.CustomEventTarget = exports.CustomEvent = exports.timeoutSignal = void 0;
exports.contentMime = contentMime;
exports.combineSignals = combineSignals;
// @ts-expect-error
Symbol.dispose ?? (Symbol.dispose = Symbol('@@dispose'));
/**
 * @todo (?) move to common package
 */ const timeoutSignal = (timeout, options)=>{
    if (!Number.isInteger(timeout) || timeout < 0) {
        throw new TypeError('Expected a positive integer');
    }
    options?.signal?.throwIfAborted();
    const controller = new AbortController();
    const { signal } = controller;
    options?.signal?.addEventListener('abort', (reason)=>controller.abort(reason), {
        once: true,
        signal
    });
    const timeoutId = setTimeout((err)=>controller.abort(err), timeout, // create Error here to keep original stack trace
    new Error('Timeout'));
    timeoutId?.unref?.(); // NodeJS only
    signal.addEventListener('abort', ()=>clearTimeout(timeoutId), {
        once: true,
        signal
    });
    Object.defineProperty(signal, Symbol.dispose, {
        value: ()=>controller.abort()
    });
    return signal;
};
exports.timeoutSignal = timeoutSignal;
function contentMime(headers) {
    return headers.get('content-type')?.split(';')[0].trim();
}
/**
 * Ponyfill for `CustomEvent` constructor.
 */ exports.CustomEvent = globalThis.CustomEvent ?? (()=>{
    var _CustomEvent_detail;
    class CustomEvent extends Event {
        constructor(type, options){
            if (!arguments.length) throw new TypeError('type argument is required');
            super(type, options);
            _CustomEvent_detail.set(this, void 0);
            __classPrivateFieldSet(this, _CustomEvent_detail, options?.detail ?? null, "f");
        }
        get detail() {
            return __classPrivateFieldGet(this, _CustomEvent_detail, "f");
        }
    }
    _CustomEvent_detail = new WeakMap();
    Object.defineProperties(CustomEvent.prototype, {
        [Symbol.toStringTag]: {
            writable: false,
            enumerable: false,
            configurable: true,
            value: 'CustomEvent'
        },
        detail: {
            enumerable: true
        }
    });
    return CustomEvent;
})();
class CustomEventTarget {
    constructor(){
        Object.defineProperty(this, "eventTarget", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventTarget()
        });
    }
    addEventListener(type, callback, options) {
        this.eventTarget.addEventListener(type, callback, options);
    }
    removeEventListener(type, callback, options) {
        this.eventTarget.removeEventListener(type, callback, options);
    }
    dispatchCustomEvent(type, detail, init) {
        return this.eventTarget.dispatchEvent(new exports.CustomEvent(type, {
            ...init,
            detail
        }));
    }
}
exports.CustomEventTarget = CustomEventTarget;
const includesSpaceSeparatedValue = (input, value)=>{
    if (value.length === 0) throw new TypeError('Value cannot be empty');
    if (value.includes(' ')) throw new TypeError('Value cannot contain spaces');
    // Optimized version of:
    // return input.split(' ').includes(value)
    const inputLength = input.length;
    const valueLength = value.length;
    if (inputLength < valueLength) return false;
    let idx = input.indexOf(value);
    let idxEnd;
    while(idx !== -1){
        idxEnd = idx + valueLength;
        if (// at beginning or preceded by space
        (idx === 0 || input[idx - 1] === ' ') && // at end or followed by space
        (idxEnd === inputLength || input[idxEnd] === ' ')) {
            return true;
        }
        idx = input.indexOf(value, idxEnd + 1);
    }
    return false;
};
exports.includesSpaceSeparatedValue = includesSpaceSeparatedValue;
function combineSignals(signals) {
    const controller = new AbortController();
    const onAbort = function(_event) {
        const reason = new Error('This operation was aborted', {
            cause: this.reason
        });
        controller.abort(reason);
    };
    for (const sig of signals){
        if (!sig) continue;
        if (sig.aborted) {
            // Remove "abort" listener that was added to sig in previous iterations
            controller.abort();
            throw new Error('One of the signals is already aborted', {
                cause: sig.reason
            });
        }
        sig.addEventListener('abort', onAbort, {
            signal: controller.signal
        });
    }
    controller[Symbol.dispose] = ()=>{
        const reason = new Error('AbortController was disposed');
        controller.abort(reason);
    };
    return controller;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-authorization-server-metadata-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthAuthorizationServerMetadataResolver = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8414}
 */ class OAuthAuthorizationServerMetadataResolver extends simple_store_1.CachedGetter {
    constructor(cache, fetch, config){
        super(async (issuer, options)=>this.fetchMetadata(issuer, options), cache);
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttpIssuer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttpIssuer = config?.allowHttpIssuer === true;
    }
    async get(input, options) {
        const issuer = oauth_types_1.oauthIssuerIdentifierSchema.parse(input);
        if (!this.allowHttpIssuer && issuer.startsWith('http:')) {
            throw new TypeError('Unsecure issuer URL protocol only allowed in development and test environments');
        }
        return super.get(issuer, options);
    }
    async fetchMetadata(issuer, options) {
        const url = new URL(`/.well-known/oauth-authorization-server`, issuer);
        const request = new Request(url, {
            headers: {
                accept: 'application/json'
            },
            cache: options?.noCache ? 'no-cache' : undefined,
            signal: options?.signal,
            redirect: 'manual'
        });
        const response = await this.fetch(request);
        // https://datatracker.ietf.org/doc/html/rfc8414#section-3.2
        if (response.status !== 200) {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected status code ${response.status} for "${url}"`, undefined, {
                cause: request
            });
        }
        if ((0, util_js_1.contentMime)(response.headers) !== 'application/json') {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected content type for "${url}"`, undefined, {
                cause: request
            });
        }
        const metadata = oauth_types_1.oauthAuthorizationServerMetadataValidator.parse(await response.json());
        // Validate the issuer (MIX-UP attacks)
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-mix-up-attacks
        // https://datatracker.ietf.org/doc/html/rfc8414#section-2
        if (metadata.issuer !== issuer) {
            throw new TypeError(`Invalid issuer ${metadata.issuer}`);
        }
        // ATPROTO requires client_id_metadata_document
        // http://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html
        if (metadata.client_id_metadata_document_supported !== true) {
            throw new TypeError(`Authorization server "${issuer}" does not support client_id_metadata_document`);
        }
        return metadata;
    }
}
exports.OAuthAuthorizationServerMetadataResolver = OAuthAuthorizationServerMetadataResolver; //# sourceMappingURL=oauth-authorization-server-metadata-resolver.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-callback-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthCallbackError = void 0;
class OAuthCallbackError extends Error {
    static from(err, params, state) {
        if (err instanceof OAuthCallbackError) return err;
        const message = err instanceof Error ? err.message : undefined;
        return new OAuthCallbackError(params, message, state, err);
    }
    constructor(params, message = params.get('error_description') || 'OAuth callback error', state, cause){
        super(message, {
            cause
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: params
        });
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: state
        });
    }
}
exports.OAuthCallbackError = OAuthCallbackError; //# sourceMappingURL=oauth-callback-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FALLBACK_ALG = void 0;
/**
 * Per ATProto spec (OpenID uses RS256)
 */ exports.FALLBACK_ALG = 'ES256'; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenRevokedError = void 0;
class TokenRevokedError extends Error {
    constructor(sub, message = `The session for "${sub}" was successfully revoked`, options){
        super(message, options);
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
    }
}
exports.TokenRevokedError = TokenRevokedError; //# sourceMappingURL=token-revoked-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-protected-resource-metadata-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthProtectedResourceMetadataResolver = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
/**
 * @see {@link https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05}
 */ class OAuthProtectedResourceMetadataResolver extends simple_store_1.CachedGetter {
    constructor(cache, fetch = globalThis.fetch, config){
        super(async (origin, options)=>this.fetchMetadata(origin, options), cache);
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttpResource", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttpResource = config?.allowHttpResource === true;
    }
    async get(resource, options) {
        const { protocol, origin } = new URL(resource);
        if (protocol !== 'https:' && protocol !== 'http:') {
            throw new TypeError(`Invalid protected resource metadata URL protocol: ${protocol}`);
        }
        if (protocol === 'http:' && !this.allowHttpResource) {
            throw new TypeError(`Unsecure resource metadata URL (${protocol}) only allowed in development and test environments`);
        }
        return super.get(origin, options);
    }
    async fetchMetadata(origin, options) {
        const url = new URL(`/.well-known/oauth-protected-resource`, origin);
        const request = new Request(url, {
            signal: options?.signal,
            headers: {
                accept: 'application/json'
            },
            cache: options?.noCache ? 'no-cache' : undefined,
            redirect: 'manual'
        });
        const response = await this.fetch(request);
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-3.2
        if (response.status !== 200) {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected status code ${response.status} for "${url}"`, undefined, {
                cause: request
            });
        }
        if ((0, util_js_1.contentMime)(response.headers) !== 'application/json') {
            await (0, fetch_1.cancelBody)(response, 'log');
            throw await fetch_1.FetchResponseError.from(response, `Unexpected content type for "${url}"`, undefined, {
                cause: request
            });
        }
        const metadata = oauth_types_1.oauthProtectedResourceMetadataSchema.parse(await response.json());
        // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-3.3
        if (metadata.resource !== origin) {
            throw new TypeError(`Invalid issuer ${metadata.resource}`);
        }
        return metadata;
    }
}
exports.OAuthProtectedResourceMetadataResolver = OAuthProtectedResourceMetadataResolver; //# sourceMappingURL=oauth-protected-resource-metadata-resolver.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthResolverError = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
class OAuthResolverError extends Error {
    constructor(message, options){
        super(message, options);
    }
    static from(cause, message) {
        if (cause instanceof OAuthResolverError) return cause;
        const validationReason = cause instanceof zod_1.ZodError ? `${cause.errors[0].path} ${cause.errors[0].message}` : null;
        const fullMessage = (message ?? `Unable to resolve identity`) + (validationReason ? ` (${validationReason})` : '');
        return new OAuthResolverError(fullMessage, {
            cause
        });
    }
}
exports.OAuthResolverError = OAuthResolverError; //# sourceMappingURL=oauth-resolver-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthResolver = void 0;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const oauth_resolver_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver-error.js [app-ssr] (ecmascript)");
class OAuthResolver {
    constructor(identityResolver, protectedResourceMetadataResolver, authorizationServerMetadataResolver){
        Object.defineProperty(this, "identityResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityResolver
        });
        Object.defineProperty(this, "protectedResourceMetadataResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: protectedResourceMetadataResolver
        });
        Object.defineProperty(this, "authorizationServerMetadataResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: authorizationServerMetadataResolver
        });
    }
    /**
     * @param input - A handle, DID, PDS URL or Entryway URL
     */ async resolve(input, options) {
        // Allow using an entryway, or PDS url, directly as login input (e.g.
        // when the user forgot their handle, or when the handle does not
        // resolve to a DID)
        return /^https?:\/\//.test(input) ? this.resolveFromService(input, options) : this.resolveFromIdentity(input, options);
    }
    /**
     * @note this method can be used to verify if a particular uri supports OAuth
     * based sign-in (for compatibility with legacy implementation).
     */ async resolveFromService(input, options) {
        try {
            // Assume first that input is a PDS URL (as required by ATPROTO)
            const metadata = await this.getResourceServerMetadata(input, options);
            return {
                metadata
            };
        } catch (err) {
            if (!options?.signal?.aborted && err instanceof oauth_resolver_error_js_1.OAuthResolverError) {
                try {
                    // Fallback to trying to fetch as an issuer (Entryway)
                    const result = oauth_types_1.oauthIssuerIdentifierSchema.safeParse(input);
                    if (result.success) {
                        const metadata = await this.getAuthorizationServerMetadata(result.data, options);
                        return {
                            metadata
                        };
                    }
                } catch  {
                // Fallback failed, throw original error
                }
            }
            throw err;
        }
    }
    async resolveFromIdentity(input, options) {
        const identity = await this.resolveIdentity(input, options);
        options?.signal?.throwIfAborted();
        const metadata = await this.getResourceServerMetadata(identity.pds, options);
        return {
            identity,
            metadata
        };
    }
    async resolveIdentity(input, options) {
        try {
            return await this.identityResolver.resolve(input, options);
        } catch (cause) {
            throw oauth_resolver_error_js_1.OAuthResolverError.from(cause, `Failed to resolve identity: ${input}`);
        }
    }
    async getAuthorizationServerMetadata(issuer, options) {
        try {
            return await this.authorizationServerMetadataResolver.get(issuer, options);
        } catch (cause) {
            throw oauth_resolver_error_js_1.OAuthResolverError.from(cause, `Failed to resolve OAuth server metadata for issuer: ${issuer}`);
        }
    }
    async getResourceServerMetadata(pdsUrl, options) {
        try {
            const rsMetadata = await this.protectedResourceMetadataResolver.get(pdsUrl, options);
            // ATPROTO requires one, and only one, authorization server entry
            if (rsMetadata.authorization_servers?.length !== 1) {
                throw new oauth_resolver_error_js_1.OAuthResolverError(rsMetadata.authorization_servers?.length ? `Unable to determine authorization server for PDS: ${pdsUrl}` : `No authorization servers found for PDS: ${pdsUrl}`);
            }
            const issuer = rsMetadata.authorization_servers[0];
            options?.signal?.throwIfAborted();
            const asMetadata = await this.getAuthorizationServerMetadata(issuer, options);
            // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata-05#section-4
            if (asMetadata.protected_resources) {
                if (!asMetadata.protected_resources.includes(rsMetadata.resource)) {
                    throw new oauth_resolver_error_js_1.OAuthResolverError(`PDS "${pdsUrl}" not protected by issuer "${issuer}"`);
                }
            }
            return asMetadata;
        } catch (cause) {
            throw oauth_resolver_error_js_1.OAuthResolverError.from(cause, `Failed to resolve OAuth server metadata for resource: ${pdsUrl}`);
        }
    }
}
exports.OAuthResolver = OAuthResolver; //# sourceMappingURL=oauth-resolver.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/atproto-token-response.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atprotoTokenResponseSchema = exports.atprotoScopeSchema = exports.isAtprotoScope = void 0;
const did_1 = __turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
const util_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
const isAtprotoScope = (input)=>(0, util_1.includesSpaceSeparatedValue)(input, 'atproto');
exports.isAtprotoScope = isAtprotoScope;
exports.atprotoScopeSchema = zod_1.z.string().refine(exports.isAtprotoScope, 'The "atproto" scope is required');
exports.atprotoTokenResponseSchema = oauth_types_1.oauthTokenResponseSchema.extend({
    token_type: zod_1.z.literal('DPoP'),
    sub: did_1.atprotoDidSchema,
    scope: exports.atprotoScopeSchema,
    // OpenID is not compatible with atproto identities
    id_token: zod_1.z.never().optional()
}); //# sourceMappingURL=atproto-token-response.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenRefreshError = void 0;
class TokenRefreshError extends Error {
    constructor(sub, message, options){
        super(message, options);
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
    }
}
exports.TokenRefreshError = TokenRefreshError; //# sourceMappingURL=token-refresh-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/fetch-dpop.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dpopFetchWrapper = dpopFetchWrapper;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const base64_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
// "undefined" in non https environments or environments without crypto
const subtle = globalThis.crypto?.subtle;
const ReadableStream = globalThis.ReadableStream;
function dpopFetchWrapper({ key, iss, supportedAlgs, nonces, sha256 = typeof subtle !== 'undefined' ? subtleSha256 : undefined, isAuthServer, fetch = globalThis.fetch }) {
    if (!sha256) {
        throw new TypeError(`crypto.subtle is not available in this environment. Please provide a sha256 function.`);
    }
    const alg = negotiateAlg(key, supportedAlgs);
    return async function(input, init) {
        if (!key.algorithms.includes(alg)) {
            throw new TypeError(`Key does not support the algorithm ${alg}`);
        }
        const request = init == null && input instanceof Request ? input : new Request(input, init);
        const authorizationHeader = request.headers.get('Authorization');
        const ath = authorizationHeader?.startsWith('DPoP ') ? await sha256(authorizationHeader.slice(5)) : undefined;
        const { method, url } = request;
        const { origin } = new URL(url);
        let initNonce;
        try {
            initNonce = await nonces.get(origin);
        } catch  {
        // Ignore get errors, we will just not send a nonce
        }
        const initProof = await buildProof(key, alg, iss, method, url, initNonce, ath);
        request.headers.set('DPoP', initProof);
        const initResponse = await fetch.call(this, request);
        // Make sure the response body is consumed. Either by the caller (when the
        // response is returned), of if an error is thrown (catch block).
        const nextNonce = initResponse.headers.get('DPoP-Nonce');
        if (!nextNonce || nextNonce === initNonce) {
            // No nonce was returned or it is the same as the one we sent. No need to
            // update the nonce store, or retry the request.
            return initResponse;
        }
        // Store the fresh nonce for future requests
        try {
            await nonces.set(origin, nextNonce);
        } catch  {
        // Ignore set errors
        }
        const shouldRetry = await isUseDpopNonceError(initResponse, isAuthServer);
        if (!shouldRetry) {
            // Not a "use_dpop_nonce" error, so there is no need to retry
            return initResponse;
        }
        // If the input stream was already consumed, we cannot retry the request. A
        // solution would be to clone() the request but that would bufferize the
        // entire stream in memory which can lead to memory starvation. Instead, we
        // will return the original response and let the calling code handle retries.
        if (input === request) {
            // The input request body was consumed. We cannot retry the request.
            return initResponse;
        }
        if (ReadableStream && init?.body instanceof ReadableStream) {
            // The init body was consumed. We cannot retry the request.
            return initResponse;
        }
        // We will now retry the request with the fresh nonce.
        // The initial response body must be consumed (see cancelBody's doc).
        await (0, fetch_1.cancelBody)(initResponse, 'log');
        const nextProof = await buildProof(key, alg, iss, method, url, nextNonce, ath);
        const nextRequest = new Request(input, init);
        nextRequest.headers.set('DPoP', nextProof);
        return fetch.call(this, nextRequest);
    };
}
async function buildProof(key, alg, iss, htm, htu, nonce, ath) {
    if (!key.bareJwk) {
        throw new Error('Only asymmetric keys can be used as DPoP proofs');
    }
    const now = Math.floor(Date.now() / 1e3);
    return key.createJwt(// https://datatracker.ietf.org/doc/html/rfc9449#section-4.2
    {
        alg,
        typ: 'dpop+jwt',
        jwk: key.bareJwk
    }, {
        iss,
        iat: now,
        // Any collision will cause the request to be rejected by the server. no biggie.
        jti: Math.random().toString(36).slice(2),
        htm,
        htu,
        nonce,
        ath
    });
}
async function isUseDpopNonceError(response, isAuthServer) {
    // https://datatracker.ietf.org/doc/html/rfc6750#section-3
    // https://datatracker.ietf.org/doc/html/rfc9449#name-resource-server-provided-no
    if (isAuthServer === undefined || isAuthServer === false) {
        if (response.status === 401) {
            const wwwAuth = response.headers.get('WWW-Authenticate');
            if (wwwAuth?.startsWith('DPoP')) {
                return wwwAuth.includes('error="use_dpop_nonce"');
            }
        }
    }
    // https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid
    if (isAuthServer === undefined || isAuthServer === true) {
        if (response.status === 400) {
            try {
                const json = await (0, fetch_1.peekJson)(response, 10 * 1024);
                return typeof json === 'object' && json?.['error'] === 'use_dpop_nonce';
            } catch  {
                // Response too big (to be "use_dpop_nonce" error) or invalid JSON
                return false;
            }
        }
    }
    return false;
}
function negotiateAlg(key, supportedAlgs) {
    if (supportedAlgs) {
        // Use order of supportedAlgs as preference
        const alg = supportedAlgs.find((a)=>key.algorithms.includes(a));
        if (alg) return alg;
    } else {
        const [alg] = key.algorithms;
        if (alg) return alg;
    }
    throw new Error('Key does not match any alg supported by the server');
}
async function subtleSha256(input) {
    if (subtle == null) {
        throw new Error(`crypto.subtle is not available in this environment. Please provide a sha256 function.`);
    }
    const bytes = new TextEncoder().encode(input);
    const digest = await subtle.digest('SHA-256', bytes);
    const digestBytes = new Uint8Array(digest);
    return base64_1.base64url.baseEncode(digestBytes);
} //# sourceMappingURL=fetch-dpop.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthResponseError = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
class OAuthResponseError extends Error {
    constructor(response, payload){
        const error = (0, fetch_1.ifString)((0, fetch_1.ifObject)(payload)?.['error']);
        const errorDescription = (0, fetch_1.ifString)((0, fetch_1.ifObject)(payload)?.['error_description']);
        const messageError = error ? `"${error}"` : 'unknown';
        const messageDesc = errorDescription ? `: ${errorDescription}` : '';
        const message = `OAuth ${messageError} error${messageDesc}`;
        super(message);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: response
        });
        Object.defineProperty(this, "payload", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: payload
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "errorDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.error = error;
        this.errorDescription = errorDescription;
    }
    get status() {
        return this.response.status;
    }
    get headers() {
        return this.response.headers;
    }
}
exports.OAuthResponseError = OAuthResponseError; //# sourceMappingURL=oauth-response-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-server-agent.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __addDisposableResource = this && this.__addDisposableResource || function(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
};
var __disposeResources = this && this.__disposeResources || function(SuppressedError1) {
    return function(env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError1(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthServerAgent = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const atproto_token_response_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/atproto-token-response.js [app-ssr] (ecmascript)");
const constants_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/constants.js [app-ssr] (ecmascript)");
const token_refresh_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)");
const fetch_dpop_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/fetch-dpop.js [app-ssr] (ecmascript)");
const oauth_response_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
class OAuthServerAgent {
    constructor(dpopKey, serverMetadata, clientMetadata, dpopNonces, oauthResolver, runtime, keyset, fetch){
        Object.defineProperty(this, "dpopKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dpopKey
        });
        Object.defineProperty(this, "serverMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: serverMetadata
        });
        Object.defineProperty(this, "clientMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clientMetadata
        });
        Object.defineProperty(this, "dpopNonces", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dpopNonces
        });
        Object.defineProperty(this, "oauthResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: oauthResolver
        });
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: runtime
        });
        Object.defineProperty(this, "keyset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyset
        });
        Object.defineProperty(this, "dpopFetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dpopFetch = (0, fetch_dpop_js_1.dpopFetchWrapper)({
            fetch: (0, fetch_1.bindFetch)(fetch),
            iss: clientMetadata.client_id,
            key: dpopKey,
            supportedAlgs: serverMetadata.dpop_signing_alg_values_supported,
            sha256: async (v)=>runtime.sha256(v),
            nonces: dpopNonces,
            isAuthServer: true
        });
    }
    get issuer() {
        return this.serverMetadata.issuer;
    }
    async revoke(token) {
        try {
            await this.request('revocation', {
                token
            });
        } catch  {
        // Don't care
        }
    }
    async exchangeCode(code, codeVerifier) {
        const now = Date.now();
        const tokenResponse = await this.request('token', {
            grant_type: 'authorization_code',
            redirect_uri: this.clientMetadata.redirect_uris[0],
            code,
            code_verifier: codeVerifier
        });
        try {
            // /!\ IMPORTANT /!\
            //
            // The tokenResponse MUST always be valid before the "sub" it contains
            // can be trusted (see Atproto's OAuth spec for details).
            const aud = await this.verifyIssuer(tokenResponse.sub);
            return {
                aud,
                sub: tokenResponse.sub,
                iss: this.issuer,
                scope: tokenResponse.scope,
                refresh_token: tokenResponse.refresh_token,
                access_token: tokenResponse.access_token,
                token_type: tokenResponse.token_type,
                expires_at: typeof tokenResponse.expires_in === 'number' ? new Date(now + tokenResponse.expires_in * 1000).toISOString() : undefined
            };
        } catch (err) {
            await this.revoke(tokenResponse.access_token);
            throw err;
        }
    }
    async refresh(tokenSet) {
        if (!tokenSet.refresh_token) {
            throw new token_refresh_error_js_1.TokenRefreshError(tokenSet.sub, 'No refresh token available');
        }
        // /!\ IMPORTANT /!\
        //
        // The "sub" MUST be a DID, whose issuer authority is indeed the server we
        // are trying to obtain credentials from. Note that we are doing this
        // *before* we actually try to refresh the token:
        // 1) To avoid unnecessary refresh
        // 2) So that the refresh is the last async operation, ensuring as few
        //    async operations happen before the result gets a chance to be stored.
        const aud = await this.verifyIssuer(tokenSet.sub);
        const now = Date.now();
        const tokenResponse = await this.request('token', {
            grant_type: 'refresh_token',
            refresh_token: tokenSet.refresh_token
        });
        return {
            aud,
            sub: tokenSet.sub,
            iss: this.issuer,
            scope: tokenResponse.scope,
            refresh_token: tokenResponse.refresh_token,
            access_token: tokenResponse.access_token,
            token_type: tokenResponse.token_type,
            expires_at: typeof tokenResponse.expires_in === 'number' ? new Date(now + tokenResponse.expires_in * 1000).toISOString() : undefined
        };
    }
    /**
     * VERY IMPORTANT ! Always call this to process token responses.
     *
     * Whenever an OAuth token response is received, we **MUST** verify that the
     * "sub" is a DID, whose issuer authority is indeed the server we just
     * obtained credentials from. This check is a critical step to actually be
     * able to use the "sub" (DID) as being the actual user's identifier.
     *
     * @returns The user's PDS URL (the resource server for the user)
     */ async verifyIssuer(sub) {
        const env_1 = {
            stack: [],
            error: void 0,
            hasError: false
        };
        try {
            const signal = __addDisposableResource(env_1, (0, util_js_1.timeoutSignal)(10e3), false);
            const resolved = await this.oauthResolver.resolveFromIdentity(sub, {
                noCache: true,
                allowStale: false,
                signal
            });
            if (this.issuer !== resolved.metadata.issuer) {
                // Best case scenario; the user switched PDS. Worst case scenario; a bad
                // actor is trying to impersonate a user. In any case, we must not allow
                // this token to be used.
                throw new TypeError('Issuer mismatch');
            }
            return resolved.identity.pds.href;
        } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        } finally{
            __disposeResources(env_1);
        }
    }
    async request(endpoint, payload) {
        const url = this.serverMetadata[`${endpoint}_endpoint`];
        if (!url) throw new Error(`No ${endpoint} endpoint available`);
        const auth = await this.buildClientAuth(endpoint);
        const { response, json } = await this.dpopFetch(url, {
            method: 'POST',
            headers: {
                ...auth.headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ...payload,
                ...auth.payload
            })
        }).then((0, fetch_1.fetchJsonProcessor)());
        if (response.ok) {
            switch(endpoint){
                case 'token':
                    return atproto_token_response_js_1.atprotoTokenResponseSchema.parse(json);
                case 'pushed_authorization_request':
                    return oauth_types_1.oauthParResponseSchema.parse(json);
                default:
                    return json;
            }
        } else {
            throw new oauth_response_error_js_1.OAuthResponseError(response, json);
        }
    }
    async buildClientAuth(endpoint) {
        const methodSupported = this.serverMetadata[`token_endpoint_auth_methods_supported`];
        const method = this.clientMetadata[`token_endpoint_auth_method`];
        if (method === 'private_key_jwt' || this.keyset && !method && (methodSupported?.includes('private_key_jwt') ?? false)) {
            if (!this.keyset) throw new Error('No keyset available');
            try {
                const alg = this.serverMetadata[`token_endpoint_auth_signing_alg_values_supported`] ?? constants_js_1.FALLBACK_ALG;
                // If jwks is defined, make sure to only sign using a key that exists in
                // the jwks. If jwks_uri is defined, we can't be sure that the key we're
                // looking for is in there so we will just assume it is.
                const kid = this.clientMetadata.jwks?.keys.map(({ kid })=>kid).filter((v)=>typeof v === 'string');
                return {
                    payload: {
                        client_id: this.clientMetadata.client_id,
                        client_assertion_type: oauth_types_1.CLIENT_ASSERTION_TYPE_JWT_BEARER,
                        client_assertion: await this.keyset.createJwt({
                            alg,
                            kid
                        }, {
                            iss: this.clientMetadata.client_id,
                            sub: this.clientMetadata.client_id,
                            aud: this.serverMetadata.issuer,
                            jti: await this.runtime.generateNonce(),
                            iat: Math.floor(Date.now() / 1000)
                        })
                    }
                };
            } catch (err) {
                if (method === 'private_key_jwt') throw err;
            // Else try next method
            }
        }
        if (method === 'none' || !method && (methodSupported?.includes('none') ?? true)) {
            return {
                payload: {
                    client_id: this.clientMetadata.client_id
                }
            };
        }
        throw new Error(`Unsupported ${endpoint} authentication method`);
    }
}
exports.OAuthServerAgent = OAuthServerAgent; //# sourceMappingURL=oauth-server-agent.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-server-factory.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthServerFactory = void 0;
const oauth_server_agent_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-agent.js [app-ssr] (ecmascript)");
class OAuthServerFactory {
    constructor(clientMetadata, runtime, resolver, fetch, keyset, dpopNonceCache){
        Object.defineProperty(this, "clientMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clientMetadata
        });
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: runtime
        });
        Object.defineProperty(this, "resolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolver
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fetch
        });
        Object.defineProperty(this, "keyset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyset
        });
        Object.defineProperty(this, "dpopNonceCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dpopNonceCache
        });
    }
    async fromIssuer(issuer, dpopKey, options) {
        const serverMetadata = await this.resolver.getAuthorizationServerMetadata(issuer, options);
        return this.fromMetadata(serverMetadata, dpopKey);
    }
    async fromMetadata(serverMetadata, dpopKey) {
        return new oauth_server_agent_js_1.OAuthServerAgent(dpopKey, serverMetadata, this.clientMetadata, this.dpopNonceCache, this.resolver, this.runtime, this.keyset, this.fetch);
    }
}
exports.OAuthServerFactory = OAuthServerFactory; //# sourceMappingURL=oauth-server-factory.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenInvalidError = void 0;
class TokenInvalidError extends Error {
    constructor(sub, message = `The session for "${sub}" is invalid`, options){
        super(message, options);
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
    }
}
exports.TokenInvalidError = TokenInvalidError; //# sourceMappingURL=token-invalid-error.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-session.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthSession = void 0;
const fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
const token_invalid_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)");
const token_revoked_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)");
const fetch_dpop_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/fetch-dpop.js [app-ssr] (ecmascript)");
const ReadableStream = globalThis.ReadableStream;
class OAuthSession {
    constructor(server, sub, sessionGetter, fetch = globalThis.fetch){
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: server
        });
        Object.defineProperty(this, "sub", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sub
        });
        Object.defineProperty(this, "sessionGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sessionGetter
        });
        Object.defineProperty(this, "dpopFetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dpopFetch = (0, fetch_dpop_js_1.dpopFetchWrapper)({
            fetch: (0, fetch_1.bindFetch)(fetch),
            iss: server.clientMetadata.client_id,
            key: server.dpopKey,
            supportedAlgs: server.serverMetadata.dpop_signing_alg_values_supported,
            sha256: async (v)=>server.runtime.sha256(v),
            nonces: server.dpopNonces,
            isAuthServer: false
        });
    }
    get did() {
        return this.sub;
    }
    get serverMetadata() {
        return this.server.serverMetadata;
    }
    /**
     * @param refresh When `true`, the credentials will be refreshed even if they
     * are not expired. When `false`, the credentials will not be refreshed even
     * if they are expired. When `undefined`, the credentials will be refreshed
     * if, and only if, they are (about to be) expired. Defaults to `undefined`.
     */ async getTokenSet(refresh) {
        const { tokenSet } = await this.sessionGetter.get(this.sub, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
        return tokenSet;
    }
    async getTokenInfo(refresh = 'auto') {
        const tokenSet = await this.getTokenSet(refresh);
        const expiresAt = tokenSet.expires_at == null ? undefined : new Date(tokenSet.expires_at);
        return {
            expiresAt,
            get expired () {
                return expiresAt == null ? undefined : expiresAt.getTime() < Date.now() - 5e3;
            },
            scope: tokenSet.scope,
            iss: tokenSet.iss,
            aud: tokenSet.aud,
            sub: tokenSet.sub
        };
    }
    async signOut() {
        try {
            const tokenSet = await this.getTokenSet(false);
            await this.server.revoke(tokenSet.access_token);
        } finally{
            await this.sessionGetter.delStored(this.sub, new token_revoked_error_js_1.TokenRevokedError(this.sub));
        }
    }
    async fetchHandler(pathname, init) {
        // This will try and refresh the token if it is known to be expired
        const tokenSet = await this.getTokenSet('auto');
        const initialUrl = new URL(pathname, tokenSet.aud);
        const initialAuth = `${tokenSet.token_type} ${tokenSet.access_token}`;
        const headers = new Headers(init?.headers);
        headers.set('Authorization', initialAuth);
        const initialResponse = await this.dpopFetch(initialUrl, {
            ...init,
            headers
        });
        // If the token is not expired, we don't need to refresh it
        if (!isInvalidTokenResponse(initialResponse)) {
            return initialResponse;
        }
        let tokenSetFresh;
        try {
            // Force a refresh
            tokenSetFresh = await this.getTokenSet(true);
        } catch (err) {
            return initialResponse;
        }
        // The stream was already consumed. We cannot retry the request. A solution
        // would be to tee() the input stream but that would bufferize the entire
        // stream in memory which can lead to memory starvation. Instead, we will
        // return the original response and let the calling code handle retries.
        if (ReadableStream && init?.body instanceof ReadableStream) {
            return initialResponse;
        }
        const finalAuth = `${tokenSetFresh.token_type} ${tokenSetFresh.access_token}`;
        const finalUrl = new URL(pathname, tokenSetFresh.aud);
        headers.set('Authorization', finalAuth);
        const finalResponse = await this.dpopFetch(finalUrl, {
            ...init,
            headers
        });
        // The token was successfully refreshed, but is still not accepted by the
        // resource server. This might be due to the resource server not accepting
        // credentials from the authorization server (e.g. because some migration
        // occurred). Any ways, there is no point in keeping the session.
        if (isInvalidTokenResponse(finalResponse)) {
            // TODO: Is there a "softer" way to handle this, e.g. by marking the
            // session as "expired" in the session store, allowing the user to trigger
            // a new login (using login_hint)?
            await this.sessionGetter.delStored(this.sub, new token_invalid_error_js_1.TokenInvalidError(this.sub));
        }
        return finalResponse;
    }
}
exports.OAuthSession = OAuthSession;
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc6750#section-3}
 * @see {@link https://datatracker.ietf.org/doc/html/rfc9449#name-resource-server-provided-no}
 */ function isInvalidTokenResponse(response) {
    if (response.status !== 401) return false;
    const wwwAuth = response.headers.get('WWW-Authenticate');
    return wwwAuth != null && (wwwAuth.startsWith('Bearer ') || wwwAuth.startsWith('DPoP ')) && wwwAuth.includes('error="invalid_token"');
} //# sourceMappingURL=oauth-session.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/lock.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.requestLocalLock = void 0;
const locks = new Map();
function acquireLocalLock(name) {
    return new Promise((resolveAcquire)=>{
        const prev = locks.get(name) ?? Promise.resolve();
        const next = prev.then(()=>{
            return new Promise((resolveRelease)=>{
                const release = ()=>{
                    // Only delete the lock if it is still the current one
                    if (locks.get(name) === next) locks.delete(name);
                    resolveRelease();
                };
                resolveAcquire(release);
            });
        });
        locks.set(name, next);
    });
}
const requestLocalLock = (name, fn)=>{
    return acquireLocalLock(name).then(async (release)=>{
        try {
            return await fn();
        } finally{
            release();
        }
    });
};
exports.requestLocalLock = requestLocalLock; //# sourceMappingURL=lock.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Runtime = void 0;
const base64_1 = __turbopack_require__("[project]/node_modules/multiformats/cjs/src/bases/base64.js [app-ssr] (ecmascript)");
const lock_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/lock.js [app-ssr] (ecmascript)");
class Runtime {
    constructor(implementation){
        Object.defineProperty(this, "implementation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: implementation
        });
        Object.defineProperty(this, "hasImplementationLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "usingLock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { requestLock } = implementation;
        this.hasImplementationLock = requestLock != null;
        this.usingLock = requestLock?.bind(implementation) || // Falling back to a local lock
        lock_js_1.requestLocalLock;
    }
    async generateKey(algs) {
        const algsSorted = Array.from(algs).sort(compareAlgos);
        return this.implementation.createKey(algsSorted);
    }
    async sha256(text) {
        const bytes = new TextEncoder().encode(text);
        const digest = await this.implementation.digest(bytes, {
            name: 'sha256'
        });
        return base64_1.base64url.baseEncode(digest);
    }
    async generateNonce(length = 16) {
        const bytes = await this.implementation.getRandomValues(length);
        return base64_1.base64url.baseEncode(bytes);
    }
    async generatePKCE(byteLength) {
        const verifier = await this.generateVerifier(byteLength);
        return {
            verifier,
            challenge: await this.sha256(verifier),
            method: 'S256'
        };
    }
    async calculateJwkThumbprint(jwk) {
        const components = extractJktComponents(jwk);
        const data = JSON.stringify(components);
        return this.sha256(data);
    }
    /**
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7636#section-4.1}
     * @note It is RECOMMENDED that the output of a suitable random number generator
     * be used to create a 32-octet sequence. The octet sequence is then
     * base64url-encoded to produce a 43-octet URL safe string to use as the code
     * verifier.
     */ async generateVerifier(byteLength = 32) {
        if (byteLength < 32 || byteLength > 96) {
            throw new TypeError('Invalid code_verifier length');
        }
        const bytes = await this.implementation.getRandomValues(byteLength);
        return base64_1.base64url.baseEncode(bytes);
    }
}
exports.Runtime = Runtime;
function extractJktComponents(jwk) {
    const get = (field)=>{
        const value = jwk[field];
        if (typeof value !== 'string' || !value) {
            throw new TypeError(`"${field}" Parameter missing or invalid`);
        }
        return value;
    };
    switch(jwk.kty){
        case 'EC':
            return {
                crv: get('crv'),
                kty: get('kty'),
                x: get('x'),
                y: get('y')
            };
        case 'OKP':
            return {
                crv: get('crv'),
                kty: get('kty'),
                x: get('x')
            };
        case 'RSA':
            return {
                e: get('e'),
                kty: get('kty'),
                n: get('n')
            };
        case 'oct':
            return {
                k: get('k'),
                kty: get('kty')
            };
        default:
            throw new TypeError('"kty" (Key Type) Parameter missing or unsupported');
    }
}
/**
 * 256K > ES (256 > 384 > 512) > PS (256 > 384 > 512) > RS (256 > 384 > 512) > other (in original order)
 */ function compareAlgos(a, b) {
    if (a === 'ES256K') return -1;
    if (b === 'ES256K') return 1;
    for (const prefix of [
        'ES',
        'PS',
        'RS'
    ]){
        if (a.startsWith(prefix)) {
            if (b.startsWith(prefix)) {
                const aLen = parseInt(a.slice(2, 5));
                const bLen = parseInt(b.slice(2, 5));
                // Prefer shorter key lengths
                return aLen - bLen;
            }
            return -1;
        } else if (b.startsWith(prefix)) {
            return 1;
        }
    }
    // Don't know how to compare, keep original order
    return 0;
} //# sourceMappingURL=runtime.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/session-getter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __addDisposableResource = this && this.__addDisposableResource || function(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
};
var __disposeResources = this && this.__disposeResources || function(SuppressedError1) {
    return function(env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError1(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionGetter = void 0;
const simple_store_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store/dist/index.js [app-ssr] (ecmascript)");
const token_invalid_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)");
const token_refresh_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)");
const token_revoked_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)");
const oauth_response_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
/**
 * There are several advantages to wrapping the sessionStore in a (single)
 * CachedGetter, the main of which is that the cached getter will ensure that at
 * most one fresh call is ever being made. Another advantage, is that it
 * contains the logic for reading from the cache which, if the cache is based on
 * localStorage/indexedDB, will sync across multiple tabs (for a given sub).
 */ class SessionGetter extends simple_store_1.CachedGetter {
    constructor(sessionStore, serverFactory, runtime){
        super(async (sub, options, storedSession)=>{
            // There needs to be a previous session to be able to refresh. If
            // storedSession is undefined, it means that the store does not contain
            // a session for the given sub.
            if (storedSession === undefined) {
                // Because the session is not in the store, this.delStored() method
                // will not be called by the CachedGetter class (because there is
                // nothing to delete). This would typically happen if there is no
                // synchronization mechanism between instances of this class. Let's
                // make sure an event is dispatched here if this occurs.
                const msg = 'The session was deleted by another process';
                const cause = new token_refresh_error_js_1.TokenRefreshError(sub, msg);
                this.dispatchEvent('deleted', {
                    sub,
                    cause
                });
                throw cause;
            }
            // From this point forward, throwing a TokenRefreshError will result in
            // this.delStored() being called, resulting in an event being
            // dispatched, even if the session was removed from the store through a
            // concurrent access (which, normally, should not happen if a proper
            // runtime lock was provided).
            const { dpopKey, tokenSet } = storedSession;
            if (sub !== tokenSet.sub) {
                // Fool-proofing (e.g. against invalid session storage)
                throw new token_refresh_error_js_1.TokenRefreshError(sub, 'Stored session sub mismatch');
            }
            if (!tokenSet.refresh_token) {
                throw new token_refresh_error_js_1.TokenRefreshError(sub, 'No refresh token available');
            }
            // Since refresh tokens can only be used once, we might run into
            // concurrency issues if multiple instances (e.g. browser tabs) are
            // trying to refresh the same token simultaneously. The chances of this
            // happening when multiple instances are started simultaneously is
            // reduced by randomizing the expiry time (see isStale() below). The
            // best solution is to use a mutex/lock to ensure that only one instance
            // is refreshing the token at a time (runtime.usingLock) but that is not
            // always possible. If no lock implementation is provided, we will use
            // the store to check if a concurrent refresh occurred.
            const server = await serverFactory.fromIssuer(tokenSet.iss, dpopKey);
            // Because refresh tokens can only be used once, we must not use the
            // "signal" to abort the refresh, or throw any abort error beyond this
            // point. Any thrown error beyond this point will prevent the
            // TokenGetter from obtaining, and storing, the new token set,
            // effectively rendering the currently saved session unusable.
            options?.signal?.throwIfAborted();
            try {
                const newTokenSet = await server.refresh(tokenSet);
                if (sub !== newTokenSet.sub) {
                    // The server returned another sub. Was the tokenSet manipulated?
                    throw new token_refresh_error_js_1.TokenRefreshError(sub, 'Token set sub mismatch');
                }
                return {
                    dpopKey,
                    tokenSet: newTokenSet
                };
            } catch (cause) {
                // If the refresh token is invalid, let's try to recover from
                // concurrency issues, or make sure the session is deleted by throwing
                // a TokenRefreshError.
                if (cause instanceof oauth_response_error_js_1.OAuthResponseError && cause.status === 400 && cause.error === 'invalid_grant') {
                    // In case there is no lock implementation in the runtime, we will
                    // wait for a short time to give the other concurrent instances a
                    // chance to finish their refreshing of the token. If a concurrent
                    // refresh did occur, we will pretend that this one succeeded.
                    if (!runtime.hasImplementationLock) {
                        await new Promise((r)=>setTimeout(r, 1000));
                        const stored = await this.getStored(sub);
                        if (stored === undefined) {
                            // A concurrent refresh occurred and caused the session to be
                            // deleted (for a reason we can't know at this point).
                            // Using a distinct error message mainly for debugging
                            // purposes. Also, throwing a TokenRefreshError to trigger
                            // deletion through the deleteOnError callback.
                            const msg = 'The session was deleted by another process';
                            throw new token_refresh_error_js_1.TokenRefreshError(sub, msg, {
                                cause
                            });
                        } else if (stored.tokenSet.access_token !== tokenSet.access_token || stored.tokenSet.refresh_token !== tokenSet.refresh_token) {
                            // A concurrent refresh occurred. Pretend this one succeeded.
                            return stored;
                        } else {
                        // There were no concurrent refresh. The token is (likely)
                        // simply no longer valid.
                        }
                    }
                    // Make sure the session gets deleted from the store
                    const msg = cause.errorDescription ?? 'The session was revoked';
                    throw new token_refresh_error_js_1.TokenRefreshError(sub, msg, {
                        cause
                    });
                }
                throw cause;
            }
        }, sessionStore, {
            isStale: (sub, { tokenSet })=>{
                return tokenSet.expires_at != null && new Date(tokenSet.expires_at).getTime() < Date.now() + // Add some lee way to ensure the token is not expired when it
                // reaches the server.
                10e3 + // Add some randomness to reduce the chances of multiple
                // instances trying to refresh the token at the same.
                30e3 * Math.random();
            },
            onStoreError: async (err, sub, { tokenSet, dpopKey })=>{
                // If the token data cannot be stored, let's revoke it
                const server = await serverFactory.fromIssuer(tokenSet.iss, dpopKey);
                await server.revoke(tokenSet.refresh_token ?? tokenSet.access_token);
                throw err;
            },
            deleteOnError: async (err)=>// Optimization: More likely to happen first
                err instanceof token_refresh_error_js_1.TokenRefreshError || err instanceof token_revoked_error_js_1.TokenRevokedError || err instanceof token_invalid_error_js_1.TokenInvalidError
        });
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: runtime
        });
        Object.defineProperty(this, "eventTarget", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new util_js_1.CustomEventTarget()
        });
    }
    addEventListener(type, callback, options) {
        this.eventTarget.addEventListener(type, callback, options);
    }
    removeEventListener(type, callback, options) {
        this.eventTarget.removeEventListener(type, callback, options);
    }
    dispatchEvent(type, detail) {
        return this.eventTarget.dispatchCustomEvent(type, detail);
    }
    async setStored(sub, session) {
        // Prevent tampering with the stored value
        if (sub !== session.tokenSet.sub) {
            throw new TypeError('Token set does not match the expected sub');
        }
        await super.setStored(sub, session);
        this.dispatchEvent('updated', {
            sub,
            ...session
        });
    }
    async delStored(sub, cause) {
        await super.delStored(sub, cause);
        this.dispatchEvent('deleted', {
            sub,
            cause
        });
    }
    /**
     * @param refresh When `true`, the credentials will be refreshed even if they
     * are not expired. When `false`, the credentials will not be refreshed even
     * if they are expired. When `undefined`, the credentials will be refreshed
     * if, and only if, they are (about to be) expired. Defaults to `undefined`.
     */ async getSession(sub, refresh) {
        return this.get(sub, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
    }
    async get(sub, options) {
        const session = await this.runtime.usingLock(`@atproto-oauth-client-${sub}`, async ()=>{
            const env_1 = {
                stack: [],
                error: void 0,
                hasError: false
            };
            try {
                // Make sure, even if there is no signal in the options, that the
                // request will be cancelled after at most 30 seconds.
                const signal = __addDisposableResource(env_1, (0, util_js_1.timeoutSignal)(30e3, options), false);
                const abortController = __addDisposableResource(env_1, (0, util_js_1.combineSignals)([
                    options?.signal,
                    signal
                ]), false);
                return await super.get(sub, {
                    ...options,
                    signal: abortController.signal
                });
            } catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            } finally{
                __disposeResources(env_1);
            }
        });
        if (sub !== session.tokenSet.sub) {
            // Fool-proofing (e.g. against invalid session storage)
            throw new Error('Token set does not match the expected sub');
        }
        return session;
    }
}
exports.SessionGetter = SessionGetter; //# sourceMappingURL=session-getter.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clientMetadataSchema = void 0;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-ssr] (ecmascript)");
exports.clientMetadataSchema = oauth_types_1.oauthClientMetadataSchema.extend({
    client_id: zod_1.z.union([
        oauth_types_1.oauthClientIdDiscoverableSchema,
        oauth_types_1.oauthClientIdLoopbackSchema
    ])
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/validate-client-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateClientMetadata = validateClientMetadata;
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const types_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/types.js [app-ssr] (ecmascript)");
const TOKEN_ENDPOINT_AUTH_METHOD = `token_endpoint_auth_method`;
const TOKEN_ENDPOINT_AUTH_SIGNING_ALG = `token_endpoint_auth_signing_alg`;
function validateClientMetadata(input, keyset) {
    if (input.jwks) {
        if (!keyset) {
            throw new TypeError(`Keyset must not be provided when jwks is provided`);
        }
        for (const key of input.jwks.keys){
            if (!key.kid) {
                throw new TypeError(`Key must have a "kid" property`);
            } else if (!keyset.has(key.kid)) {
                throw new TypeError(`Key with kid "${key.kid}" not found in keyset`);
            }
        }
    }
    // Allow to pass a keyset and omit the jwks/jwks_uri properties
    if (!input.jwks && !input.jwks_uri && keyset?.size) {
        input = {
            ...input,
            jwks: keyset.toJSON()
        };
    }
    const metadata = types_js_1.clientMetadataSchema.parse(input);
    // Validate client ID
    if (metadata.client_id.startsWith('http:')) {
        (0, oauth_types_1.assertOAuthLoopbackClientId)(metadata.client_id);
    } else {
        (0, oauth_types_1.assertOAuthDiscoverableClientId)(metadata.client_id);
    }
    const scopes = metadata.scope?.split(' ');
    if (!scopes?.includes('atproto')) {
        throw new TypeError(`Client metadata must include the "atproto" scope`);
    }
    if (!metadata.response_types.includes('code')) {
        throw new TypeError(`"response_types" must include "code"`);
    }
    if (!metadata.grant_types.includes('authorization_code')) {
        throw new TypeError(`"grant_types" must include "authorization_code"`);
    }
    const method = metadata[TOKEN_ENDPOINT_AUTH_METHOD];
    switch(method){
        case undefined:
            throw new TypeError(`${TOKEN_ENDPOINT_AUTH_METHOD} must be provided`);
        case 'none':
            if (metadata[TOKEN_ENDPOINT_AUTH_SIGNING_ALG]) {
                throw new TypeError(`${TOKEN_ENDPOINT_AUTH_SIGNING_ALG} must not be provided when ${TOKEN_ENDPOINT_AUTH_METHOD} is "${method}"`);
            }
            break;
        case 'private_key_jwt':
            if (!keyset?.size) {
                throw new TypeError(`A non-empty keyset must be provided when ${TOKEN_ENDPOINT_AUTH_METHOD} is "${method}"`);
            }
            if (!metadata[TOKEN_ENDPOINT_AUTH_SIGNING_ALG]) {
                throw new TypeError(`${TOKEN_ENDPOINT_AUTH_SIGNING_ALG} must be provided when ${TOKEN_ENDPOINT_AUTH_METHOD} is "${method}"`);
            }
            break;
        default:
            throw new TypeError(`Invalid "token_endpoint_auth_method" value: ${method}`);
    }
    return metadata;
} //# sourceMappingURL=validate-client-metadata.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/oauth-client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OAuthClient = void 0;
const did_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/index.js [app-ssr] (ecmascript)");
const handle_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)");
const identity_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/identity-resolver/dist/index.js [app-ssr] (ecmascript)");
const simple_store_memory_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/simple-store-memory/dist/index.js [app-ssr] (ecmascript)");
const jwk_1 = __turbopack_require__("[project]/node_modules/@atproto/jwk/dist/index.js [app-ssr] (ecmascript)");
const oauth_types_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)");
const constants_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/constants.js [app-ssr] (ecmascript)");
const token_revoked_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)");
const oauth_authorization_server_metadata_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-authorization-server-metadata-resolver.js [app-ssr] (ecmascript)");
const oauth_callback_error_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-callback-error.js [app-ssr] (ecmascript)");
const oauth_protected_resource_metadata_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-protected-resource-metadata-resolver.js [app-ssr] (ecmascript)");
const oauth_resolver_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver.js [app-ssr] (ecmascript)");
const oauth_server_factory_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-factory.js [app-ssr] (ecmascript)");
const oauth_session_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-session.js [app-ssr] (ecmascript)");
const runtime_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/runtime.js [app-ssr] (ecmascript)");
const session_getter_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/session-getter.js [app-ssr] (ecmascript)");
const util_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/util.js [app-ssr] (ecmascript)");
const validate_client_metadata_js_1 = __turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/validate-client-metadata.js [app-ssr] (ecmascript)");
class OAuthClient extends util_js_1.CustomEventTarget {
    static async fetchMetadata({ clientId, fetch = globalThis.fetch, signal }) {
        signal?.throwIfAborted();
        const request = new Request(clientId, {
            redirect: 'error',
            signal: signal
        });
        const response = await fetch(request);
        if (response.status !== 200) {
            response.body?.cancel?.();
            throw new TypeError(`Failed to fetch client metadata: ${response.status}`);
        }
        // https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#section-4.1
        const mime = response.headers.get('content-type')?.split(';')[0].trim();
        if (mime !== 'application/json') {
            response.body?.cancel?.();
            throw new TypeError(`Invalid client metadata content type: ${mime}`);
        }
        const json = await response.json();
        signal?.throwIfAborted();
        return oauth_types_1.oauthClientMetadataSchema.parse(json);
    }
    constructor({ fetch = globalThis.fetch, allowHttp = false, stateStore, sessionStore, didCache = undefined, dpopNonceCache = new simple_store_memory_1.SimpleStoreMemory({
        ttl: 60e3,
        max: 100
    }), handleCache = undefined, authorizationServerMetadataCache = new simple_store_memory_1.SimpleStoreMemory({
        ttl: 60e3,
        max: 100
    }), protectedResourceMetadataCache = new simple_store_memory_1.SimpleStoreMemory({
        ttl: 60e3,
        max: 100
    }), responseMode, clientMetadata, handleResolver, plcDirectoryUrl, runtimeImplementation, keyset }){
        super();
        // Config
        Object.defineProperty(this, "clientMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "responseMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Services
        Object.defineProperty(this, "runtime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oauthResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "serverFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Stores
        Object.defineProperty(this, "sessionGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stateStore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.keyset = keyset ? keyset instanceof jwk_1.Keyset ? keyset : new jwk_1.Keyset(keyset) : undefined;
        this.clientMetadata = (0, validate_client_metadata_js_1.validateClientMetadata)(clientMetadata, this.keyset);
        this.responseMode = responseMode;
        this.runtime = new runtime_js_1.Runtime(runtimeImplementation);
        this.fetch = fetch;
        this.oauthResolver = new oauth_resolver_js_1.OAuthResolver(new identity_resolver_1.IdentityResolver(new did_resolver_1.DidResolverCached(new did_resolver_1.DidResolverCommon({
            fetch,
            plcDirectoryUrl,
            allowHttp
        }), didCache), new handle_resolver_1.CachedHandleResolver(handle_resolver_1.AppViewHandleResolver.from(handleResolver, {
            fetch
        }), handleCache)), new oauth_protected_resource_metadata_resolver_js_1.OAuthProtectedResourceMetadataResolver(protectedResourceMetadataCache, fetch, {
            allowHttpResource: allowHttp
        }), new oauth_authorization_server_metadata_resolver_js_1.OAuthAuthorizationServerMetadataResolver(authorizationServerMetadataCache, fetch, {
            allowHttpIssuer: allowHttp
        }));
        this.serverFactory = new oauth_server_factory_js_1.OAuthServerFactory(this.clientMetadata, this.runtime, this.oauthResolver, this.fetch, this.keyset, dpopNonceCache);
        this.sessionGetter = new session_getter_js_1.SessionGetter(sessionStore, this.serverFactory, this.runtime);
        this.stateStore = stateStore;
        // Proxy sessionGetter events
        for (const type of [
            'deleted',
            'updated'
        ]){
            this.sessionGetter.addEventListener(type, (event)=>{
                if (!this.dispatchCustomEvent(type, event.detail)) {
                    event.preventDefault();
                }
            });
        }
    }
    // Exposed as public API for convenience
    get identityResolver() {
        return this.oauthResolver.identityResolver;
    }
    // Exposed as public API for convenience
    get didResolver() {
        return this.identityResolver.didResolver;
    }
    // Exposed as public API for convenience
    get handleResolver() {
        return this.identityResolver.handleResolver;
    }
    get jwks() {
        return this.keyset?.publicJwks ?? {
            keys: []
        };
    }
    async authorize(input, { signal, ...options } = {}) {
        const redirectUri = options?.redirect_uri ?? this.clientMetadata.redirect_uris[0];
        if (!this.clientMetadata.redirect_uris.includes(redirectUri)) {
            // The server will enforce this, but let's catch it early
            throw new TypeError('Invalid redirect_uri');
        }
        const { identity, metadata } = await this.oauthResolver.resolve(input, {
            signal
        });
        const pkce = await this.runtime.generatePKCE();
        const dpopKey = await this.runtime.generateKey(metadata.dpop_signing_alg_values_supported || [
            constants_js_1.FALLBACK_ALG
        ]);
        const state = await this.runtime.generateNonce();
        await this.stateStore.set(state, {
            iss: metadata.issuer,
            dpopKey,
            verifier: pkce.verifier,
            appState: options?.state
        });
        const parameters = {
            ...options,
            client_id: this.clientMetadata.client_id,
            redirect_uri: redirectUri,
            code_challenge: pkce.challenge,
            code_challenge_method: pkce.method,
            state,
            login_hint: identity ? input // If input is a handle or a DID, use it as a login_hint
             : undefined,
            response_mode: this.responseMode,
            response_type: 'code',
            scope: options?.scope ?? this.clientMetadata.scope
        };
        const authorizationUrl = new URL(metadata.authorization_endpoint);
        // Since the user will be redirected to the authorization_endpoint url using
        // a browser, we need to make sure that the url is valid.
        if (authorizationUrl.protocol !== 'https:' && authorizationUrl.protocol !== 'http:') {
            throw new TypeError(`Invalid authorization endpoint protocol: ${authorizationUrl.protocol}`);
        }
        if (metadata.pushed_authorization_request_endpoint) {
            const server = await this.serverFactory.fromMetadata(metadata, dpopKey);
            const parResponse = await server.request('pushed_authorization_request', parameters);
            authorizationUrl.searchParams.set('client_id', this.clientMetadata.client_id);
            authorizationUrl.searchParams.set('request_uri', parResponse.request_uri);
            return authorizationUrl;
        } else if (metadata.require_pushed_authorization_requests) {
            throw new Error('Server requires pushed authorization requests (PAR) but no PAR endpoint is available');
        } else {
            for (const [key, value] of Object.entries(parameters)){
                if (value) authorizationUrl.searchParams.set(key, String(value));
            }
            // Length of the URL that will be sent to the server
            const urlLength = authorizationUrl.pathname.length + authorizationUrl.search.length;
            if (urlLength < 2048) {
                return authorizationUrl;
            } else if (!metadata.pushed_authorization_request_endpoint) {
                throw new Error('Login URL too long');
            }
        }
        throw new Error('Server does not support pushed authorization requests (PAR)');
    }
    /**
     * This method allows the client to proactively revoke the request_uri it
     * created through PAR.
     */ async abortRequest(authorizeUrl) {
        const requestUri = authorizeUrl.searchParams.get('request_uri');
        if (!requestUri) return;
    // @NOTE This is not implemented here because, 1) the request server should
    // invalidate the request_uri after some delay anyways, and 2) I am not sure
    // that the revocation endpoint is even supposed to support this (and I
    // don't want to spend the time checking now).
    // @TODO investigate actual necessity & feasibility of this feature
    }
    async callback(params) {
        const responseJwt = params.get('response');
        if (responseJwt != null) {
            // https://openid.net/specs/oauth-v2-jarm.html
            throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'JARM not supported');
        }
        const issuerParam = params.get('iss');
        const stateParam = params.get('state');
        const errorParam = params.get('error');
        const codeParam = params.get('code');
        if (!stateParam) {
            throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Missing "state" parameter');
        }
        const stateData = await this.stateStore.get(stateParam);
        if (stateData) {
            // Prevent any kind of replay
            await this.stateStore.del(stateParam);
        } else {
            throw new oauth_callback_error_js_1.OAuthCallbackError(params, `Unknown authorization session "${stateParam}"`);
        }
        try {
            if (errorParam != null) {
                throw new oauth_callback_error_js_1.OAuthCallbackError(params, undefined, stateData.appState);
            }
            if (!codeParam) {
                throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Missing "code" query param', stateData.appState);
            }
            const server = await this.serverFactory.fromIssuer(stateData.iss, stateData.dpopKey);
            if (issuerParam != null) {
                if (!server.issuer) {
                    throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Issuer not found in metadata', stateData.appState);
                }
                if (server.issuer !== issuerParam) {
                    throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'Issuer mismatch', stateData.appState);
                }
            } else if (server.serverMetadata.authorization_response_iss_parameter_supported) {
                throw new oauth_callback_error_js_1.OAuthCallbackError(params, 'iss missing from the response', stateData.appState);
            }
            const tokenSet = await server.exchangeCode(codeParam, stateData.verifier);
            try {
                await this.sessionGetter.setStored(tokenSet.sub, {
                    dpopKey: stateData.dpopKey,
                    tokenSet
                });
                const session = this.createSession(server, tokenSet.sub);
                return {
                    session,
                    state: stateData.appState ?? null
                };
            } catch (err) {
                await server.revoke(tokenSet.refresh_token || tokenSet.access_token);
                throw err;
            }
        } catch (err) {
            // Make sure, whatever the underlying error, that the appState is
            // available in the calling code
            throw oauth_callback_error_js_1.OAuthCallbackError.from(err, params, stateData.appState);
        }
    }
    /**
     * Load a stored session. This will refresh the token only if needed (about to
     * expire) by default.
     *
     * @param refresh See {@link SessionGetter.getSession}
     */ async restore(sub, refresh = 'auto') {
        // sub arg is lightly typed for convenience of library user
        (0, did_resolver_1.assertAtprotoDid)(sub);
        const { dpopKey, tokenSet } = await this.sessionGetter.get(sub, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
        const server = await this.serverFactory.fromIssuer(tokenSet.iss, dpopKey, {
            noCache: refresh === true,
            allowStale: refresh === false
        });
        return this.createSession(server, sub);
    }
    async revoke(sub) {
        // sub arg is lightly typed for convenience of library user
        (0, did_resolver_1.assertAtprotoDid)(sub);
        const { dpopKey, tokenSet } = await this.sessionGetter.get(sub, {
            allowStale: true
        });
        // NOT using `;(await this.restore(sub, false)).signOut()` because we want
        // the tokens to be deleted even if it was not possible to fetch the issuer
        // data.
        try {
            const server = await this.serverFactory.fromIssuer(tokenSet.iss, dpopKey);
            await server.revoke(tokenSet.access_token);
        } finally{
            await this.sessionGetter.delStored(sub, new token_revoked_error_js_1.TokenRevokedError(sub));
        }
    }
    createSession(server, sub) {
        return new oauth_session_js_1.OAuthSession(server, sub, this.sessionGetter, this.fetch);
    }
}
exports.OAuthClient = OAuthClient; //# sourceMappingURL=oauth-client.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/runtime-implementation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=runtime-implementation.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/state-store.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=state-store.js.map
}}),
"[project]/node_modules/@atproto/oauth-client/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchResponseError = exports.FetchRequestError = exports.FetchError = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/did-resolver/dist/index.js [app-ssr] (ecmascript)"), exports);
var fetch_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/fetch/dist/index.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FetchError", {
    enumerable: true,
    get: function() {
        return fetch_1.FetchError;
    }
});
Object.defineProperty(exports, "FetchRequestError", {
    enumerable: true,
    get: function() {
        return fetch_1.FetchRequestError;
    }
});
Object.defineProperty(exports, "FetchResponseError", {
    enumerable: true,
    get: function() {
        return fetch_1.FetchResponseError;
    }
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/did/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-types/dist/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-authorization-server-metadata-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-callback-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-client.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-protected-resource-metadata-resolver.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-resolver-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-response-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-agent.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-server-factory.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/oauth-session.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/runtime-implementation.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/session-getter.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/state-store.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-invalid-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-refresh-error.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/@atproto/oauth-client/dist/errors/token-revoked-error.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@atproto-labs/identity-resolver/dist/identity-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IdentityResolver = void 0;
const handle_resolver_1 = __turbopack_require__("[project]/node_modules/@atproto-labs/handle-resolver/dist/index.js [app-ssr] (ecmascript)");
const syntax_1 = __turbopack_require__("[project]/node_modules/@atproto/syntax/dist/index.js [app-ssr] (ecmascript)");
class IdentityResolver {
    constructor(didResolver, handleResolver){
        Object.defineProperty(this, "didResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: didResolver
        });
        Object.defineProperty(this, "handleResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: handleResolver
        });
    }
    async resolve(input, options) {
        const document = (0, handle_resolver_1.isResolvedHandle)(input) ? await this.getDocumentFromDid(input, options) : await this.getDocumentFromHandle(input, options);
        const service = document.service?.find(isAtprotoPersonalDataServerService, document);
        if (!service) {
            throw new TypeError(`No valid "AtprotoPersonalDataServer" service found in "${document.id}" DID document`);
        }
        return {
            did: document.id,
            pds: new URL(service.serviceEndpoint)
        };
    }
    async getDocumentFromDid(did, options) {
        return this.didResolver.resolve(did, options);
    }
    async getDocumentFromHandle(input, options) {
        const handle = (0, syntax_1.normalizeAndEnsureValidHandle)(input);
        const did = await this.handleResolver.resolve(handle, options);
        if (!did) {
            throw new TypeError(`Handle "${handle}" does not resolve to a DID`);
        }
        options?.signal?.throwIfAborted();
        // Note: Not using "return this.resolveDid(did, options)" to make the extra
        // check for the handle in the DID document:
        const document = await this.didResolver.resolve(did, options);
        // Ensure that the handle is included in the document
        if (!document.alsoKnownAs?.includes(`at://${handle}`)) {
            throw new TypeError(`Did document for "${did}" does not include the handle "${handle}"`);
        }
        return document;
    }
}
exports.IdentityResolver = IdentityResolver;
function isAtprotoPersonalDataServerService(s) {
    return typeof s.serviceEndpoint === 'string' && s.type === 'AtprotoPersonalDataServer' && (s.id.startsWith('#') ? s.id === '#atproto_pds' : s.id === `${this.id}#atproto_pds`);
} //# sourceMappingURL=identity-resolver.js.map
}}),
"[project]/node_modules/@atproto-labs/identity-resolver/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/@atproto-labs/identity-resolver/dist/identity-resolver.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_47a1e0._.js.map